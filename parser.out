Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    ABSTRACT
    AS
    BITAND
    BITNOT
    BITOR
    CALLABLE
    CATCH
    CLASS
    CLONE
    CONCAT
    CONCATASSIGN
    CONST
    DECLARE
    DECREMENT
    DIE
    DIVIDEASSIGN
    DO
    DOC_COMMENT
    DOUBLEQUOTE
    ELSEIF
    EMPTY
    ENDWHILE
    ERRORCONTROL
    EVAL
    EXECUTION
    EXIT
    EXPASSIGN
    EXTENDS
    FINAL
    FINALLY
    FOREACH
    GLOBAL
    GOTO
    IMPLEMENTS
    INCLUDE
    INCLUDE_ONCE
    INCREMENT
    INSTANCEOF
    INSTEADOF
    INTERFACE
    ISSET
    LIST
    LOGICALNOT
    MATCH
    MINUSASSIGN
    MODASSIGN
    NAMESPACE
    PLUSASSIGN
    PRIVATE
    PROTECTED
    PUBLIC
    QUOTE
    REQUIRE
    REQUIRE_ONCE
    RETURN
    STATIC
    THROW
    TIMESASSIGN
    TRAIT
    TRY
    UNSET
    USE
    VAR
    WHILE
    YIELD
    YIELD_FROM
    __HALT_COMPILER

Grammar

Rule 0     S' -> programa
Rule 1     programa -> cuerpo
Rule 2     programa -> programa cuerpo
Rule 3     cuerpo -> arithmeticExpression
Rule 4     cuerpo -> if_elseStatement
Rule 5     cuerpo -> forStatement
Rule 6     cuerpo -> switchStatement
Rule 7     cuerpo -> arrayAsignation
Rule 8     cuerpo -> queueDeclaration
Rule 9     cuerpo -> queueEnqueue
Rule 10    cuerpo -> queueDequeue
Rule 11    cuerpo -> defineFunction
Rule 12    cuerpo -> anonymousFunction
Rule 13    cuerpo -> arrowFunction
Rule 14    cuerpo -> echo
Rule 15    cuerpo -> fgets
Rule 16    cuerpo -> stackDeclaration
Rule 17    cuerpo -> stackPush
Rule 18    cuerpo -> stackPop
Rule 19    cuerpo -> line
Rule 20    cuerpo -> print
Rule 21    cuerpo -> logicalCondition
Rule 22    cuerpo -> OPEN_TAG
Rule 23    cuerpo -> CLOSE_TAG
Rule 24    switchStatement -> SWITCH LPAREN value RPAREN LCURLY switchCases switchDefault RCURLY
Rule 25    switchDefault -> DEFAULT COLON programa
Rule 26    switchCase -> CASE value COLON programa BREAK SEMICOLON
Rule 27    switchCases -> switchCase
Rule 28    switchCases -> switchCases switchCase
Rule 29    if_elseStatement -> IF LPAREN logicalCondition RPAREN LCURLY ifStatementBody RCURLY ELSE ifStatementBody
Rule 30    if_elseStatement -> IF LPAREN logicalCondition RPAREN LCURLY ifStatementBody
Rule 31    ifStatementBody -> cuerpo
Rule 32    ifStatementBody -> cuerpo CONTINUE SEMICOLON
Rule 33    ifStatementBody -> ifStatementBody cuerpo
Rule 34    forStatement -> FOR LPAREN forStatementCondition RPAREN LCURLY forStatementBody RCURLY
Rule 35    forStatementCondition -> SEMICOLON SEMICOLON
Rule 36    forStatementCondition -> variableAsignation SEMICOLON SEMICOLON variableAsignation
Rule 37    forStatementCondition -> variableAsignation SEMICOLON comparingValue SEMICOLON variableAsignation
Rule 38    forStatementBody -> cuerpo
Rule 39    forStatementBody -> forStatementBody cuerpo
Rule 40    arrayAsignation -> ID EQUAL arrayDeclaration SEMICOLON
Rule 41    arrayDeclaration -> ARRAY arraysValues RPAREN
Rule 42    arrayDeclaration -> LSQUARE arraysValues RSQUARE
Rule 43    arrayDeclaration -> arrayValue
Rule 44    arraysValues -> arrayValue
Rule 45    arraysValues -> arraysValues COMMA arrayValue
Rule 46    arrayValue -> ARRAY values RPAREN
Rule 47    arrayValue -> LSQUARE values RSQUARE
Rule 48    stackDeclaration -> ID EQUAL NEW STACK SEMICOLON
Rule 49    stackPush -> ID OBJOP PUSH LPAREN value RPAREN SEMICOLON
Rule 50    stackPop -> ID OBJOP POP SEMICOLON
Rule 51    queueDeclaration -> ID EQUAL NEW QUEUE SEMICOLON
Rule 52    queueEnqueue -> ID OBJOP PUSH LPAREN value RPAREN SEMICOLON
Rule 53    queueDequeue -> ID OBJOP POP SEMICOLON
Rule 54    defineFunction -> FUNCTION ID LPAREN arguments RPAREN LCURLY cuerpo RCURLY
Rule 55    defineFunction -> FUNCTION ID LPAREN RPAREN LCURLY cuerpo RCURLY
Rule 56    arguments -> ID
Rule 57    arguments -> ID COMMA arguments
Rule 58    anonymousFunction -> FUNCTION LPAREN RPAREN LCURLY cuerpo RCURLY
Rule 59    anonymousFunction -> FUNCTION LPAREN arguments RPAREN LCURLY cuerpo RCURLY
Rule 60    arrowFunction -> FN LPAREN ID RPAREN FNARROW arrowBody SEMICOLON
Rule 61    arrowBody -> FN LPAREN ID RPAREN FNARROW arrowBody
Rule 62    arrowBody -> cuerpo
Rule 63    echo -> ECHO values SEMICOLON
Rule 64    print -> PRINT LPAREN values RPAREN SEMICOLON
Rule 65    print -> PRINT value SEMICOLON
Rule 66    values -> value
Rule 67    values -> values COMMA value
Rule 68    fgets -> ID EQUAL FGETS LPAREN STDIN RPAREN SEMICOLON
Rule 69    arithmeticExpression -> value
Rule 70    arithmeticExpression -> arithmeticExpression arithmeticOperator arithmeticExpression
Rule 71    arithmeticExpression -> LPAREN arithmeticExpression RPAREN
Rule 72    value -> ID
Rule 73    value -> INTEGER
Rule 74    value -> FLOAT
Rule 75    value -> STRING
Rule 76    value -> BOOL
Rule 77    value -> NULL
Rule 78    arithmeticOperator -> PLUS
Rule 79    arithmeticOperator -> MINUS
Rule 80    arithmeticOperator -> TIMES
Rule 81    arithmeticOperator -> DIVIDE
Rule 82    arithmeticOperator -> MOD
Rule 83    arithmeticOperator -> EXP
Rule 84    line -> variableAsignation SEMICOLON
Rule 85    variableAsignation -> ID EQUAL value
Rule 86    variableAsignation -> ID EQUAL arithmeticExpression
Rule 87    comparingSign -> IS_EQUAL
Rule 88    comparingSign -> IDENTICAL
Rule 89    comparingSign -> NOTEQUAL
Rule 90    comparingSign -> LESSTHAN
Rule 91    comparingSign -> GREATERTHAN
Rule 92    comparingSign -> LESSEQUALTHAN
Rule 93    comparingSign -> GREATEREQUALTHAN
Rule 94    comparingValue -> value comparingSign value
Rule 95    logicalCondition -> comparingValue
Rule 96    logicalCondition -> comparingValue conditionOperator comparingValue
Rule 97    logicalCondition -> LPAREN logicalCondition RPAREN
Rule 98    conditionOperator -> AND
Rule 99    conditionOperator -> OR
Rule 100   conditionOperator -> XOR

Terminals, with rules where they appear

ABSTRACT             : 
AND                  : 98
ARRAY                : 41 46
AS                   : 
BITAND               : 
BITNOT               : 
BITOR                : 
BOOL                 : 76
BREAK                : 26
CALLABLE             : 
CASE                 : 26
CATCH                : 
CLASS                : 
CLONE                : 
CLOSE_TAG            : 23
COLON                : 25 26
COMMA                : 45 57 67
CONCAT               : 
CONCATASSIGN         : 
CONST                : 
CONTINUE             : 32
DECLARE              : 
DECREMENT            : 
DEFAULT              : 25
DIE                  : 
DIVIDE               : 81
DIVIDEASSIGN         : 
DO                   : 
DOC_COMMENT          : 
DOUBLEQUOTE          : 
ECHO                 : 63
ELSE                 : 29
ELSEIF               : 
EMPTY                : 
ENDWHILE             : 
EQUAL                : 40 48 51 68 85 86
ERRORCONTROL         : 
EVAL                 : 
EXECUTION            : 
EXIT                 : 
EXP                  : 83
EXPASSIGN            : 
EXTENDS              : 
FGETS                : 68
FINAL                : 
FINALLY              : 
FLOAT                : 74
FN                   : 60 61
FNARROW              : 60 61
FOR                  : 34
FOREACH              : 
FUNCTION             : 54 55 58 59
GLOBAL               : 
GOTO                 : 
GREATEREQUALTHAN     : 93
GREATERTHAN          : 91
ID                   : 40 48 49 50 51 52 53 54 55 56 57 60 61 68 72 85 86
IDENTICAL            : 88
IF                   : 29 30
IMPLEMENTS           : 
INCLUDE              : 
INCLUDE_ONCE         : 
INCREMENT            : 
INSTANCEOF           : 
INSTEADOF            : 
INTEGER              : 73
INTERFACE            : 
ISSET                : 
IS_EQUAL             : 87
LCURLY               : 24 29 30 34 54 55 58 59
LESSEQUALTHAN        : 92
LESSTHAN             : 90
LIST                 : 
LOGICALNOT           : 
LPAREN               : 24 29 30 34 49 52 54 55 58 59 60 61 64 68 71 97
LSQUARE              : 42 47
MATCH                : 
MINUS                : 79
MINUSASSIGN          : 
MOD                  : 82
MODASSIGN            : 
NAMESPACE            : 
NEW                  : 48 51
NOTEQUAL             : 89
NULL                 : 77
OBJOP                : 49 50 52 53
OPEN_TAG             : 22
OR                   : 99
PLUS                 : 78
PLUSASSIGN           : 
POP                  : 50 53
PRINT                : 64 65
PRIVATE              : 
PROTECTED            : 
PUBLIC               : 
PUSH                 : 49 52
QUEUE                : 51
QUOTE                : 
RCURLY               : 24 29 34 54 55 58 59
REQUIRE              : 
REQUIRE_ONCE         : 
RETURN               : 
RPAREN               : 24 29 30 34 41 46 49 52 54 55 58 59 60 61 64 68 71 97
RSQUARE              : 42 47
SEMICOLON            : 26 32 35 35 36 36 37 37 40 48 49 50 51 52 53 60 63 64 65 68 84
STACK                : 48
STATIC               : 
STDIN                : 68
STRING               : 75
SWITCH               : 24
THROW                : 
TIMES                : 80
TIMESASSIGN          : 
TRAIT                : 
TRY                  : 
UNSET                : 
USE                  : 
VAR                  : 
WHILE                : 
XOR                  : 100
YIELD                : 
YIELD_FROM           : 
__HALT_COMPILER      : 
error                : 

Nonterminals, with rules where they appear

anonymousFunction    : 12
arguments            : 54 57 59
arithmeticExpression : 3 70 70 71 86
arithmeticOperator   : 70
arrayAsignation      : 7
arrayDeclaration     : 40
arrayValue           : 43 44 45
arraysValues         : 41 42 45
arrowBody            : 60 61
arrowFunction        : 13
comparingSign        : 94
comparingValue       : 37 95 96 96
conditionOperator    : 96
cuerpo               : 1 2 31 32 33 38 39 54 55 58 59 62
defineFunction       : 11
echo                 : 14
fgets                : 15
forStatement         : 5
forStatementBody     : 34 39
forStatementCondition : 34
ifStatementBody      : 29 29 30 33
if_elseStatement     : 4
line                 : 19
logicalCondition     : 21 29 30 97
print                : 20
programa             : 2 25 26 0
queueDeclaration     : 8
queueDequeue         : 10
queueEnqueue         : 9
stackDeclaration     : 16
stackPop             : 18
stackPush            : 17
switchCase           : 27 28
switchCases          : 24 28
switchDefault        : 24
switchStatement      : 6
value                : 24 26 49 52 65 66 67 69 85 94 94
values               : 46 47 63 64 67
variableAsignation   : 36 36 37 37 84

Parsing method: LALR

state 0

    (0) S' -> . programa
    (1) programa -> . cuerpo
    (2) programa -> . programa cuerpo
    (3) cuerpo -> . arithmeticExpression
    (4) cuerpo -> . if_elseStatement
    (5) cuerpo -> . forStatement
    (6) cuerpo -> . switchStatement
    (7) cuerpo -> . arrayAsignation
    (8) cuerpo -> . queueDeclaration
    (9) cuerpo -> . queueEnqueue
    (10) cuerpo -> . queueDequeue
    (11) cuerpo -> . defineFunction
    (12) cuerpo -> . anonymousFunction
    (13) cuerpo -> . arrowFunction
    (14) cuerpo -> . echo
    (15) cuerpo -> . fgets
    (16) cuerpo -> . stackDeclaration
    (17) cuerpo -> . stackPush
    (18) cuerpo -> . stackPop
    (19) cuerpo -> . line
    (20) cuerpo -> . print
    (21) cuerpo -> . logicalCondition
    (22) cuerpo -> . OPEN_TAG
    (23) cuerpo -> . CLOSE_TAG
    (69) arithmeticExpression -> . value
    (70) arithmeticExpression -> . arithmeticExpression arithmeticOperator arithmeticExpression
    (71) arithmeticExpression -> . LPAREN arithmeticExpression RPAREN
    (29) if_elseStatement -> . IF LPAREN logicalCondition RPAREN LCURLY ifStatementBody RCURLY ELSE ifStatementBody
    (30) if_elseStatement -> . IF LPAREN logicalCondition RPAREN LCURLY ifStatementBody
    (34) forStatement -> . FOR LPAREN forStatementCondition RPAREN LCURLY forStatementBody RCURLY
    (24) switchStatement -> . SWITCH LPAREN value RPAREN LCURLY switchCases switchDefault RCURLY
    (40) arrayAsignation -> . ID EQUAL arrayDeclaration SEMICOLON
    (51) queueDeclaration -> . ID EQUAL NEW QUEUE SEMICOLON
    (52) queueEnqueue -> . ID OBJOP PUSH LPAREN value RPAREN SEMICOLON
    (53) queueDequeue -> . ID OBJOP POP SEMICOLON
    (54) defineFunction -> . FUNCTION ID LPAREN arguments RPAREN LCURLY cuerpo RCURLY
    (55) defineFunction -> . FUNCTION ID LPAREN RPAREN LCURLY cuerpo RCURLY
    (58) anonymousFunction -> . FUNCTION LPAREN RPAREN LCURLY cuerpo RCURLY
    (59) anonymousFunction -> . FUNCTION LPAREN arguments RPAREN LCURLY cuerpo RCURLY
    (60) arrowFunction -> . FN LPAREN ID RPAREN FNARROW arrowBody SEMICOLON
    (63) echo -> . ECHO values SEMICOLON
    (68) fgets -> . ID EQUAL FGETS LPAREN STDIN RPAREN SEMICOLON
    (48) stackDeclaration -> . ID EQUAL NEW STACK SEMICOLON
    (49) stackPush -> . ID OBJOP PUSH LPAREN value RPAREN SEMICOLON
    (50) stackPop -> . ID OBJOP POP SEMICOLON
    (84) line -> . variableAsignation SEMICOLON
    (64) print -> . PRINT LPAREN values RPAREN SEMICOLON
    (65) print -> . PRINT value SEMICOLON
    (95) logicalCondition -> . comparingValue
    (96) logicalCondition -> . comparingValue conditionOperator comparingValue
    (97) logicalCondition -> . LPAREN logicalCondition RPAREN
    (72) value -> . ID
    (73) value -> . INTEGER
    (74) value -> . FLOAT
    (75) value -> . STRING
    (76) value -> . BOOL
    (77) value -> . NULL
    (85) variableAsignation -> . ID EQUAL value
    (86) variableAsignation -> . ID EQUAL arithmeticExpression
    (94) comparingValue -> . value comparingSign value

    OPEN_TAG        shift and go to state 22
    CLOSE_TAG       shift and go to state 23
    LPAREN          shift and go to state 25
    IF              shift and go to state 26
    FOR             shift and go to state 27
    SWITCH          shift and go to state 28
    ID              shift and go to state 29
    FUNCTION        shift and go to state 30
    FN              shift and go to state 31
    ECHO            shift and go to state 32
    PRINT           shift and go to state 34
    INTEGER         shift and go to state 36
    FLOAT           shift and go to state 37
    STRING          shift and go to state 38
    BOOL            shift and go to state 39
    NULL            shift and go to state 40

    programa                       shift and go to state 1
    cuerpo                         shift and go to state 2
    arithmeticExpression           shift and go to state 3
    if_elseStatement               shift and go to state 4
    forStatement                   shift and go to state 5
    switchStatement                shift and go to state 6
    arrayAsignation                shift and go to state 7
    queueDeclaration               shift and go to state 8
    queueEnqueue                   shift and go to state 9
    queueDequeue                   shift and go to state 10
    defineFunction                 shift and go to state 11
    anonymousFunction              shift and go to state 12
    arrowFunction                  shift and go to state 13
    echo                           shift and go to state 14
    fgets                          shift and go to state 15
    stackDeclaration               shift and go to state 16
    stackPush                      shift and go to state 17
    stackPop                       shift and go to state 18
    line                           shift and go to state 19
    print                          shift and go to state 20
    logicalCondition               shift and go to state 21
    value                          shift and go to state 24
    variableAsignation             shift and go to state 33
    comparingValue                 shift and go to state 35

state 1

    (0) S' -> programa .
    (2) programa -> programa . cuerpo
    (3) cuerpo -> . arithmeticExpression
    (4) cuerpo -> . if_elseStatement
    (5) cuerpo -> . forStatement
    (6) cuerpo -> . switchStatement
    (7) cuerpo -> . arrayAsignation
    (8) cuerpo -> . queueDeclaration
    (9) cuerpo -> . queueEnqueue
    (10) cuerpo -> . queueDequeue
    (11) cuerpo -> . defineFunction
    (12) cuerpo -> . anonymousFunction
    (13) cuerpo -> . arrowFunction
    (14) cuerpo -> . echo
    (15) cuerpo -> . fgets
    (16) cuerpo -> . stackDeclaration
    (17) cuerpo -> . stackPush
    (18) cuerpo -> . stackPop
    (19) cuerpo -> . line
    (20) cuerpo -> . print
    (21) cuerpo -> . logicalCondition
    (22) cuerpo -> . OPEN_TAG
    (23) cuerpo -> . CLOSE_TAG
    (69) arithmeticExpression -> . value
    (70) arithmeticExpression -> . arithmeticExpression arithmeticOperator arithmeticExpression
    (71) arithmeticExpression -> . LPAREN arithmeticExpression RPAREN
    (29) if_elseStatement -> . IF LPAREN logicalCondition RPAREN LCURLY ifStatementBody RCURLY ELSE ifStatementBody
    (30) if_elseStatement -> . IF LPAREN logicalCondition RPAREN LCURLY ifStatementBody
    (34) forStatement -> . FOR LPAREN forStatementCondition RPAREN LCURLY forStatementBody RCURLY
    (24) switchStatement -> . SWITCH LPAREN value RPAREN LCURLY switchCases switchDefault RCURLY
    (40) arrayAsignation -> . ID EQUAL arrayDeclaration SEMICOLON
    (51) queueDeclaration -> . ID EQUAL NEW QUEUE SEMICOLON
    (52) queueEnqueue -> . ID OBJOP PUSH LPAREN value RPAREN SEMICOLON
    (53) queueDequeue -> . ID OBJOP POP SEMICOLON
    (54) defineFunction -> . FUNCTION ID LPAREN arguments RPAREN LCURLY cuerpo RCURLY
    (55) defineFunction -> . FUNCTION ID LPAREN RPAREN LCURLY cuerpo RCURLY
    (58) anonymousFunction -> . FUNCTION LPAREN RPAREN LCURLY cuerpo RCURLY
    (59) anonymousFunction -> . FUNCTION LPAREN arguments RPAREN LCURLY cuerpo RCURLY
    (60) arrowFunction -> . FN LPAREN ID RPAREN FNARROW arrowBody SEMICOLON
    (63) echo -> . ECHO values SEMICOLON
    (68) fgets -> . ID EQUAL FGETS LPAREN STDIN RPAREN SEMICOLON
    (48) stackDeclaration -> . ID EQUAL NEW STACK SEMICOLON
    (49) stackPush -> . ID OBJOP PUSH LPAREN value RPAREN SEMICOLON
    (50) stackPop -> . ID OBJOP POP SEMICOLON
    (84) line -> . variableAsignation SEMICOLON
    (64) print -> . PRINT LPAREN values RPAREN SEMICOLON
    (65) print -> . PRINT value SEMICOLON
    (95) logicalCondition -> . comparingValue
    (96) logicalCondition -> . comparingValue conditionOperator comparingValue
    (97) logicalCondition -> . LPAREN logicalCondition RPAREN
    (72) value -> . ID
    (73) value -> . INTEGER
    (74) value -> . FLOAT
    (75) value -> . STRING
    (76) value -> . BOOL
    (77) value -> . NULL
    (85) variableAsignation -> . ID EQUAL value
    (86) variableAsignation -> . ID EQUAL arithmeticExpression
    (94) comparingValue -> . value comparingSign value

    OPEN_TAG        shift and go to state 22
    CLOSE_TAG       shift and go to state 23
    LPAREN          shift and go to state 25
    IF              shift and go to state 26
    FOR             shift and go to state 27
    SWITCH          shift and go to state 28
    ID              shift and go to state 29
    FUNCTION        shift and go to state 30
    FN              shift and go to state 31
    ECHO            shift and go to state 32
    PRINT           shift and go to state 34
    INTEGER         shift and go to state 36
    FLOAT           shift and go to state 37
    STRING          shift and go to state 38
    BOOL            shift and go to state 39
    NULL            shift and go to state 40

    cuerpo                         shift and go to state 41
    arithmeticExpression           shift and go to state 3
    if_elseStatement               shift and go to state 4
    forStatement                   shift and go to state 5
    switchStatement                shift and go to state 6
    arrayAsignation                shift and go to state 7
    queueDeclaration               shift and go to state 8
    queueEnqueue                   shift and go to state 9
    queueDequeue                   shift and go to state 10
    defineFunction                 shift and go to state 11
    anonymousFunction              shift and go to state 12
    arrowFunction                  shift and go to state 13
    echo                           shift and go to state 14
    fgets                          shift and go to state 15
    stackDeclaration               shift and go to state 16
    stackPush                      shift and go to state 17
    stackPop                       shift and go to state 18
    line                           shift and go to state 19
    print                          shift and go to state 20
    logicalCondition               shift and go to state 21
    value                          shift and go to state 24
    variableAsignation             shift and go to state 33
    comparingValue                 shift and go to state 35

state 2

    (1) programa -> cuerpo .

    OPEN_TAG        reduce using rule 1 (programa -> cuerpo .)
    CLOSE_TAG       reduce using rule 1 (programa -> cuerpo .)
    LPAREN          reduce using rule 1 (programa -> cuerpo .)
    IF              reduce using rule 1 (programa -> cuerpo .)
    FOR             reduce using rule 1 (programa -> cuerpo .)
    SWITCH          reduce using rule 1 (programa -> cuerpo .)
    ID              reduce using rule 1 (programa -> cuerpo .)
    FUNCTION        reduce using rule 1 (programa -> cuerpo .)
    FN              reduce using rule 1 (programa -> cuerpo .)
    ECHO            reduce using rule 1 (programa -> cuerpo .)
    PRINT           reduce using rule 1 (programa -> cuerpo .)
    INTEGER         reduce using rule 1 (programa -> cuerpo .)
    FLOAT           reduce using rule 1 (programa -> cuerpo .)
    STRING          reduce using rule 1 (programa -> cuerpo .)
    BOOL            reduce using rule 1 (programa -> cuerpo .)
    NULL            reduce using rule 1 (programa -> cuerpo .)
    $end            reduce using rule 1 (programa -> cuerpo .)
    RCURLY          reduce using rule 1 (programa -> cuerpo .)
    BREAK           reduce using rule 1 (programa -> cuerpo .)


state 3

    (3) cuerpo -> arithmeticExpression .
    (70) arithmeticExpression -> arithmeticExpression . arithmeticOperator arithmeticExpression
    (78) arithmeticOperator -> . PLUS
    (79) arithmeticOperator -> . MINUS
    (80) arithmeticOperator -> . TIMES
    (81) arithmeticOperator -> . DIVIDE
    (82) arithmeticOperator -> . MOD
    (83) arithmeticOperator -> . EXP

    OPEN_TAG        reduce using rule 3 (cuerpo -> arithmeticExpression .)
    CLOSE_TAG       reduce using rule 3 (cuerpo -> arithmeticExpression .)
    LPAREN          reduce using rule 3 (cuerpo -> arithmeticExpression .)
    IF              reduce using rule 3 (cuerpo -> arithmeticExpression .)
    FOR             reduce using rule 3 (cuerpo -> arithmeticExpression .)
    SWITCH          reduce using rule 3 (cuerpo -> arithmeticExpression .)
    ID              reduce using rule 3 (cuerpo -> arithmeticExpression .)
    FUNCTION        reduce using rule 3 (cuerpo -> arithmeticExpression .)
    FN              reduce using rule 3 (cuerpo -> arithmeticExpression .)
    ECHO            reduce using rule 3 (cuerpo -> arithmeticExpression .)
    PRINT           reduce using rule 3 (cuerpo -> arithmeticExpression .)
    INTEGER         reduce using rule 3 (cuerpo -> arithmeticExpression .)
    FLOAT           reduce using rule 3 (cuerpo -> arithmeticExpression .)
    STRING          reduce using rule 3 (cuerpo -> arithmeticExpression .)
    BOOL            reduce using rule 3 (cuerpo -> arithmeticExpression .)
    NULL            reduce using rule 3 (cuerpo -> arithmeticExpression .)
    $end            reduce using rule 3 (cuerpo -> arithmeticExpression .)
    RCURLY          reduce using rule 3 (cuerpo -> arithmeticExpression .)
    CONTINUE        reduce using rule 3 (cuerpo -> arithmeticExpression .)
    SEMICOLON       reduce using rule 3 (cuerpo -> arithmeticExpression .)
    BREAK           reduce using rule 3 (cuerpo -> arithmeticExpression .)
    PLUS            shift and go to state 43
    MINUS           shift and go to state 44
    TIMES           shift and go to state 45
    DIVIDE          shift and go to state 46
    MOD             shift and go to state 47
    EXP             shift and go to state 48

    arithmeticOperator             shift and go to state 42

state 4

    (4) cuerpo -> if_elseStatement .

    OPEN_TAG        reduce using rule 4 (cuerpo -> if_elseStatement .)
    CLOSE_TAG       reduce using rule 4 (cuerpo -> if_elseStatement .)
    LPAREN          reduce using rule 4 (cuerpo -> if_elseStatement .)
    IF              reduce using rule 4 (cuerpo -> if_elseStatement .)
    FOR             reduce using rule 4 (cuerpo -> if_elseStatement .)
    SWITCH          reduce using rule 4 (cuerpo -> if_elseStatement .)
    ID              reduce using rule 4 (cuerpo -> if_elseStatement .)
    FUNCTION        reduce using rule 4 (cuerpo -> if_elseStatement .)
    FN              reduce using rule 4 (cuerpo -> if_elseStatement .)
    ECHO            reduce using rule 4 (cuerpo -> if_elseStatement .)
    PRINT           reduce using rule 4 (cuerpo -> if_elseStatement .)
    INTEGER         reduce using rule 4 (cuerpo -> if_elseStatement .)
    FLOAT           reduce using rule 4 (cuerpo -> if_elseStatement .)
    STRING          reduce using rule 4 (cuerpo -> if_elseStatement .)
    BOOL            reduce using rule 4 (cuerpo -> if_elseStatement .)
    NULL            reduce using rule 4 (cuerpo -> if_elseStatement .)
    $end            reduce using rule 4 (cuerpo -> if_elseStatement .)
    RCURLY          reduce using rule 4 (cuerpo -> if_elseStatement .)
    CONTINUE        reduce using rule 4 (cuerpo -> if_elseStatement .)
    SEMICOLON       reduce using rule 4 (cuerpo -> if_elseStatement .)
    BREAK           reduce using rule 4 (cuerpo -> if_elseStatement .)


state 5

    (5) cuerpo -> forStatement .

    OPEN_TAG        reduce using rule 5 (cuerpo -> forStatement .)
    CLOSE_TAG       reduce using rule 5 (cuerpo -> forStatement .)
    LPAREN          reduce using rule 5 (cuerpo -> forStatement .)
    IF              reduce using rule 5 (cuerpo -> forStatement .)
    FOR             reduce using rule 5 (cuerpo -> forStatement .)
    SWITCH          reduce using rule 5 (cuerpo -> forStatement .)
    ID              reduce using rule 5 (cuerpo -> forStatement .)
    FUNCTION        reduce using rule 5 (cuerpo -> forStatement .)
    FN              reduce using rule 5 (cuerpo -> forStatement .)
    ECHO            reduce using rule 5 (cuerpo -> forStatement .)
    PRINT           reduce using rule 5 (cuerpo -> forStatement .)
    INTEGER         reduce using rule 5 (cuerpo -> forStatement .)
    FLOAT           reduce using rule 5 (cuerpo -> forStatement .)
    STRING          reduce using rule 5 (cuerpo -> forStatement .)
    BOOL            reduce using rule 5 (cuerpo -> forStatement .)
    NULL            reduce using rule 5 (cuerpo -> forStatement .)
    $end            reduce using rule 5 (cuerpo -> forStatement .)
    RCURLY          reduce using rule 5 (cuerpo -> forStatement .)
    CONTINUE        reduce using rule 5 (cuerpo -> forStatement .)
    SEMICOLON       reduce using rule 5 (cuerpo -> forStatement .)
    BREAK           reduce using rule 5 (cuerpo -> forStatement .)


state 6

    (6) cuerpo -> switchStatement .

    OPEN_TAG        reduce using rule 6 (cuerpo -> switchStatement .)
    CLOSE_TAG       reduce using rule 6 (cuerpo -> switchStatement .)
    LPAREN          reduce using rule 6 (cuerpo -> switchStatement .)
    IF              reduce using rule 6 (cuerpo -> switchStatement .)
    FOR             reduce using rule 6 (cuerpo -> switchStatement .)
    SWITCH          reduce using rule 6 (cuerpo -> switchStatement .)
    ID              reduce using rule 6 (cuerpo -> switchStatement .)
    FUNCTION        reduce using rule 6 (cuerpo -> switchStatement .)
    FN              reduce using rule 6 (cuerpo -> switchStatement .)
    ECHO            reduce using rule 6 (cuerpo -> switchStatement .)
    PRINT           reduce using rule 6 (cuerpo -> switchStatement .)
    INTEGER         reduce using rule 6 (cuerpo -> switchStatement .)
    FLOAT           reduce using rule 6 (cuerpo -> switchStatement .)
    STRING          reduce using rule 6 (cuerpo -> switchStatement .)
    BOOL            reduce using rule 6 (cuerpo -> switchStatement .)
    NULL            reduce using rule 6 (cuerpo -> switchStatement .)
    $end            reduce using rule 6 (cuerpo -> switchStatement .)
    RCURLY          reduce using rule 6 (cuerpo -> switchStatement .)
    CONTINUE        reduce using rule 6 (cuerpo -> switchStatement .)
    SEMICOLON       reduce using rule 6 (cuerpo -> switchStatement .)
    BREAK           reduce using rule 6 (cuerpo -> switchStatement .)


state 7

    (7) cuerpo -> arrayAsignation .

    OPEN_TAG        reduce using rule 7 (cuerpo -> arrayAsignation .)
    CLOSE_TAG       reduce using rule 7 (cuerpo -> arrayAsignation .)
    LPAREN          reduce using rule 7 (cuerpo -> arrayAsignation .)
    IF              reduce using rule 7 (cuerpo -> arrayAsignation .)
    FOR             reduce using rule 7 (cuerpo -> arrayAsignation .)
    SWITCH          reduce using rule 7 (cuerpo -> arrayAsignation .)
    ID              reduce using rule 7 (cuerpo -> arrayAsignation .)
    FUNCTION        reduce using rule 7 (cuerpo -> arrayAsignation .)
    FN              reduce using rule 7 (cuerpo -> arrayAsignation .)
    ECHO            reduce using rule 7 (cuerpo -> arrayAsignation .)
    PRINT           reduce using rule 7 (cuerpo -> arrayAsignation .)
    INTEGER         reduce using rule 7 (cuerpo -> arrayAsignation .)
    FLOAT           reduce using rule 7 (cuerpo -> arrayAsignation .)
    STRING          reduce using rule 7 (cuerpo -> arrayAsignation .)
    BOOL            reduce using rule 7 (cuerpo -> arrayAsignation .)
    NULL            reduce using rule 7 (cuerpo -> arrayAsignation .)
    $end            reduce using rule 7 (cuerpo -> arrayAsignation .)
    RCURLY          reduce using rule 7 (cuerpo -> arrayAsignation .)
    CONTINUE        reduce using rule 7 (cuerpo -> arrayAsignation .)
    SEMICOLON       reduce using rule 7 (cuerpo -> arrayAsignation .)
    BREAK           reduce using rule 7 (cuerpo -> arrayAsignation .)


state 8

    (8) cuerpo -> queueDeclaration .

    OPEN_TAG        reduce using rule 8 (cuerpo -> queueDeclaration .)
    CLOSE_TAG       reduce using rule 8 (cuerpo -> queueDeclaration .)
    LPAREN          reduce using rule 8 (cuerpo -> queueDeclaration .)
    IF              reduce using rule 8 (cuerpo -> queueDeclaration .)
    FOR             reduce using rule 8 (cuerpo -> queueDeclaration .)
    SWITCH          reduce using rule 8 (cuerpo -> queueDeclaration .)
    ID              reduce using rule 8 (cuerpo -> queueDeclaration .)
    FUNCTION        reduce using rule 8 (cuerpo -> queueDeclaration .)
    FN              reduce using rule 8 (cuerpo -> queueDeclaration .)
    ECHO            reduce using rule 8 (cuerpo -> queueDeclaration .)
    PRINT           reduce using rule 8 (cuerpo -> queueDeclaration .)
    INTEGER         reduce using rule 8 (cuerpo -> queueDeclaration .)
    FLOAT           reduce using rule 8 (cuerpo -> queueDeclaration .)
    STRING          reduce using rule 8 (cuerpo -> queueDeclaration .)
    BOOL            reduce using rule 8 (cuerpo -> queueDeclaration .)
    NULL            reduce using rule 8 (cuerpo -> queueDeclaration .)
    $end            reduce using rule 8 (cuerpo -> queueDeclaration .)
    RCURLY          reduce using rule 8 (cuerpo -> queueDeclaration .)
    CONTINUE        reduce using rule 8 (cuerpo -> queueDeclaration .)
    SEMICOLON       reduce using rule 8 (cuerpo -> queueDeclaration .)
    BREAK           reduce using rule 8 (cuerpo -> queueDeclaration .)


state 9

    (9) cuerpo -> queueEnqueue .

    OPEN_TAG        reduce using rule 9 (cuerpo -> queueEnqueue .)
    CLOSE_TAG       reduce using rule 9 (cuerpo -> queueEnqueue .)
    LPAREN          reduce using rule 9 (cuerpo -> queueEnqueue .)
    IF              reduce using rule 9 (cuerpo -> queueEnqueue .)
    FOR             reduce using rule 9 (cuerpo -> queueEnqueue .)
    SWITCH          reduce using rule 9 (cuerpo -> queueEnqueue .)
    ID              reduce using rule 9 (cuerpo -> queueEnqueue .)
    FUNCTION        reduce using rule 9 (cuerpo -> queueEnqueue .)
    FN              reduce using rule 9 (cuerpo -> queueEnqueue .)
    ECHO            reduce using rule 9 (cuerpo -> queueEnqueue .)
    PRINT           reduce using rule 9 (cuerpo -> queueEnqueue .)
    INTEGER         reduce using rule 9 (cuerpo -> queueEnqueue .)
    FLOAT           reduce using rule 9 (cuerpo -> queueEnqueue .)
    STRING          reduce using rule 9 (cuerpo -> queueEnqueue .)
    BOOL            reduce using rule 9 (cuerpo -> queueEnqueue .)
    NULL            reduce using rule 9 (cuerpo -> queueEnqueue .)
    $end            reduce using rule 9 (cuerpo -> queueEnqueue .)
    RCURLY          reduce using rule 9 (cuerpo -> queueEnqueue .)
    CONTINUE        reduce using rule 9 (cuerpo -> queueEnqueue .)
    SEMICOLON       reduce using rule 9 (cuerpo -> queueEnqueue .)
    BREAK           reduce using rule 9 (cuerpo -> queueEnqueue .)


state 10

    (10) cuerpo -> queueDequeue .

    OPEN_TAG        reduce using rule 10 (cuerpo -> queueDequeue .)
    CLOSE_TAG       reduce using rule 10 (cuerpo -> queueDequeue .)
    LPAREN          reduce using rule 10 (cuerpo -> queueDequeue .)
    IF              reduce using rule 10 (cuerpo -> queueDequeue .)
    FOR             reduce using rule 10 (cuerpo -> queueDequeue .)
    SWITCH          reduce using rule 10 (cuerpo -> queueDequeue .)
    ID              reduce using rule 10 (cuerpo -> queueDequeue .)
    FUNCTION        reduce using rule 10 (cuerpo -> queueDequeue .)
    FN              reduce using rule 10 (cuerpo -> queueDequeue .)
    ECHO            reduce using rule 10 (cuerpo -> queueDequeue .)
    PRINT           reduce using rule 10 (cuerpo -> queueDequeue .)
    INTEGER         reduce using rule 10 (cuerpo -> queueDequeue .)
    FLOAT           reduce using rule 10 (cuerpo -> queueDequeue .)
    STRING          reduce using rule 10 (cuerpo -> queueDequeue .)
    BOOL            reduce using rule 10 (cuerpo -> queueDequeue .)
    NULL            reduce using rule 10 (cuerpo -> queueDequeue .)
    $end            reduce using rule 10 (cuerpo -> queueDequeue .)
    RCURLY          reduce using rule 10 (cuerpo -> queueDequeue .)
    CONTINUE        reduce using rule 10 (cuerpo -> queueDequeue .)
    SEMICOLON       reduce using rule 10 (cuerpo -> queueDequeue .)
    BREAK           reduce using rule 10 (cuerpo -> queueDequeue .)


state 11

    (11) cuerpo -> defineFunction .

    OPEN_TAG        reduce using rule 11 (cuerpo -> defineFunction .)
    CLOSE_TAG       reduce using rule 11 (cuerpo -> defineFunction .)
    LPAREN          reduce using rule 11 (cuerpo -> defineFunction .)
    IF              reduce using rule 11 (cuerpo -> defineFunction .)
    FOR             reduce using rule 11 (cuerpo -> defineFunction .)
    SWITCH          reduce using rule 11 (cuerpo -> defineFunction .)
    ID              reduce using rule 11 (cuerpo -> defineFunction .)
    FUNCTION        reduce using rule 11 (cuerpo -> defineFunction .)
    FN              reduce using rule 11 (cuerpo -> defineFunction .)
    ECHO            reduce using rule 11 (cuerpo -> defineFunction .)
    PRINT           reduce using rule 11 (cuerpo -> defineFunction .)
    INTEGER         reduce using rule 11 (cuerpo -> defineFunction .)
    FLOAT           reduce using rule 11 (cuerpo -> defineFunction .)
    STRING          reduce using rule 11 (cuerpo -> defineFunction .)
    BOOL            reduce using rule 11 (cuerpo -> defineFunction .)
    NULL            reduce using rule 11 (cuerpo -> defineFunction .)
    $end            reduce using rule 11 (cuerpo -> defineFunction .)
    RCURLY          reduce using rule 11 (cuerpo -> defineFunction .)
    CONTINUE        reduce using rule 11 (cuerpo -> defineFunction .)
    SEMICOLON       reduce using rule 11 (cuerpo -> defineFunction .)
    BREAK           reduce using rule 11 (cuerpo -> defineFunction .)


state 12

    (12) cuerpo -> anonymousFunction .

    OPEN_TAG        reduce using rule 12 (cuerpo -> anonymousFunction .)
    CLOSE_TAG       reduce using rule 12 (cuerpo -> anonymousFunction .)
    LPAREN          reduce using rule 12 (cuerpo -> anonymousFunction .)
    IF              reduce using rule 12 (cuerpo -> anonymousFunction .)
    FOR             reduce using rule 12 (cuerpo -> anonymousFunction .)
    SWITCH          reduce using rule 12 (cuerpo -> anonymousFunction .)
    ID              reduce using rule 12 (cuerpo -> anonymousFunction .)
    FUNCTION        reduce using rule 12 (cuerpo -> anonymousFunction .)
    FN              reduce using rule 12 (cuerpo -> anonymousFunction .)
    ECHO            reduce using rule 12 (cuerpo -> anonymousFunction .)
    PRINT           reduce using rule 12 (cuerpo -> anonymousFunction .)
    INTEGER         reduce using rule 12 (cuerpo -> anonymousFunction .)
    FLOAT           reduce using rule 12 (cuerpo -> anonymousFunction .)
    STRING          reduce using rule 12 (cuerpo -> anonymousFunction .)
    BOOL            reduce using rule 12 (cuerpo -> anonymousFunction .)
    NULL            reduce using rule 12 (cuerpo -> anonymousFunction .)
    $end            reduce using rule 12 (cuerpo -> anonymousFunction .)
    RCURLY          reduce using rule 12 (cuerpo -> anonymousFunction .)
    CONTINUE        reduce using rule 12 (cuerpo -> anonymousFunction .)
    SEMICOLON       reduce using rule 12 (cuerpo -> anonymousFunction .)
    BREAK           reduce using rule 12 (cuerpo -> anonymousFunction .)


state 13

    (13) cuerpo -> arrowFunction .

    OPEN_TAG        reduce using rule 13 (cuerpo -> arrowFunction .)
    CLOSE_TAG       reduce using rule 13 (cuerpo -> arrowFunction .)
    LPAREN          reduce using rule 13 (cuerpo -> arrowFunction .)
    IF              reduce using rule 13 (cuerpo -> arrowFunction .)
    FOR             reduce using rule 13 (cuerpo -> arrowFunction .)
    SWITCH          reduce using rule 13 (cuerpo -> arrowFunction .)
    ID              reduce using rule 13 (cuerpo -> arrowFunction .)
    FUNCTION        reduce using rule 13 (cuerpo -> arrowFunction .)
    FN              reduce using rule 13 (cuerpo -> arrowFunction .)
    ECHO            reduce using rule 13 (cuerpo -> arrowFunction .)
    PRINT           reduce using rule 13 (cuerpo -> arrowFunction .)
    INTEGER         reduce using rule 13 (cuerpo -> arrowFunction .)
    FLOAT           reduce using rule 13 (cuerpo -> arrowFunction .)
    STRING          reduce using rule 13 (cuerpo -> arrowFunction .)
    BOOL            reduce using rule 13 (cuerpo -> arrowFunction .)
    NULL            reduce using rule 13 (cuerpo -> arrowFunction .)
    $end            reduce using rule 13 (cuerpo -> arrowFunction .)
    RCURLY          reduce using rule 13 (cuerpo -> arrowFunction .)
    CONTINUE        reduce using rule 13 (cuerpo -> arrowFunction .)
    SEMICOLON       reduce using rule 13 (cuerpo -> arrowFunction .)
    BREAK           reduce using rule 13 (cuerpo -> arrowFunction .)


state 14

    (14) cuerpo -> echo .

    OPEN_TAG        reduce using rule 14 (cuerpo -> echo .)
    CLOSE_TAG       reduce using rule 14 (cuerpo -> echo .)
    LPAREN          reduce using rule 14 (cuerpo -> echo .)
    IF              reduce using rule 14 (cuerpo -> echo .)
    FOR             reduce using rule 14 (cuerpo -> echo .)
    SWITCH          reduce using rule 14 (cuerpo -> echo .)
    ID              reduce using rule 14 (cuerpo -> echo .)
    FUNCTION        reduce using rule 14 (cuerpo -> echo .)
    FN              reduce using rule 14 (cuerpo -> echo .)
    ECHO            reduce using rule 14 (cuerpo -> echo .)
    PRINT           reduce using rule 14 (cuerpo -> echo .)
    INTEGER         reduce using rule 14 (cuerpo -> echo .)
    FLOAT           reduce using rule 14 (cuerpo -> echo .)
    STRING          reduce using rule 14 (cuerpo -> echo .)
    BOOL            reduce using rule 14 (cuerpo -> echo .)
    NULL            reduce using rule 14 (cuerpo -> echo .)
    $end            reduce using rule 14 (cuerpo -> echo .)
    RCURLY          reduce using rule 14 (cuerpo -> echo .)
    CONTINUE        reduce using rule 14 (cuerpo -> echo .)
    SEMICOLON       reduce using rule 14 (cuerpo -> echo .)
    BREAK           reduce using rule 14 (cuerpo -> echo .)


state 15

    (15) cuerpo -> fgets .

    OPEN_TAG        reduce using rule 15 (cuerpo -> fgets .)
    CLOSE_TAG       reduce using rule 15 (cuerpo -> fgets .)
    LPAREN          reduce using rule 15 (cuerpo -> fgets .)
    IF              reduce using rule 15 (cuerpo -> fgets .)
    FOR             reduce using rule 15 (cuerpo -> fgets .)
    SWITCH          reduce using rule 15 (cuerpo -> fgets .)
    ID              reduce using rule 15 (cuerpo -> fgets .)
    FUNCTION        reduce using rule 15 (cuerpo -> fgets .)
    FN              reduce using rule 15 (cuerpo -> fgets .)
    ECHO            reduce using rule 15 (cuerpo -> fgets .)
    PRINT           reduce using rule 15 (cuerpo -> fgets .)
    INTEGER         reduce using rule 15 (cuerpo -> fgets .)
    FLOAT           reduce using rule 15 (cuerpo -> fgets .)
    STRING          reduce using rule 15 (cuerpo -> fgets .)
    BOOL            reduce using rule 15 (cuerpo -> fgets .)
    NULL            reduce using rule 15 (cuerpo -> fgets .)
    $end            reduce using rule 15 (cuerpo -> fgets .)
    RCURLY          reduce using rule 15 (cuerpo -> fgets .)
    CONTINUE        reduce using rule 15 (cuerpo -> fgets .)
    SEMICOLON       reduce using rule 15 (cuerpo -> fgets .)
    BREAK           reduce using rule 15 (cuerpo -> fgets .)


state 16

    (16) cuerpo -> stackDeclaration .

    OPEN_TAG        reduce using rule 16 (cuerpo -> stackDeclaration .)
    CLOSE_TAG       reduce using rule 16 (cuerpo -> stackDeclaration .)
    LPAREN          reduce using rule 16 (cuerpo -> stackDeclaration .)
    IF              reduce using rule 16 (cuerpo -> stackDeclaration .)
    FOR             reduce using rule 16 (cuerpo -> stackDeclaration .)
    SWITCH          reduce using rule 16 (cuerpo -> stackDeclaration .)
    ID              reduce using rule 16 (cuerpo -> stackDeclaration .)
    FUNCTION        reduce using rule 16 (cuerpo -> stackDeclaration .)
    FN              reduce using rule 16 (cuerpo -> stackDeclaration .)
    ECHO            reduce using rule 16 (cuerpo -> stackDeclaration .)
    PRINT           reduce using rule 16 (cuerpo -> stackDeclaration .)
    INTEGER         reduce using rule 16 (cuerpo -> stackDeclaration .)
    FLOAT           reduce using rule 16 (cuerpo -> stackDeclaration .)
    STRING          reduce using rule 16 (cuerpo -> stackDeclaration .)
    BOOL            reduce using rule 16 (cuerpo -> stackDeclaration .)
    NULL            reduce using rule 16 (cuerpo -> stackDeclaration .)
    $end            reduce using rule 16 (cuerpo -> stackDeclaration .)
    RCURLY          reduce using rule 16 (cuerpo -> stackDeclaration .)
    CONTINUE        reduce using rule 16 (cuerpo -> stackDeclaration .)
    SEMICOLON       reduce using rule 16 (cuerpo -> stackDeclaration .)
    BREAK           reduce using rule 16 (cuerpo -> stackDeclaration .)


state 17

    (17) cuerpo -> stackPush .

    OPEN_TAG        reduce using rule 17 (cuerpo -> stackPush .)
    CLOSE_TAG       reduce using rule 17 (cuerpo -> stackPush .)
    LPAREN          reduce using rule 17 (cuerpo -> stackPush .)
    IF              reduce using rule 17 (cuerpo -> stackPush .)
    FOR             reduce using rule 17 (cuerpo -> stackPush .)
    SWITCH          reduce using rule 17 (cuerpo -> stackPush .)
    ID              reduce using rule 17 (cuerpo -> stackPush .)
    FUNCTION        reduce using rule 17 (cuerpo -> stackPush .)
    FN              reduce using rule 17 (cuerpo -> stackPush .)
    ECHO            reduce using rule 17 (cuerpo -> stackPush .)
    PRINT           reduce using rule 17 (cuerpo -> stackPush .)
    INTEGER         reduce using rule 17 (cuerpo -> stackPush .)
    FLOAT           reduce using rule 17 (cuerpo -> stackPush .)
    STRING          reduce using rule 17 (cuerpo -> stackPush .)
    BOOL            reduce using rule 17 (cuerpo -> stackPush .)
    NULL            reduce using rule 17 (cuerpo -> stackPush .)
    $end            reduce using rule 17 (cuerpo -> stackPush .)
    RCURLY          reduce using rule 17 (cuerpo -> stackPush .)
    CONTINUE        reduce using rule 17 (cuerpo -> stackPush .)
    SEMICOLON       reduce using rule 17 (cuerpo -> stackPush .)
    BREAK           reduce using rule 17 (cuerpo -> stackPush .)


state 18

    (18) cuerpo -> stackPop .

    OPEN_TAG        reduce using rule 18 (cuerpo -> stackPop .)
    CLOSE_TAG       reduce using rule 18 (cuerpo -> stackPop .)
    LPAREN          reduce using rule 18 (cuerpo -> stackPop .)
    IF              reduce using rule 18 (cuerpo -> stackPop .)
    FOR             reduce using rule 18 (cuerpo -> stackPop .)
    SWITCH          reduce using rule 18 (cuerpo -> stackPop .)
    ID              reduce using rule 18 (cuerpo -> stackPop .)
    FUNCTION        reduce using rule 18 (cuerpo -> stackPop .)
    FN              reduce using rule 18 (cuerpo -> stackPop .)
    ECHO            reduce using rule 18 (cuerpo -> stackPop .)
    PRINT           reduce using rule 18 (cuerpo -> stackPop .)
    INTEGER         reduce using rule 18 (cuerpo -> stackPop .)
    FLOAT           reduce using rule 18 (cuerpo -> stackPop .)
    STRING          reduce using rule 18 (cuerpo -> stackPop .)
    BOOL            reduce using rule 18 (cuerpo -> stackPop .)
    NULL            reduce using rule 18 (cuerpo -> stackPop .)
    $end            reduce using rule 18 (cuerpo -> stackPop .)
    RCURLY          reduce using rule 18 (cuerpo -> stackPop .)
    CONTINUE        reduce using rule 18 (cuerpo -> stackPop .)
    SEMICOLON       reduce using rule 18 (cuerpo -> stackPop .)
    BREAK           reduce using rule 18 (cuerpo -> stackPop .)


state 19

    (19) cuerpo -> line .

    OPEN_TAG        reduce using rule 19 (cuerpo -> line .)
    CLOSE_TAG       reduce using rule 19 (cuerpo -> line .)
    LPAREN          reduce using rule 19 (cuerpo -> line .)
    IF              reduce using rule 19 (cuerpo -> line .)
    FOR             reduce using rule 19 (cuerpo -> line .)
    SWITCH          reduce using rule 19 (cuerpo -> line .)
    ID              reduce using rule 19 (cuerpo -> line .)
    FUNCTION        reduce using rule 19 (cuerpo -> line .)
    FN              reduce using rule 19 (cuerpo -> line .)
    ECHO            reduce using rule 19 (cuerpo -> line .)
    PRINT           reduce using rule 19 (cuerpo -> line .)
    INTEGER         reduce using rule 19 (cuerpo -> line .)
    FLOAT           reduce using rule 19 (cuerpo -> line .)
    STRING          reduce using rule 19 (cuerpo -> line .)
    BOOL            reduce using rule 19 (cuerpo -> line .)
    NULL            reduce using rule 19 (cuerpo -> line .)
    $end            reduce using rule 19 (cuerpo -> line .)
    RCURLY          reduce using rule 19 (cuerpo -> line .)
    CONTINUE        reduce using rule 19 (cuerpo -> line .)
    SEMICOLON       reduce using rule 19 (cuerpo -> line .)
    BREAK           reduce using rule 19 (cuerpo -> line .)


state 20

    (20) cuerpo -> print .

    OPEN_TAG        reduce using rule 20 (cuerpo -> print .)
    CLOSE_TAG       reduce using rule 20 (cuerpo -> print .)
    LPAREN          reduce using rule 20 (cuerpo -> print .)
    IF              reduce using rule 20 (cuerpo -> print .)
    FOR             reduce using rule 20 (cuerpo -> print .)
    SWITCH          reduce using rule 20 (cuerpo -> print .)
    ID              reduce using rule 20 (cuerpo -> print .)
    FUNCTION        reduce using rule 20 (cuerpo -> print .)
    FN              reduce using rule 20 (cuerpo -> print .)
    ECHO            reduce using rule 20 (cuerpo -> print .)
    PRINT           reduce using rule 20 (cuerpo -> print .)
    INTEGER         reduce using rule 20 (cuerpo -> print .)
    FLOAT           reduce using rule 20 (cuerpo -> print .)
    STRING          reduce using rule 20 (cuerpo -> print .)
    BOOL            reduce using rule 20 (cuerpo -> print .)
    NULL            reduce using rule 20 (cuerpo -> print .)
    $end            reduce using rule 20 (cuerpo -> print .)
    RCURLY          reduce using rule 20 (cuerpo -> print .)
    CONTINUE        reduce using rule 20 (cuerpo -> print .)
    SEMICOLON       reduce using rule 20 (cuerpo -> print .)
    BREAK           reduce using rule 20 (cuerpo -> print .)


state 21

    (21) cuerpo -> logicalCondition .

    OPEN_TAG        reduce using rule 21 (cuerpo -> logicalCondition .)
    CLOSE_TAG       reduce using rule 21 (cuerpo -> logicalCondition .)
    LPAREN          reduce using rule 21 (cuerpo -> logicalCondition .)
    IF              reduce using rule 21 (cuerpo -> logicalCondition .)
    FOR             reduce using rule 21 (cuerpo -> logicalCondition .)
    SWITCH          reduce using rule 21 (cuerpo -> logicalCondition .)
    ID              reduce using rule 21 (cuerpo -> logicalCondition .)
    FUNCTION        reduce using rule 21 (cuerpo -> logicalCondition .)
    FN              reduce using rule 21 (cuerpo -> logicalCondition .)
    ECHO            reduce using rule 21 (cuerpo -> logicalCondition .)
    PRINT           reduce using rule 21 (cuerpo -> logicalCondition .)
    INTEGER         reduce using rule 21 (cuerpo -> logicalCondition .)
    FLOAT           reduce using rule 21 (cuerpo -> logicalCondition .)
    STRING          reduce using rule 21 (cuerpo -> logicalCondition .)
    BOOL            reduce using rule 21 (cuerpo -> logicalCondition .)
    NULL            reduce using rule 21 (cuerpo -> logicalCondition .)
    $end            reduce using rule 21 (cuerpo -> logicalCondition .)
    RCURLY          reduce using rule 21 (cuerpo -> logicalCondition .)
    CONTINUE        reduce using rule 21 (cuerpo -> logicalCondition .)
    SEMICOLON       reduce using rule 21 (cuerpo -> logicalCondition .)
    BREAK           reduce using rule 21 (cuerpo -> logicalCondition .)


state 22

    (22) cuerpo -> OPEN_TAG .

    OPEN_TAG        reduce using rule 22 (cuerpo -> OPEN_TAG .)
    CLOSE_TAG       reduce using rule 22 (cuerpo -> OPEN_TAG .)
    LPAREN          reduce using rule 22 (cuerpo -> OPEN_TAG .)
    IF              reduce using rule 22 (cuerpo -> OPEN_TAG .)
    FOR             reduce using rule 22 (cuerpo -> OPEN_TAG .)
    SWITCH          reduce using rule 22 (cuerpo -> OPEN_TAG .)
    ID              reduce using rule 22 (cuerpo -> OPEN_TAG .)
    FUNCTION        reduce using rule 22 (cuerpo -> OPEN_TAG .)
    FN              reduce using rule 22 (cuerpo -> OPEN_TAG .)
    ECHO            reduce using rule 22 (cuerpo -> OPEN_TAG .)
    PRINT           reduce using rule 22 (cuerpo -> OPEN_TAG .)
    INTEGER         reduce using rule 22 (cuerpo -> OPEN_TAG .)
    FLOAT           reduce using rule 22 (cuerpo -> OPEN_TAG .)
    STRING          reduce using rule 22 (cuerpo -> OPEN_TAG .)
    BOOL            reduce using rule 22 (cuerpo -> OPEN_TAG .)
    NULL            reduce using rule 22 (cuerpo -> OPEN_TAG .)
    $end            reduce using rule 22 (cuerpo -> OPEN_TAG .)
    RCURLY          reduce using rule 22 (cuerpo -> OPEN_TAG .)
    CONTINUE        reduce using rule 22 (cuerpo -> OPEN_TAG .)
    SEMICOLON       reduce using rule 22 (cuerpo -> OPEN_TAG .)
    BREAK           reduce using rule 22 (cuerpo -> OPEN_TAG .)


state 23

    (23) cuerpo -> CLOSE_TAG .

    OPEN_TAG        reduce using rule 23 (cuerpo -> CLOSE_TAG .)
    CLOSE_TAG       reduce using rule 23 (cuerpo -> CLOSE_TAG .)
    LPAREN          reduce using rule 23 (cuerpo -> CLOSE_TAG .)
    IF              reduce using rule 23 (cuerpo -> CLOSE_TAG .)
    FOR             reduce using rule 23 (cuerpo -> CLOSE_TAG .)
    SWITCH          reduce using rule 23 (cuerpo -> CLOSE_TAG .)
    ID              reduce using rule 23 (cuerpo -> CLOSE_TAG .)
    FUNCTION        reduce using rule 23 (cuerpo -> CLOSE_TAG .)
    FN              reduce using rule 23 (cuerpo -> CLOSE_TAG .)
    ECHO            reduce using rule 23 (cuerpo -> CLOSE_TAG .)
    PRINT           reduce using rule 23 (cuerpo -> CLOSE_TAG .)
    INTEGER         reduce using rule 23 (cuerpo -> CLOSE_TAG .)
    FLOAT           reduce using rule 23 (cuerpo -> CLOSE_TAG .)
    STRING          reduce using rule 23 (cuerpo -> CLOSE_TAG .)
    BOOL            reduce using rule 23 (cuerpo -> CLOSE_TAG .)
    NULL            reduce using rule 23 (cuerpo -> CLOSE_TAG .)
    $end            reduce using rule 23 (cuerpo -> CLOSE_TAG .)
    RCURLY          reduce using rule 23 (cuerpo -> CLOSE_TAG .)
    CONTINUE        reduce using rule 23 (cuerpo -> CLOSE_TAG .)
    SEMICOLON       reduce using rule 23 (cuerpo -> CLOSE_TAG .)
    BREAK           reduce using rule 23 (cuerpo -> CLOSE_TAG .)


state 24

    (69) arithmeticExpression -> value .
    (94) comparingValue -> value . comparingSign value
    (87) comparingSign -> . IS_EQUAL
    (88) comparingSign -> . IDENTICAL
    (89) comparingSign -> . NOTEQUAL
    (90) comparingSign -> . LESSTHAN
    (91) comparingSign -> . GREATERTHAN
    (92) comparingSign -> . LESSEQUALTHAN
    (93) comparingSign -> . GREATEREQUALTHAN

    PLUS            reduce using rule 69 (arithmeticExpression -> value .)
    MINUS           reduce using rule 69 (arithmeticExpression -> value .)
    TIMES           reduce using rule 69 (arithmeticExpression -> value .)
    DIVIDE          reduce using rule 69 (arithmeticExpression -> value .)
    MOD             reduce using rule 69 (arithmeticExpression -> value .)
    EXP             reduce using rule 69 (arithmeticExpression -> value .)
    OPEN_TAG        reduce using rule 69 (arithmeticExpression -> value .)
    CLOSE_TAG       reduce using rule 69 (arithmeticExpression -> value .)
    LPAREN          reduce using rule 69 (arithmeticExpression -> value .)
    IF              reduce using rule 69 (arithmeticExpression -> value .)
    FOR             reduce using rule 69 (arithmeticExpression -> value .)
    SWITCH          reduce using rule 69 (arithmeticExpression -> value .)
    ID              reduce using rule 69 (arithmeticExpression -> value .)
    FUNCTION        reduce using rule 69 (arithmeticExpression -> value .)
    FN              reduce using rule 69 (arithmeticExpression -> value .)
    ECHO            reduce using rule 69 (arithmeticExpression -> value .)
    PRINT           reduce using rule 69 (arithmeticExpression -> value .)
    INTEGER         reduce using rule 69 (arithmeticExpression -> value .)
    FLOAT           reduce using rule 69 (arithmeticExpression -> value .)
    STRING          reduce using rule 69 (arithmeticExpression -> value .)
    BOOL            reduce using rule 69 (arithmeticExpression -> value .)
    NULL            reduce using rule 69 (arithmeticExpression -> value .)
    $end            reduce using rule 69 (arithmeticExpression -> value .)
    RPAREN          reduce using rule 69 (arithmeticExpression -> value .)
    RCURLY          reduce using rule 69 (arithmeticExpression -> value .)
    CONTINUE        reduce using rule 69 (arithmeticExpression -> value .)
    SEMICOLON       reduce using rule 69 (arithmeticExpression -> value .)
    BREAK           reduce using rule 69 (arithmeticExpression -> value .)
    IS_EQUAL        shift and go to state 50
    IDENTICAL       shift and go to state 51
    NOTEQUAL        shift and go to state 52
    LESSTHAN        shift and go to state 53
    GREATERTHAN     shift and go to state 54
    LESSEQUALTHAN   shift and go to state 55
    GREATEREQUALTHAN shift and go to state 56

    comparingSign                  shift and go to state 49

state 25

    (71) arithmeticExpression -> LPAREN . arithmeticExpression RPAREN
    (97) logicalCondition -> LPAREN . logicalCondition RPAREN
    (69) arithmeticExpression -> . value
    (70) arithmeticExpression -> . arithmeticExpression arithmeticOperator arithmeticExpression
    (71) arithmeticExpression -> . LPAREN arithmeticExpression RPAREN
    (95) logicalCondition -> . comparingValue
    (96) logicalCondition -> . comparingValue conditionOperator comparingValue
    (97) logicalCondition -> . LPAREN logicalCondition RPAREN
    (72) value -> . ID
    (73) value -> . INTEGER
    (74) value -> . FLOAT
    (75) value -> . STRING
    (76) value -> . BOOL
    (77) value -> . NULL
    (94) comparingValue -> . value comparingSign value

    LPAREN          shift and go to state 25
    ID              shift and go to state 59
    INTEGER         shift and go to state 36
    FLOAT           shift and go to state 37
    STRING          shift and go to state 38
    BOOL            shift and go to state 39
    NULL            shift and go to state 40

    arithmeticExpression           shift and go to state 57
    logicalCondition               shift and go to state 58
    value                          shift and go to state 24
    comparingValue                 shift and go to state 35

state 26

    (29) if_elseStatement -> IF . LPAREN logicalCondition RPAREN LCURLY ifStatementBody RCURLY ELSE ifStatementBody
    (30) if_elseStatement -> IF . LPAREN logicalCondition RPAREN LCURLY ifStatementBody

    LPAREN          shift and go to state 60


state 27

    (34) forStatement -> FOR . LPAREN forStatementCondition RPAREN LCURLY forStatementBody RCURLY

    LPAREN          shift and go to state 61


state 28

    (24) switchStatement -> SWITCH . LPAREN value RPAREN LCURLY switchCases switchDefault RCURLY

    LPAREN          shift and go to state 62


state 29

    (40) arrayAsignation -> ID . EQUAL arrayDeclaration SEMICOLON
    (51) queueDeclaration -> ID . EQUAL NEW QUEUE SEMICOLON
    (52) queueEnqueue -> ID . OBJOP PUSH LPAREN value RPAREN SEMICOLON
    (53) queueDequeue -> ID . OBJOP POP SEMICOLON
    (68) fgets -> ID . EQUAL FGETS LPAREN STDIN RPAREN SEMICOLON
    (48) stackDeclaration -> ID . EQUAL NEW STACK SEMICOLON
    (49) stackPush -> ID . OBJOP PUSH LPAREN value RPAREN SEMICOLON
    (50) stackPop -> ID . OBJOP POP SEMICOLON
    (72) value -> ID .
    (85) variableAsignation -> ID . EQUAL value
    (86) variableAsignation -> ID . EQUAL arithmeticExpression

    EQUAL           shift and go to state 63
    OBJOP           shift and go to state 64
    IS_EQUAL        reduce using rule 72 (value -> ID .)
    IDENTICAL       reduce using rule 72 (value -> ID .)
    NOTEQUAL        reduce using rule 72 (value -> ID .)
    LESSTHAN        reduce using rule 72 (value -> ID .)
    GREATERTHAN     reduce using rule 72 (value -> ID .)
    LESSEQUALTHAN   reduce using rule 72 (value -> ID .)
    GREATEREQUALTHAN reduce using rule 72 (value -> ID .)
    PLUS            reduce using rule 72 (value -> ID .)
    MINUS           reduce using rule 72 (value -> ID .)
    TIMES           reduce using rule 72 (value -> ID .)
    DIVIDE          reduce using rule 72 (value -> ID .)
    MOD             reduce using rule 72 (value -> ID .)
    EXP             reduce using rule 72 (value -> ID .)
    OPEN_TAG        reduce using rule 72 (value -> ID .)
    CLOSE_TAG       reduce using rule 72 (value -> ID .)
    LPAREN          reduce using rule 72 (value -> ID .)
    IF              reduce using rule 72 (value -> ID .)
    FOR             reduce using rule 72 (value -> ID .)
    SWITCH          reduce using rule 72 (value -> ID .)
    ID              reduce using rule 72 (value -> ID .)
    FUNCTION        reduce using rule 72 (value -> ID .)
    FN              reduce using rule 72 (value -> ID .)
    ECHO            reduce using rule 72 (value -> ID .)
    PRINT           reduce using rule 72 (value -> ID .)
    INTEGER         reduce using rule 72 (value -> ID .)
    FLOAT           reduce using rule 72 (value -> ID .)
    STRING          reduce using rule 72 (value -> ID .)
    BOOL            reduce using rule 72 (value -> ID .)
    NULL            reduce using rule 72 (value -> ID .)
    $end            reduce using rule 72 (value -> ID .)
    RCURLY          reduce using rule 72 (value -> ID .)
    CONTINUE        reduce using rule 72 (value -> ID .)
    SEMICOLON       reduce using rule 72 (value -> ID .)
    BREAK           reduce using rule 72 (value -> ID .)


state 30

    (54) defineFunction -> FUNCTION . ID LPAREN arguments RPAREN LCURLY cuerpo RCURLY
    (55) defineFunction -> FUNCTION . ID LPAREN RPAREN LCURLY cuerpo RCURLY
    (58) anonymousFunction -> FUNCTION . LPAREN RPAREN LCURLY cuerpo RCURLY
    (59) anonymousFunction -> FUNCTION . LPAREN arguments RPAREN LCURLY cuerpo RCURLY

    ID              shift and go to state 65
    LPAREN          shift and go to state 66


state 31

    (60) arrowFunction -> FN . LPAREN ID RPAREN FNARROW arrowBody SEMICOLON

    LPAREN          shift and go to state 67


state 32

    (63) echo -> ECHO . values SEMICOLON
    (66) values -> . value
    (67) values -> . values COMMA value
    (72) value -> . ID
    (73) value -> . INTEGER
    (74) value -> . FLOAT
    (75) value -> . STRING
    (76) value -> . BOOL
    (77) value -> . NULL

    ID              shift and go to state 59
    INTEGER         shift and go to state 36
    FLOAT           shift and go to state 37
    STRING          shift and go to state 38
    BOOL            shift and go to state 39
    NULL            shift and go to state 40

    values                         shift and go to state 68
    value                          shift and go to state 69

state 33

    (84) line -> variableAsignation . SEMICOLON

    SEMICOLON       shift and go to state 70


state 34

    (64) print -> PRINT . LPAREN values RPAREN SEMICOLON
    (65) print -> PRINT . value SEMICOLON
    (72) value -> . ID
    (73) value -> . INTEGER
    (74) value -> . FLOAT
    (75) value -> . STRING
    (76) value -> . BOOL
    (77) value -> . NULL

    LPAREN          shift and go to state 71
    ID              shift and go to state 59
    INTEGER         shift and go to state 36
    FLOAT           shift and go to state 37
    STRING          shift and go to state 38
    BOOL            shift and go to state 39
    NULL            shift and go to state 40

    value                          shift and go to state 72

state 35

    (95) logicalCondition -> comparingValue .
    (96) logicalCondition -> comparingValue . conditionOperator comparingValue
    (98) conditionOperator -> . AND
    (99) conditionOperator -> . OR
    (100) conditionOperator -> . XOR

    OPEN_TAG        reduce using rule 95 (logicalCondition -> comparingValue .)
    CLOSE_TAG       reduce using rule 95 (logicalCondition -> comparingValue .)
    LPAREN          reduce using rule 95 (logicalCondition -> comparingValue .)
    IF              reduce using rule 95 (logicalCondition -> comparingValue .)
    FOR             reduce using rule 95 (logicalCondition -> comparingValue .)
    SWITCH          reduce using rule 95 (logicalCondition -> comparingValue .)
    ID              reduce using rule 95 (logicalCondition -> comparingValue .)
    FUNCTION        reduce using rule 95 (logicalCondition -> comparingValue .)
    FN              reduce using rule 95 (logicalCondition -> comparingValue .)
    ECHO            reduce using rule 95 (logicalCondition -> comparingValue .)
    PRINT           reduce using rule 95 (logicalCondition -> comparingValue .)
    INTEGER         reduce using rule 95 (logicalCondition -> comparingValue .)
    FLOAT           reduce using rule 95 (logicalCondition -> comparingValue .)
    STRING          reduce using rule 95 (logicalCondition -> comparingValue .)
    BOOL            reduce using rule 95 (logicalCondition -> comparingValue .)
    NULL            reduce using rule 95 (logicalCondition -> comparingValue .)
    $end            reduce using rule 95 (logicalCondition -> comparingValue .)
    RPAREN          reduce using rule 95 (logicalCondition -> comparingValue .)
    RCURLY          reduce using rule 95 (logicalCondition -> comparingValue .)
    CONTINUE        reduce using rule 95 (logicalCondition -> comparingValue .)
    SEMICOLON       reduce using rule 95 (logicalCondition -> comparingValue .)
    BREAK           reduce using rule 95 (logicalCondition -> comparingValue .)
    AND             shift and go to state 74
    OR              shift and go to state 75
    XOR             shift and go to state 76

    conditionOperator              shift and go to state 73

state 36

    (73) value -> INTEGER .

    IS_EQUAL        reduce using rule 73 (value -> INTEGER .)
    IDENTICAL       reduce using rule 73 (value -> INTEGER .)
    NOTEQUAL        reduce using rule 73 (value -> INTEGER .)
    LESSTHAN        reduce using rule 73 (value -> INTEGER .)
    GREATERTHAN     reduce using rule 73 (value -> INTEGER .)
    LESSEQUALTHAN   reduce using rule 73 (value -> INTEGER .)
    GREATEREQUALTHAN reduce using rule 73 (value -> INTEGER .)
    PLUS            reduce using rule 73 (value -> INTEGER .)
    MINUS           reduce using rule 73 (value -> INTEGER .)
    TIMES           reduce using rule 73 (value -> INTEGER .)
    DIVIDE          reduce using rule 73 (value -> INTEGER .)
    MOD             reduce using rule 73 (value -> INTEGER .)
    EXP             reduce using rule 73 (value -> INTEGER .)
    OPEN_TAG        reduce using rule 73 (value -> INTEGER .)
    CLOSE_TAG       reduce using rule 73 (value -> INTEGER .)
    LPAREN          reduce using rule 73 (value -> INTEGER .)
    IF              reduce using rule 73 (value -> INTEGER .)
    FOR             reduce using rule 73 (value -> INTEGER .)
    SWITCH          reduce using rule 73 (value -> INTEGER .)
    ID              reduce using rule 73 (value -> INTEGER .)
    FUNCTION        reduce using rule 73 (value -> INTEGER .)
    FN              reduce using rule 73 (value -> INTEGER .)
    ECHO            reduce using rule 73 (value -> INTEGER .)
    PRINT           reduce using rule 73 (value -> INTEGER .)
    INTEGER         reduce using rule 73 (value -> INTEGER .)
    FLOAT           reduce using rule 73 (value -> INTEGER .)
    STRING          reduce using rule 73 (value -> INTEGER .)
    BOOL            reduce using rule 73 (value -> INTEGER .)
    NULL            reduce using rule 73 (value -> INTEGER .)
    $end            reduce using rule 73 (value -> INTEGER .)
    RPAREN          reduce using rule 73 (value -> INTEGER .)
    SEMICOLON       reduce using rule 73 (value -> INTEGER .)
    COMMA           reduce using rule 73 (value -> INTEGER .)
    RCURLY          reduce using rule 73 (value -> INTEGER .)
    CONTINUE        reduce using rule 73 (value -> INTEGER .)
    BREAK           reduce using rule 73 (value -> INTEGER .)
    AND             reduce using rule 73 (value -> INTEGER .)
    OR              reduce using rule 73 (value -> INTEGER .)
    XOR             reduce using rule 73 (value -> INTEGER .)
    RSQUARE         reduce using rule 73 (value -> INTEGER .)
    COLON           reduce using rule 73 (value -> INTEGER .)


state 37

    (74) value -> FLOAT .

    IS_EQUAL        reduce using rule 74 (value -> FLOAT .)
    IDENTICAL       reduce using rule 74 (value -> FLOAT .)
    NOTEQUAL        reduce using rule 74 (value -> FLOAT .)
    LESSTHAN        reduce using rule 74 (value -> FLOAT .)
    GREATERTHAN     reduce using rule 74 (value -> FLOAT .)
    LESSEQUALTHAN   reduce using rule 74 (value -> FLOAT .)
    GREATEREQUALTHAN reduce using rule 74 (value -> FLOAT .)
    PLUS            reduce using rule 74 (value -> FLOAT .)
    MINUS           reduce using rule 74 (value -> FLOAT .)
    TIMES           reduce using rule 74 (value -> FLOAT .)
    DIVIDE          reduce using rule 74 (value -> FLOAT .)
    MOD             reduce using rule 74 (value -> FLOAT .)
    EXP             reduce using rule 74 (value -> FLOAT .)
    OPEN_TAG        reduce using rule 74 (value -> FLOAT .)
    CLOSE_TAG       reduce using rule 74 (value -> FLOAT .)
    LPAREN          reduce using rule 74 (value -> FLOAT .)
    IF              reduce using rule 74 (value -> FLOAT .)
    FOR             reduce using rule 74 (value -> FLOAT .)
    SWITCH          reduce using rule 74 (value -> FLOAT .)
    ID              reduce using rule 74 (value -> FLOAT .)
    FUNCTION        reduce using rule 74 (value -> FLOAT .)
    FN              reduce using rule 74 (value -> FLOAT .)
    ECHO            reduce using rule 74 (value -> FLOAT .)
    PRINT           reduce using rule 74 (value -> FLOAT .)
    INTEGER         reduce using rule 74 (value -> FLOAT .)
    FLOAT           reduce using rule 74 (value -> FLOAT .)
    STRING          reduce using rule 74 (value -> FLOAT .)
    BOOL            reduce using rule 74 (value -> FLOAT .)
    NULL            reduce using rule 74 (value -> FLOAT .)
    $end            reduce using rule 74 (value -> FLOAT .)
    RPAREN          reduce using rule 74 (value -> FLOAT .)
    SEMICOLON       reduce using rule 74 (value -> FLOAT .)
    COMMA           reduce using rule 74 (value -> FLOAT .)
    RCURLY          reduce using rule 74 (value -> FLOAT .)
    CONTINUE        reduce using rule 74 (value -> FLOAT .)
    BREAK           reduce using rule 74 (value -> FLOAT .)
    AND             reduce using rule 74 (value -> FLOAT .)
    OR              reduce using rule 74 (value -> FLOAT .)
    XOR             reduce using rule 74 (value -> FLOAT .)
    RSQUARE         reduce using rule 74 (value -> FLOAT .)
    COLON           reduce using rule 74 (value -> FLOAT .)


state 38

    (75) value -> STRING .

    IS_EQUAL        reduce using rule 75 (value -> STRING .)
    IDENTICAL       reduce using rule 75 (value -> STRING .)
    NOTEQUAL        reduce using rule 75 (value -> STRING .)
    LESSTHAN        reduce using rule 75 (value -> STRING .)
    GREATERTHAN     reduce using rule 75 (value -> STRING .)
    LESSEQUALTHAN   reduce using rule 75 (value -> STRING .)
    GREATEREQUALTHAN reduce using rule 75 (value -> STRING .)
    PLUS            reduce using rule 75 (value -> STRING .)
    MINUS           reduce using rule 75 (value -> STRING .)
    TIMES           reduce using rule 75 (value -> STRING .)
    DIVIDE          reduce using rule 75 (value -> STRING .)
    MOD             reduce using rule 75 (value -> STRING .)
    EXP             reduce using rule 75 (value -> STRING .)
    OPEN_TAG        reduce using rule 75 (value -> STRING .)
    CLOSE_TAG       reduce using rule 75 (value -> STRING .)
    LPAREN          reduce using rule 75 (value -> STRING .)
    IF              reduce using rule 75 (value -> STRING .)
    FOR             reduce using rule 75 (value -> STRING .)
    SWITCH          reduce using rule 75 (value -> STRING .)
    ID              reduce using rule 75 (value -> STRING .)
    FUNCTION        reduce using rule 75 (value -> STRING .)
    FN              reduce using rule 75 (value -> STRING .)
    ECHO            reduce using rule 75 (value -> STRING .)
    PRINT           reduce using rule 75 (value -> STRING .)
    INTEGER         reduce using rule 75 (value -> STRING .)
    FLOAT           reduce using rule 75 (value -> STRING .)
    STRING          reduce using rule 75 (value -> STRING .)
    BOOL            reduce using rule 75 (value -> STRING .)
    NULL            reduce using rule 75 (value -> STRING .)
    $end            reduce using rule 75 (value -> STRING .)
    RPAREN          reduce using rule 75 (value -> STRING .)
    SEMICOLON       reduce using rule 75 (value -> STRING .)
    COMMA           reduce using rule 75 (value -> STRING .)
    RCURLY          reduce using rule 75 (value -> STRING .)
    CONTINUE        reduce using rule 75 (value -> STRING .)
    BREAK           reduce using rule 75 (value -> STRING .)
    AND             reduce using rule 75 (value -> STRING .)
    OR              reduce using rule 75 (value -> STRING .)
    XOR             reduce using rule 75 (value -> STRING .)
    RSQUARE         reduce using rule 75 (value -> STRING .)
    COLON           reduce using rule 75 (value -> STRING .)


state 39

    (76) value -> BOOL .

    IS_EQUAL        reduce using rule 76 (value -> BOOL .)
    IDENTICAL       reduce using rule 76 (value -> BOOL .)
    NOTEQUAL        reduce using rule 76 (value -> BOOL .)
    LESSTHAN        reduce using rule 76 (value -> BOOL .)
    GREATERTHAN     reduce using rule 76 (value -> BOOL .)
    LESSEQUALTHAN   reduce using rule 76 (value -> BOOL .)
    GREATEREQUALTHAN reduce using rule 76 (value -> BOOL .)
    PLUS            reduce using rule 76 (value -> BOOL .)
    MINUS           reduce using rule 76 (value -> BOOL .)
    TIMES           reduce using rule 76 (value -> BOOL .)
    DIVIDE          reduce using rule 76 (value -> BOOL .)
    MOD             reduce using rule 76 (value -> BOOL .)
    EXP             reduce using rule 76 (value -> BOOL .)
    OPEN_TAG        reduce using rule 76 (value -> BOOL .)
    CLOSE_TAG       reduce using rule 76 (value -> BOOL .)
    LPAREN          reduce using rule 76 (value -> BOOL .)
    IF              reduce using rule 76 (value -> BOOL .)
    FOR             reduce using rule 76 (value -> BOOL .)
    SWITCH          reduce using rule 76 (value -> BOOL .)
    ID              reduce using rule 76 (value -> BOOL .)
    FUNCTION        reduce using rule 76 (value -> BOOL .)
    FN              reduce using rule 76 (value -> BOOL .)
    ECHO            reduce using rule 76 (value -> BOOL .)
    PRINT           reduce using rule 76 (value -> BOOL .)
    INTEGER         reduce using rule 76 (value -> BOOL .)
    FLOAT           reduce using rule 76 (value -> BOOL .)
    STRING          reduce using rule 76 (value -> BOOL .)
    BOOL            reduce using rule 76 (value -> BOOL .)
    NULL            reduce using rule 76 (value -> BOOL .)
    $end            reduce using rule 76 (value -> BOOL .)
    RPAREN          reduce using rule 76 (value -> BOOL .)
    SEMICOLON       reduce using rule 76 (value -> BOOL .)
    COMMA           reduce using rule 76 (value -> BOOL .)
    RCURLY          reduce using rule 76 (value -> BOOL .)
    CONTINUE        reduce using rule 76 (value -> BOOL .)
    BREAK           reduce using rule 76 (value -> BOOL .)
    AND             reduce using rule 76 (value -> BOOL .)
    OR              reduce using rule 76 (value -> BOOL .)
    XOR             reduce using rule 76 (value -> BOOL .)
    RSQUARE         reduce using rule 76 (value -> BOOL .)
    COLON           reduce using rule 76 (value -> BOOL .)


state 40

    (77) value -> NULL .

    IS_EQUAL        reduce using rule 77 (value -> NULL .)
    IDENTICAL       reduce using rule 77 (value -> NULL .)
    NOTEQUAL        reduce using rule 77 (value -> NULL .)
    LESSTHAN        reduce using rule 77 (value -> NULL .)
    GREATERTHAN     reduce using rule 77 (value -> NULL .)
    LESSEQUALTHAN   reduce using rule 77 (value -> NULL .)
    GREATEREQUALTHAN reduce using rule 77 (value -> NULL .)
    PLUS            reduce using rule 77 (value -> NULL .)
    MINUS           reduce using rule 77 (value -> NULL .)
    TIMES           reduce using rule 77 (value -> NULL .)
    DIVIDE          reduce using rule 77 (value -> NULL .)
    MOD             reduce using rule 77 (value -> NULL .)
    EXP             reduce using rule 77 (value -> NULL .)
    OPEN_TAG        reduce using rule 77 (value -> NULL .)
    CLOSE_TAG       reduce using rule 77 (value -> NULL .)
    LPAREN          reduce using rule 77 (value -> NULL .)
    IF              reduce using rule 77 (value -> NULL .)
    FOR             reduce using rule 77 (value -> NULL .)
    SWITCH          reduce using rule 77 (value -> NULL .)
    ID              reduce using rule 77 (value -> NULL .)
    FUNCTION        reduce using rule 77 (value -> NULL .)
    FN              reduce using rule 77 (value -> NULL .)
    ECHO            reduce using rule 77 (value -> NULL .)
    PRINT           reduce using rule 77 (value -> NULL .)
    INTEGER         reduce using rule 77 (value -> NULL .)
    FLOAT           reduce using rule 77 (value -> NULL .)
    STRING          reduce using rule 77 (value -> NULL .)
    BOOL            reduce using rule 77 (value -> NULL .)
    NULL            reduce using rule 77 (value -> NULL .)
    $end            reduce using rule 77 (value -> NULL .)
    RPAREN          reduce using rule 77 (value -> NULL .)
    SEMICOLON       reduce using rule 77 (value -> NULL .)
    COMMA           reduce using rule 77 (value -> NULL .)
    RCURLY          reduce using rule 77 (value -> NULL .)
    CONTINUE        reduce using rule 77 (value -> NULL .)
    BREAK           reduce using rule 77 (value -> NULL .)
    AND             reduce using rule 77 (value -> NULL .)
    OR              reduce using rule 77 (value -> NULL .)
    XOR             reduce using rule 77 (value -> NULL .)
    RSQUARE         reduce using rule 77 (value -> NULL .)
    COLON           reduce using rule 77 (value -> NULL .)


state 41

    (2) programa -> programa cuerpo .

    OPEN_TAG        reduce using rule 2 (programa -> programa cuerpo .)
    CLOSE_TAG       reduce using rule 2 (programa -> programa cuerpo .)
    LPAREN          reduce using rule 2 (programa -> programa cuerpo .)
    IF              reduce using rule 2 (programa -> programa cuerpo .)
    FOR             reduce using rule 2 (programa -> programa cuerpo .)
    SWITCH          reduce using rule 2 (programa -> programa cuerpo .)
    ID              reduce using rule 2 (programa -> programa cuerpo .)
    FUNCTION        reduce using rule 2 (programa -> programa cuerpo .)
    FN              reduce using rule 2 (programa -> programa cuerpo .)
    ECHO            reduce using rule 2 (programa -> programa cuerpo .)
    PRINT           reduce using rule 2 (programa -> programa cuerpo .)
    INTEGER         reduce using rule 2 (programa -> programa cuerpo .)
    FLOAT           reduce using rule 2 (programa -> programa cuerpo .)
    STRING          reduce using rule 2 (programa -> programa cuerpo .)
    BOOL            reduce using rule 2 (programa -> programa cuerpo .)
    NULL            reduce using rule 2 (programa -> programa cuerpo .)
    $end            reduce using rule 2 (programa -> programa cuerpo .)
    RCURLY          reduce using rule 2 (programa -> programa cuerpo .)
    BREAK           reduce using rule 2 (programa -> programa cuerpo .)


state 42

    (70) arithmeticExpression -> arithmeticExpression arithmeticOperator . arithmeticExpression
    (69) arithmeticExpression -> . value
    (70) arithmeticExpression -> . arithmeticExpression arithmeticOperator arithmeticExpression
    (71) arithmeticExpression -> . LPAREN arithmeticExpression RPAREN
    (72) value -> . ID
    (73) value -> . INTEGER
    (74) value -> . FLOAT
    (75) value -> . STRING
    (76) value -> . BOOL
    (77) value -> . NULL

    LPAREN          shift and go to state 79
    ID              shift and go to state 59
    INTEGER         shift and go to state 36
    FLOAT           shift and go to state 37
    STRING          shift and go to state 38
    BOOL            shift and go to state 39
    NULL            shift and go to state 40

    arithmeticExpression           shift and go to state 77
    value                          shift and go to state 78

state 43

    (78) arithmeticOperator -> PLUS .

    LPAREN          reduce using rule 78 (arithmeticOperator -> PLUS .)
    ID              reduce using rule 78 (arithmeticOperator -> PLUS .)
    INTEGER         reduce using rule 78 (arithmeticOperator -> PLUS .)
    FLOAT           reduce using rule 78 (arithmeticOperator -> PLUS .)
    STRING          reduce using rule 78 (arithmeticOperator -> PLUS .)
    BOOL            reduce using rule 78 (arithmeticOperator -> PLUS .)
    NULL            reduce using rule 78 (arithmeticOperator -> PLUS .)


state 44

    (79) arithmeticOperator -> MINUS .

    LPAREN          reduce using rule 79 (arithmeticOperator -> MINUS .)
    ID              reduce using rule 79 (arithmeticOperator -> MINUS .)
    INTEGER         reduce using rule 79 (arithmeticOperator -> MINUS .)
    FLOAT           reduce using rule 79 (arithmeticOperator -> MINUS .)
    STRING          reduce using rule 79 (arithmeticOperator -> MINUS .)
    BOOL            reduce using rule 79 (arithmeticOperator -> MINUS .)
    NULL            reduce using rule 79 (arithmeticOperator -> MINUS .)


state 45

    (80) arithmeticOperator -> TIMES .

    LPAREN          reduce using rule 80 (arithmeticOperator -> TIMES .)
    ID              reduce using rule 80 (arithmeticOperator -> TIMES .)
    INTEGER         reduce using rule 80 (arithmeticOperator -> TIMES .)
    FLOAT           reduce using rule 80 (arithmeticOperator -> TIMES .)
    STRING          reduce using rule 80 (arithmeticOperator -> TIMES .)
    BOOL            reduce using rule 80 (arithmeticOperator -> TIMES .)
    NULL            reduce using rule 80 (arithmeticOperator -> TIMES .)


state 46

    (81) arithmeticOperator -> DIVIDE .

    LPAREN          reduce using rule 81 (arithmeticOperator -> DIVIDE .)
    ID              reduce using rule 81 (arithmeticOperator -> DIVIDE .)
    INTEGER         reduce using rule 81 (arithmeticOperator -> DIVIDE .)
    FLOAT           reduce using rule 81 (arithmeticOperator -> DIVIDE .)
    STRING          reduce using rule 81 (arithmeticOperator -> DIVIDE .)
    BOOL            reduce using rule 81 (arithmeticOperator -> DIVIDE .)
    NULL            reduce using rule 81 (arithmeticOperator -> DIVIDE .)


state 47

    (82) arithmeticOperator -> MOD .

    LPAREN          reduce using rule 82 (arithmeticOperator -> MOD .)
    ID              reduce using rule 82 (arithmeticOperator -> MOD .)
    INTEGER         reduce using rule 82 (arithmeticOperator -> MOD .)
    FLOAT           reduce using rule 82 (arithmeticOperator -> MOD .)
    STRING          reduce using rule 82 (arithmeticOperator -> MOD .)
    BOOL            reduce using rule 82 (arithmeticOperator -> MOD .)
    NULL            reduce using rule 82 (arithmeticOperator -> MOD .)


state 48

    (83) arithmeticOperator -> EXP .

    LPAREN          reduce using rule 83 (arithmeticOperator -> EXP .)
    ID              reduce using rule 83 (arithmeticOperator -> EXP .)
    INTEGER         reduce using rule 83 (arithmeticOperator -> EXP .)
    FLOAT           reduce using rule 83 (arithmeticOperator -> EXP .)
    STRING          reduce using rule 83 (arithmeticOperator -> EXP .)
    BOOL            reduce using rule 83 (arithmeticOperator -> EXP .)
    NULL            reduce using rule 83 (arithmeticOperator -> EXP .)


state 49

    (94) comparingValue -> value comparingSign . value
    (72) value -> . ID
    (73) value -> . INTEGER
    (74) value -> . FLOAT
    (75) value -> . STRING
    (76) value -> . BOOL
    (77) value -> . NULL

    ID              shift and go to state 59
    INTEGER         shift and go to state 36
    FLOAT           shift and go to state 37
    STRING          shift and go to state 38
    BOOL            shift and go to state 39
    NULL            shift and go to state 40

    value                          shift and go to state 80

state 50

    (87) comparingSign -> IS_EQUAL .

    ID              reduce using rule 87 (comparingSign -> IS_EQUAL .)
    INTEGER         reduce using rule 87 (comparingSign -> IS_EQUAL .)
    FLOAT           reduce using rule 87 (comparingSign -> IS_EQUAL .)
    STRING          reduce using rule 87 (comparingSign -> IS_EQUAL .)
    BOOL            reduce using rule 87 (comparingSign -> IS_EQUAL .)
    NULL            reduce using rule 87 (comparingSign -> IS_EQUAL .)


state 51

    (88) comparingSign -> IDENTICAL .

    ID              reduce using rule 88 (comparingSign -> IDENTICAL .)
    INTEGER         reduce using rule 88 (comparingSign -> IDENTICAL .)
    FLOAT           reduce using rule 88 (comparingSign -> IDENTICAL .)
    STRING          reduce using rule 88 (comparingSign -> IDENTICAL .)
    BOOL            reduce using rule 88 (comparingSign -> IDENTICAL .)
    NULL            reduce using rule 88 (comparingSign -> IDENTICAL .)


state 52

    (89) comparingSign -> NOTEQUAL .

    ID              reduce using rule 89 (comparingSign -> NOTEQUAL .)
    INTEGER         reduce using rule 89 (comparingSign -> NOTEQUAL .)
    FLOAT           reduce using rule 89 (comparingSign -> NOTEQUAL .)
    STRING          reduce using rule 89 (comparingSign -> NOTEQUAL .)
    BOOL            reduce using rule 89 (comparingSign -> NOTEQUAL .)
    NULL            reduce using rule 89 (comparingSign -> NOTEQUAL .)


state 53

    (90) comparingSign -> LESSTHAN .

    ID              reduce using rule 90 (comparingSign -> LESSTHAN .)
    INTEGER         reduce using rule 90 (comparingSign -> LESSTHAN .)
    FLOAT           reduce using rule 90 (comparingSign -> LESSTHAN .)
    STRING          reduce using rule 90 (comparingSign -> LESSTHAN .)
    BOOL            reduce using rule 90 (comparingSign -> LESSTHAN .)
    NULL            reduce using rule 90 (comparingSign -> LESSTHAN .)


state 54

    (91) comparingSign -> GREATERTHAN .

    ID              reduce using rule 91 (comparingSign -> GREATERTHAN .)
    INTEGER         reduce using rule 91 (comparingSign -> GREATERTHAN .)
    FLOAT           reduce using rule 91 (comparingSign -> GREATERTHAN .)
    STRING          reduce using rule 91 (comparingSign -> GREATERTHAN .)
    BOOL            reduce using rule 91 (comparingSign -> GREATERTHAN .)
    NULL            reduce using rule 91 (comparingSign -> GREATERTHAN .)


state 55

    (92) comparingSign -> LESSEQUALTHAN .

    ID              reduce using rule 92 (comparingSign -> LESSEQUALTHAN .)
    INTEGER         reduce using rule 92 (comparingSign -> LESSEQUALTHAN .)
    FLOAT           reduce using rule 92 (comparingSign -> LESSEQUALTHAN .)
    STRING          reduce using rule 92 (comparingSign -> LESSEQUALTHAN .)
    BOOL            reduce using rule 92 (comparingSign -> LESSEQUALTHAN .)
    NULL            reduce using rule 92 (comparingSign -> LESSEQUALTHAN .)


state 56

    (93) comparingSign -> GREATEREQUALTHAN .

    ID              reduce using rule 93 (comparingSign -> GREATEREQUALTHAN .)
    INTEGER         reduce using rule 93 (comparingSign -> GREATEREQUALTHAN .)
    FLOAT           reduce using rule 93 (comparingSign -> GREATEREQUALTHAN .)
    STRING          reduce using rule 93 (comparingSign -> GREATEREQUALTHAN .)
    BOOL            reduce using rule 93 (comparingSign -> GREATEREQUALTHAN .)
    NULL            reduce using rule 93 (comparingSign -> GREATEREQUALTHAN .)


state 57

    (71) arithmeticExpression -> LPAREN arithmeticExpression . RPAREN
    (70) arithmeticExpression -> arithmeticExpression . arithmeticOperator arithmeticExpression
    (78) arithmeticOperator -> . PLUS
    (79) arithmeticOperator -> . MINUS
    (80) arithmeticOperator -> . TIMES
    (81) arithmeticOperator -> . DIVIDE
    (82) arithmeticOperator -> . MOD
    (83) arithmeticOperator -> . EXP

    RPAREN          shift and go to state 81
    PLUS            shift and go to state 43
    MINUS           shift and go to state 44
    TIMES           shift and go to state 45
    DIVIDE          shift and go to state 46
    MOD             shift and go to state 47
    EXP             shift and go to state 48

    arithmeticOperator             shift and go to state 42

state 58

    (97) logicalCondition -> LPAREN logicalCondition . RPAREN

    RPAREN          shift and go to state 82


state 59

    (72) value -> ID .

    IS_EQUAL        reduce using rule 72 (value -> ID .)
    IDENTICAL       reduce using rule 72 (value -> ID .)
    NOTEQUAL        reduce using rule 72 (value -> ID .)
    LESSTHAN        reduce using rule 72 (value -> ID .)
    GREATERTHAN     reduce using rule 72 (value -> ID .)
    LESSEQUALTHAN   reduce using rule 72 (value -> ID .)
    GREATEREQUALTHAN reduce using rule 72 (value -> ID .)
    RPAREN          reduce using rule 72 (value -> ID .)
    PLUS            reduce using rule 72 (value -> ID .)
    MINUS           reduce using rule 72 (value -> ID .)
    TIMES           reduce using rule 72 (value -> ID .)
    DIVIDE          reduce using rule 72 (value -> ID .)
    MOD             reduce using rule 72 (value -> ID .)
    EXP             reduce using rule 72 (value -> ID .)
    SEMICOLON       reduce using rule 72 (value -> ID .)
    COMMA           reduce using rule 72 (value -> ID .)
    OPEN_TAG        reduce using rule 72 (value -> ID .)
    CLOSE_TAG       reduce using rule 72 (value -> ID .)
    LPAREN          reduce using rule 72 (value -> ID .)
    IF              reduce using rule 72 (value -> ID .)
    FOR             reduce using rule 72 (value -> ID .)
    SWITCH          reduce using rule 72 (value -> ID .)
    ID              reduce using rule 72 (value -> ID .)
    FUNCTION        reduce using rule 72 (value -> ID .)
    FN              reduce using rule 72 (value -> ID .)
    ECHO            reduce using rule 72 (value -> ID .)
    PRINT           reduce using rule 72 (value -> ID .)
    INTEGER         reduce using rule 72 (value -> ID .)
    FLOAT           reduce using rule 72 (value -> ID .)
    STRING          reduce using rule 72 (value -> ID .)
    BOOL            reduce using rule 72 (value -> ID .)
    NULL            reduce using rule 72 (value -> ID .)
    $end            reduce using rule 72 (value -> ID .)
    RCURLY          reduce using rule 72 (value -> ID .)
    CONTINUE        reduce using rule 72 (value -> ID .)
    BREAK           reduce using rule 72 (value -> ID .)
    AND             reduce using rule 72 (value -> ID .)
    OR              reduce using rule 72 (value -> ID .)
    XOR             reduce using rule 72 (value -> ID .)
    RSQUARE         reduce using rule 72 (value -> ID .)
    COLON           reduce using rule 72 (value -> ID .)


state 60

    (29) if_elseStatement -> IF LPAREN . logicalCondition RPAREN LCURLY ifStatementBody RCURLY ELSE ifStatementBody
    (30) if_elseStatement -> IF LPAREN . logicalCondition RPAREN LCURLY ifStatementBody
    (95) logicalCondition -> . comparingValue
    (96) logicalCondition -> . comparingValue conditionOperator comparingValue
    (97) logicalCondition -> . LPAREN logicalCondition RPAREN
    (94) comparingValue -> . value comparingSign value
    (72) value -> . ID
    (73) value -> . INTEGER
    (74) value -> . FLOAT
    (75) value -> . STRING
    (76) value -> . BOOL
    (77) value -> . NULL

    LPAREN          shift and go to state 83
    ID              shift and go to state 59
    INTEGER         shift and go to state 36
    FLOAT           shift and go to state 37
    STRING          shift and go to state 38
    BOOL            shift and go to state 39
    NULL            shift and go to state 40

    logicalCondition               shift and go to state 84
    comparingValue                 shift and go to state 35
    value                          shift and go to state 85

state 61

    (34) forStatement -> FOR LPAREN . forStatementCondition RPAREN LCURLY forStatementBody RCURLY
    (35) forStatementCondition -> . SEMICOLON SEMICOLON
    (36) forStatementCondition -> . variableAsignation SEMICOLON SEMICOLON variableAsignation
    (37) forStatementCondition -> . variableAsignation SEMICOLON comparingValue SEMICOLON variableAsignation
    (85) variableAsignation -> . ID EQUAL value
    (86) variableAsignation -> . ID EQUAL arithmeticExpression

    SEMICOLON       shift and go to state 87
    ID              shift and go to state 89

    forStatementCondition          shift and go to state 86
    variableAsignation             shift and go to state 88

state 62

    (24) switchStatement -> SWITCH LPAREN . value RPAREN LCURLY switchCases switchDefault RCURLY
    (72) value -> . ID
    (73) value -> . INTEGER
    (74) value -> . FLOAT
    (75) value -> . STRING
    (76) value -> . BOOL
    (77) value -> . NULL

    ID              shift and go to state 59
    INTEGER         shift and go to state 36
    FLOAT           shift and go to state 37
    STRING          shift and go to state 38
    BOOL            shift and go to state 39
    NULL            shift and go to state 40

    value                          shift and go to state 90

state 63

    (40) arrayAsignation -> ID EQUAL . arrayDeclaration SEMICOLON
    (51) queueDeclaration -> ID EQUAL . NEW QUEUE SEMICOLON
    (68) fgets -> ID EQUAL . FGETS LPAREN STDIN RPAREN SEMICOLON
    (48) stackDeclaration -> ID EQUAL . NEW STACK SEMICOLON
    (85) variableAsignation -> ID EQUAL . value
    (86) variableAsignation -> ID EQUAL . arithmeticExpression
    (41) arrayDeclaration -> . ARRAY arraysValues RPAREN
    (42) arrayDeclaration -> . LSQUARE arraysValues RSQUARE
    (43) arrayDeclaration -> . arrayValue
    (72) value -> . ID
    (73) value -> . INTEGER
    (74) value -> . FLOAT
    (75) value -> . STRING
    (76) value -> . BOOL
    (77) value -> . NULL
    (69) arithmeticExpression -> . value
    (70) arithmeticExpression -> . arithmeticExpression arithmeticOperator arithmeticExpression
    (71) arithmeticExpression -> . LPAREN arithmeticExpression RPAREN
    (46) arrayValue -> . ARRAY values RPAREN
    (47) arrayValue -> . LSQUARE values RSQUARE

    NEW             shift and go to state 92
    FGETS           shift and go to state 93
    ARRAY           shift and go to state 96
    LSQUARE         shift and go to state 97
    ID              shift and go to state 59
    INTEGER         shift and go to state 36
    FLOAT           shift and go to state 37
    STRING          shift and go to state 38
    BOOL            shift and go to state 39
    NULL            shift and go to state 40
    LPAREN          shift and go to state 79

    arrayDeclaration               shift and go to state 91
    value                          shift and go to state 94
    arithmeticExpression           shift and go to state 95
    arrayValue                     shift and go to state 98

state 64

    (52) queueEnqueue -> ID OBJOP . PUSH LPAREN value RPAREN SEMICOLON
    (53) queueDequeue -> ID OBJOP . POP SEMICOLON
    (49) stackPush -> ID OBJOP . PUSH LPAREN value RPAREN SEMICOLON
    (50) stackPop -> ID OBJOP . POP SEMICOLON

    PUSH            shift and go to state 99
    POP             shift and go to state 100


state 65

    (54) defineFunction -> FUNCTION ID . LPAREN arguments RPAREN LCURLY cuerpo RCURLY
    (55) defineFunction -> FUNCTION ID . LPAREN RPAREN LCURLY cuerpo RCURLY

    LPAREN          shift and go to state 101


state 66

    (58) anonymousFunction -> FUNCTION LPAREN . RPAREN LCURLY cuerpo RCURLY
    (59) anonymousFunction -> FUNCTION LPAREN . arguments RPAREN LCURLY cuerpo RCURLY
    (56) arguments -> . ID
    (57) arguments -> . ID COMMA arguments

    RPAREN          shift and go to state 102
    ID              shift and go to state 104

    arguments                      shift and go to state 103

state 67

    (60) arrowFunction -> FN LPAREN . ID RPAREN FNARROW arrowBody SEMICOLON

    ID              shift and go to state 105


state 68

    (63) echo -> ECHO values . SEMICOLON
    (67) values -> values . COMMA value

    SEMICOLON       shift and go to state 106
    COMMA           shift and go to state 107


state 69

    (66) values -> value .

    SEMICOLON       reduce using rule 66 (values -> value .)
    COMMA           reduce using rule 66 (values -> value .)
    RPAREN          reduce using rule 66 (values -> value .)
    RSQUARE         reduce using rule 66 (values -> value .)


state 70

    (84) line -> variableAsignation SEMICOLON .

    OPEN_TAG        reduce using rule 84 (line -> variableAsignation SEMICOLON .)
    CLOSE_TAG       reduce using rule 84 (line -> variableAsignation SEMICOLON .)
    LPAREN          reduce using rule 84 (line -> variableAsignation SEMICOLON .)
    IF              reduce using rule 84 (line -> variableAsignation SEMICOLON .)
    FOR             reduce using rule 84 (line -> variableAsignation SEMICOLON .)
    SWITCH          reduce using rule 84 (line -> variableAsignation SEMICOLON .)
    ID              reduce using rule 84 (line -> variableAsignation SEMICOLON .)
    FUNCTION        reduce using rule 84 (line -> variableAsignation SEMICOLON .)
    FN              reduce using rule 84 (line -> variableAsignation SEMICOLON .)
    ECHO            reduce using rule 84 (line -> variableAsignation SEMICOLON .)
    PRINT           reduce using rule 84 (line -> variableAsignation SEMICOLON .)
    INTEGER         reduce using rule 84 (line -> variableAsignation SEMICOLON .)
    FLOAT           reduce using rule 84 (line -> variableAsignation SEMICOLON .)
    STRING          reduce using rule 84 (line -> variableAsignation SEMICOLON .)
    BOOL            reduce using rule 84 (line -> variableAsignation SEMICOLON .)
    NULL            reduce using rule 84 (line -> variableAsignation SEMICOLON .)
    $end            reduce using rule 84 (line -> variableAsignation SEMICOLON .)
    RCURLY          reduce using rule 84 (line -> variableAsignation SEMICOLON .)
    CONTINUE        reduce using rule 84 (line -> variableAsignation SEMICOLON .)
    SEMICOLON       reduce using rule 84 (line -> variableAsignation SEMICOLON .)
    BREAK           reduce using rule 84 (line -> variableAsignation SEMICOLON .)


state 71

    (64) print -> PRINT LPAREN . values RPAREN SEMICOLON
    (66) values -> . value
    (67) values -> . values COMMA value
    (72) value -> . ID
    (73) value -> . INTEGER
    (74) value -> . FLOAT
    (75) value -> . STRING
    (76) value -> . BOOL
    (77) value -> . NULL

    ID              shift and go to state 59
    INTEGER         shift and go to state 36
    FLOAT           shift and go to state 37
    STRING          shift and go to state 38
    BOOL            shift and go to state 39
    NULL            shift and go to state 40

    values                         shift and go to state 108
    value                          shift and go to state 69

state 72

    (65) print -> PRINT value . SEMICOLON

    SEMICOLON       shift and go to state 109


state 73

    (96) logicalCondition -> comparingValue conditionOperator . comparingValue
    (94) comparingValue -> . value comparingSign value
    (72) value -> . ID
    (73) value -> . INTEGER
    (74) value -> . FLOAT
    (75) value -> . STRING
    (76) value -> . BOOL
    (77) value -> . NULL

    ID              shift and go to state 59
    INTEGER         shift and go to state 36
    FLOAT           shift and go to state 37
    STRING          shift and go to state 38
    BOOL            shift and go to state 39
    NULL            shift and go to state 40

    comparingValue                 shift and go to state 110
    value                          shift and go to state 85

state 74

    (98) conditionOperator -> AND .

    ID              reduce using rule 98 (conditionOperator -> AND .)
    INTEGER         reduce using rule 98 (conditionOperator -> AND .)
    FLOAT           reduce using rule 98 (conditionOperator -> AND .)
    STRING          reduce using rule 98 (conditionOperator -> AND .)
    BOOL            reduce using rule 98 (conditionOperator -> AND .)
    NULL            reduce using rule 98 (conditionOperator -> AND .)


state 75

    (99) conditionOperator -> OR .

    ID              reduce using rule 99 (conditionOperator -> OR .)
    INTEGER         reduce using rule 99 (conditionOperator -> OR .)
    FLOAT           reduce using rule 99 (conditionOperator -> OR .)
    STRING          reduce using rule 99 (conditionOperator -> OR .)
    BOOL            reduce using rule 99 (conditionOperator -> OR .)
    NULL            reduce using rule 99 (conditionOperator -> OR .)


state 76

    (100) conditionOperator -> XOR .

    ID              reduce using rule 100 (conditionOperator -> XOR .)
    INTEGER         reduce using rule 100 (conditionOperator -> XOR .)
    FLOAT           reduce using rule 100 (conditionOperator -> XOR .)
    STRING          reduce using rule 100 (conditionOperator -> XOR .)
    BOOL            reduce using rule 100 (conditionOperator -> XOR .)
    NULL            reduce using rule 100 (conditionOperator -> XOR .)


state 77

    (70) arithmeticExpression -> arithmeticExpression arithmeticOperator arithmeticExpression .
    (70) arithmeticExpression -> arithmeticExpression . arithmeticOperator arithmeticExpression
    (78) arithmeticOperator -> . PLUS
    (79) arithmeticOperator -> . MINUS
    (80) arithmeticOperator -> . TIMES
    (81) arithmeticOperator -> . DIVIDE
    (82) arithmeticOperator -> . MOD
    (83) arithmeticOperator -> . EXP

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for EXP resolved as shift
    OPEN_TAG        reduce using rule 70 (arithmeticExpression -> arithmeticExpression arithmeticOperator arithmeticExpression .)
    CLOSE_TAG       reduce using rule 70 (arithmeticExpression -> arithmeticExpression arithmeticOperator arithmeticExpression .)
    LPAREN          reduce using rule 70 (arithmeticExpression -> arithmeticExpression arithmeticOperator arithmeticExpression .)
    IF              reduce using rule 70 (arithmeticExpression -> arithmeticExpression arithmeticOperator arithmeticExpression .)
    FOR             reduce using rule 70 (arithmeticExpression -> arithmeticExpression arithmeticOperator arithmeticExpression .)
    SWITCH          reduce using rule 70 (arithmeticExpression -> arithmeticExpression arithmeticOperator arithmeticExpression .)
    ID              reduce using rule 70 (arithmeticExpression -> arithmeticExpression arithmeticOperator arithmeticExpression .)
    FUNCTION        reduce using rule 70 (arithmeticExpression -> arithmeticExpression arithmeticOperator arithmeticExpression .)
    FN              reduce using rule 70 (arithmeticExpression -> arithmeticExpression arithmeticOperator arithmeticExpression .)
    ECHO            reduce using rule 70 (arithmeticExpression -> arithmeticExpression arithmeticOperator arithmeticExpression .)
    PRINT           reduce using rule 70 (arithmeticExpression -> arithmeticExpression arithmeticOperator arithmeticExpression .)
    INTEGER         reduce using rule 70 (arithmeticExpression -> arithmeticExpression arithmeticOperator arithmeticExpression .)
    FLOAT           reduce using rule 70 (arithmeticExpression -> arithmeticExpression arithmeticOperator arithmeticExpression .)
    STRING          reduce using rule 70 (arithmeticExpression -> arithmeticExpression arithmeticOperator arithmeticExpression .)
    BOOL            reduce using rule 70 (arithmeticExpression -> arithmeticExpression arithmeticOperator arithmeticExpression .)
    NULL            reduce using rule 70 (arithmeticExpression -> arithmeticExpression arithmeticOperator arithmeticExpression .)
    $end            reduce using rule 70 (arithmeticExpression -> arithmeticExpression arithmeticOperator arithmeticExpression .)
    RPAREN          reduce using rule 70 (arithmeticExpression -> arithmeticExpression arithmeticOperator arithmeticExpression .)
    SEMICOLON       reduce using rule 70 (arithmeticExpression -> arithmeticExpression arithmeticOperator arithmeticExpression .)
    RCURLY          reduce using rule 70 (arithmeticExpression -> arithmeticExpression arithmeticOperator arithmeticExpression .)
    CONTINUE        reduce using rule 70 (arithmeticExpression -> arithmeticExpression arithmeticOperator arithmeticExpression .)
    BREAK           reduce using rule 70 (arithmeticExpression -> arithmeticExpression arithmeticOperator arithmeticExpression .)
    PLUS            shift and go to state 43
    MINUS           shift and go to state 44
    TIMES           shift and go to state 45
    DIVIDE          shift and go to state 46
    MOD             shift and go to state 47
    EXP             shift and go to state 48

  ! PLUS            [ reduce using rule 70 (arithmeticExpression -> arithmeticExpression arithmeticOperator arithmeticExpression .) ]
  ! MINUS           [ reduce using rule 70 (arithmeticExpression -> arithmeticExpression arithmeticOperator arithmeticExpression .) ]
  ! TIMES           [ reduce using rule 70 (arithmeticExpression -> arithmeticExpression arithmeticOperator arithmeticExpression .) ]
  ! DIVIDE          [ reduce using rule 70 (arithmeticExpression -> arithmeticExpression arithmeticOperator arithmeticExpression .) ]
  ! MOD             [ reduce using rule 70 (arithmeticExpression -> arithmeticExpression arithmeticOperator arithmeticExpression .) ]
  ! EXP             [ reduce using rule 70 (arithmeticExpression -> arithmeticExpression arithmeticOperator arithmeticExpression .) ]

    arithmeticOperator             shift and go to state 42

state 78

    (69) arithmeticExpression -> value .

    PLUS            reduce using rule 69 (arithmeticExpression -> value .)
    MINUS           reduce using rule 69 (arithmeticExpression -> value .)
    TIMES           reduce using rule 69 (arithmeticExpression -> value .)
    DIVIDE          reduce using rule 69 (arithmeticExpression -> value .)
    MOD             reduce using rule 69 (arithmeticExpression -> value .)
    EXP             reduce using rule 69 (arithmeticExpression -> value .)
    OPEN_TAG        reduce using rule 69 (arithmeticExpression -> value .)
    CLOSE_TAG       reduce using rule 69 (arithmeticExpression -> value .)
    LPAREN          reduce using rule 69 (arithmeticExpression -> value .)
    IF              reduce using rule 69 (arithmeticExpression -> value .)
    FOR             reduce using rule 69 (arithmeticExpression -> value .)
    SWITCH          reduce using rule 69 (arithmeticExpression -> value .)
    ID              reduce using rule 69 (arithmeticExpression -> value .)
    FUNCTION        reduce using rule 69 (arithmeticExpression -> value .)
    FN              reduce using rule 69 (arithmeticExpression -> value .)
    ECHO            reduce using rule 69 (arithmeticExpression -> value .)
    PRINT           reduce using rule 69 (arithmeticExpression -> value .)
    INTEGER         reduce using rule 69 (arithmeticExpression -> value .)
    FLOAT           reduce using rule 69 (arithmeticExpression -> value .)
    STRING          reduce using rule 69 (arithmeticExpression -> value .)
    BOOL            reduce using rule 69 (arithmeticExpression -> value .)
    NULL            reduce using rule 69 (arithmeticExpression -> value .)
    $end            reduce using rule 69 (arithmeticExpression -> value .)
    RPAREN          reduce using rule 69 (arithmeticExpression -> value .)
    SEMICOLON       reduce using rule 69 (arithmeticExpression -> value .)
    RCURLY          reduce using rule 69 (arithmeticExpression -> value .)
    CONTINUE        reduce using rule 69 (arithmeticExpression -> value .)
    BREAK           reduce using rule 69 (arithmeticExpression -> value .)


state 79

    (71) arithmeticExpression -> LPAREN . arithmeticExpression RPAREN
    (69) arithmeticExpression -> . value
    (70) arithmeticExpression -> . arithmeticExpression arithmeticOperator arithmeticExpression
    (71) arithmeticExpression -> . LPAREN arithmeticExpression RPAREN
    (72) value -> . ID
    (73) value -> . INTEGER
    (74) value -> . FLOAT
    (75) value -> . STRING
    (76) value -> . BOOL
    (77) value -> . NULL

    LPAREN          shift and go to state 79
    ID              shift and go to state 59
    INTEGER         shift and go to state 36
    FLOAT           shift and go to state 37
    STRING          shift and go to state 38
    BOOL            shift and go to state 39
    NULL            shift and go to state 40

    arithmeticExpression           shift and go to state 57
    value                          shift and go to state 78

state 80

    (94) comparingValue -> value comparingSign value .

    AND             reduce using rule 94 (comparingValue -> value comparingSign value .)
    OR              reduce using rule 94 (comparingValue -> value comparingSign value .)
    XOR             reduce using rule 94 (comparingValue -> value comparingSign value .)
    OPEN_TAG        reduce using rule 94 (comparingValue -> value comparingSign value .)
    CLOSE_TAG       reduce using rule 94 (comparingValue -> value comparingSign value .)
    LPAREN          reduce using rule 94 (comparingValue -> value comparingSign value .)
    IF              reduce using rule 94 (comparingValue -> value comparingSign value .)
    FOR             reduce using rule 94 (comparingValue -> value comparingSign value .)
    SWITCH          reduce using rule 94 (comparingValue -> value comparingSign value .)
    ID              reduce using rule 94 (comparingValue -> value comparingSign value .)
    FUNCTION        reduce using rule 94 (comparingValue -> value comparingSign value .)
    FN              reduce using rule 94 (comparingValue -> value comparingSign value .)
    ECHO            reduce using rule 94 (comparingValue -> value comparingSign value .)
    PRINT           reduce using rule 94 (comparingValue -> value comparingSign value .)
    INTEGER         reduce using rule 94 (comparingValue -> value comparingSign value .)
    FLOAT           reduce using rule 94 (comparingValue -> value comparingSign value .)
    STRING          reduce using rule 94 (comparingValue -> value comparingSign value .)
    BOOL            reduce using rule 94 (comparingValue -> value comparingSign value .)
    NULL            reduce using rule 94 (comparingValue -> value comparingSign value .)
    $end            reduce using rule 94 (comparingValue -> value comparingSign value .)
    RPAREN          reduce using rule 94 (comparingValue -> value comparingSign value .)
    RCURLY          reduce using rule 94 (comparingValue -> value comparingSign value .)
    CONTINUE        reduce using rule 94 (comparingValue -> value comparingSign value .)
    SEMICOLON       reduce using rule 94 (comparingValue -> value comparingSign value .)
    BREAK           reduce using rule 94 (comparingValue -> value comparingSign value .)


state 81

    (71) arithmeticExpression -> LPAREN arithmeticExpression RPAREN .

    PLUS            reduce using rule 71 (arithmeticExpression -> LPAREN arithmeticExpression RPAREN .)
    MINUS           reduce using rule 71 (arithmeticExpression -> LPAREN arithmeticExpression RPAREN .)
    TIMES           reduce using rule 71 (arithmeticExpression -> LPAREN arithmeticExpression RPAREN .)
    DIVIDE          reduce using rule 71 (arithmeticExpression -> LPAREN arithmeticExpression RPAREN .)
    MOD             reduce using rule 71 (arithmeticExpression -> LPAREN arithmeticExpression RPAREN .)
    EXP             reduce using rule 71 (arithmeticExpression -> LPAREN arithmeticExpression RPAREN .)
    OPEN_TAG        reduce using rule 71 (arithmeticExpression -> LPAREN arithmeticExpression RPAREN .)
    CLOSE_TAG       reduce using rule 71 (arithmeticExpression -> LPAREN arithmeticExpression RPAREN .)
    LPAREN          reduce using rule 71 (arithmeticExpression -> LPAREN arithmeticExpression RPAREN .)
    IF              reduce using rule 71 (arithmeticExpression -> LPAREN arithmeticExpression RPAREN .)
    FOR             reduce using rule 71 (arithmeticExpression -> LPAREN arithmeticExpression RPAREN .)
    SWITCH          reduce using rule 71 (arithmeticExpression -> LPAREN arithmeticExpression RPAREN .)
    ID              reduce using rule 71 (arithmeticExpression -> LPAREN arithmeticExpression RPAREN .)
    FUNCTION        reduce using rule 71 (arithmeticExpression -> LPAREN arithmeticExpression RPAREN .)
    FN              reduce using rule 71 (arithmeticExpression -> LPAREN arithmeticExpression RPAREN .)
    ECHO            reduce using rule 71 (arithmeticExpression -> LPAREN arithmeticExpression RPAREN .)
    PRINT           reduce using rule 71 (arithmeticExpression -> LPAREN arithmeticExpression RPAREN .)
    INTEGER         reduce using rule 71 (arithmeticExpression -> LPAREN arithmeticExpression RPAREN .)
    FLOAT           reduce using rule 71 (arithmeticExpression -> LPAREN arithmeticExpression RPAREN .)
    STRING          reduce using rule 71 (arithmeticExpression -> LPAREN arithmeticExpression RPAREN .)
    BOOL            reduce using rule 71 (arithmeticExpression -> LPAREN arithmeticExpression RPAREN .)
    NULL            reduce using rule 71 (arithmeticExpression -> LPAREN arithmeticExpression RPAREN .)
    $end            reduce using rule 71 (arithmeticExpression -> LPAREN arithmeticExpression RPAREN .)
    RPAREN          reduce using rule 71 (arithmeticExpression -> LPAREN arithmeticExpression RPAREN .)
    SEMICOLON       reduce using rule 71 (arithmeticExpression -> LPAREN arithmeticExpression RPAREN .)
    RCURLY          reduce using rule 71 (arithmeticExpression -> LPAREN arithmeticExpression RPAREN .)
    CONTINUE        reduce using rule 71 (arithmeticExpression -> LPAREN arithmeticExpression RPAREN .)
    BREAK           reduce using rule 71 (arithmeticExpression -> LPAREN arithmeticExpression RPAREN .)


state 82

    (97) logicalCondition -> LPAREN logicalCondition RPAREN .

    OPEN_TAG        reduce using rule 97 (logicalCondition -> LPAREN logicalCondition RPAREN .)
    CLOSE_TAG       reduce using rule 97 (logicalCondition -> LPAREN logicalCondition RPAREN .)
    LPAREN          reduce using rule 97 (logicalCondition -> LPAREN logicalCondition RPAREN .)
    IF              reduce using rule 97 (logicalCondition -> LPAREN logicalCondition RPAREN .)
    FOR             reduce using rule 97 (logicalCondition -> LPAREN logicalCondition RPAREN .)
    SWITCH          reduce using rule 97 (logicalCondition -> LPAREN logicalCondition RPAREN .)
    ID              reduce using rule 97 (logicalCondition -> LPAREN logicalCondition RPAREN .)
    FUNCTION        reduce using rule 97 (logicalCondition -> LPAREN logicalCondition RPAREN .)
    FN              reduce using rule 97 (logicalCondition -> LPAREN logicalCondition RPAREN .)
    ECHO            reduce using rule 97 (logicalCondition -> LPAREN logicalCondition RPAREN .)
    PRINT           reduce using rule 97 (logicalCondition -> LPAREN logicalCondition RPAREN .)
    INTEGER         reduce using rule 97 (logicalCondition -> LPAREN logicalCondition RPAREN .)
    FLOAT           reduce using rule 97 (logicalCondition -> LPAREN logicalCondition RPAREN .)
    STRING          reduce using rule 97 (logicalCondition -> LPAREN logicalCondition RPAREN .)
    BOOL            reduce using rule 97 (logicalCondition -> LPAREN logicalCondition RPAREN .)
    NULL            reduce using rule 97 (logicalCondition -> LPAREN logicalCondition RPAREN .)
    $end            reduce using rule 97 (logicalCondition -> LPAREN logicalCondition RPAREN .)
    RPAREN          reduce using rule 97 (logicalCondition -> LPAREN logicalCondition RPAREN .)
    RCURLY          reduce using rule 97 (logicalCondition -> LPAREN logicalCondition RPAREN .)
    CONTINUE        reduce using rule 97 (logicalCondition -> LPAREN logicalCondition RPAREN .)
    SEMICOLON       reduce using rule 97 (logicalCondition -> LPAREN logicalCondition RPAREN .)
    BREAK           reduce using rule 97 (logicalCondition -> LPAREN logicalCondition RPAREN .)


state 83

    (97) logicalCondition -> LPAREN . logicalCondition RPAREN
    (95) logicalCondition -> . comparingValue
    (96) logicalCondition -> . comparingValue conditionOperator comparingValue
    (97) logicalCondition -> . LPAREN logicalCondition RPAREN
    (94) comparingValue -> . value comparingSign value
    (72) value -> . ID
    (73) value -> . INTEGER
    (74) value -> . FLOAT
    (75) value -> . STRING
    (76) value -> . BOOL
    (77) value -> . NULL

    LPAREN          shift and go to state 83
    ID              shift and go to state 59
    INTEGER         shift and go to state 36
    FLOAT           shift and go to state 37
    STRING          shift and go to state 38
    BOOL            shift and go to state 39
    NULL            shift and go to state 40

    logicalCondition               shift and go to state 58
    comparingValue                 shift and go to state 35
    value                          shift and go to state 85

state 84

    (29) if_elseStatement -> IF LPAREN logicalCondition . RPAREN LCURLY ifStatementBody RCURLY ELSE ifStatementBody
    (30) if_elseStatement -> IF LPAREN logicalCondition . RPAREN LCURLY ifStatementBody

    RPAREN          shift and go to state 111


state 85

    (94) comparingValue -> value . comparingSign value
    (87) comparingSign -> . IS_EQUAL
    (88) comparingSign -> . IDENTICAL
    (89) comparingSign -> . NOTEQUAL
    (90) comparingSign -> . LESSTHAN
    (91) comparingSign -> . GREATERTHAN
    (92) comparingSign -> . LESSEQUALTHAN
    (93) comparingSign -> . GREATEREQUALTHAN

    IS_EQUAL        shift and go to state 50
    IDENTICAL       shift and go to state 51
    NOTEQUAL        shift and go to state 52
    LESSTHAN        shift and go to state 53
    GREATERTHAN     shift and go to state 54
    LESSEQUALTHAN   shift and go to state 55
    GREATEREQUALTHAN shift and go to state 56

    comparingSign                  shift and go to state 49

state 86

    (34) forStatement -> FOR LPAREN forStatementCondition . RPAREN LCURLY forStatementBody RCURLY

    RPAREN          shift and go to state 112


state 87

    (35) forStatementCondition -> SEMICOLON . SEMICOLON

    SEMICOLON       shift and go to state 113


state 88

    (36) forStatementCondition -> variableAsignation . SEMICOLON SEMICOLON variableAsignation
    (37) forStatementCondition -> variableAsignation . SEMICOLON comparingValue SEMICOLON variableAsignation

    SEMICOLON       shift and go to state 114


state 89

    (85) variableAsignation -> ID . EQUAL value
    (86) variableAsignation -> ID . EQUAL arithmeticExpression

    EQUAL           shift and go to state 115


state 90

    (24) switchStatement -> SWITCH LPAREN value . RPAREN LCURLY switchCases switchDefault RCURLY

    RPAREN          shift and go to state 116


state 91

    (40) arrayAsignation -> ID EQUAL arrayDeclaration . SEMICOLON

    SEMICOLON       shift and go to state 117


state 92

    (51) queueDeclaration -> ID EQUAL NEW . QUEUE SEMICOLON
    (48) stackDeclaration -> ID EQUAL NEW . STACK SEMICOLON

    QUEUE           shift and go to state 118
    STACK           shift and go to state 119


state 93

    (68) fgets -> ID EQUAL FGETS . LPAREN STDIN RPAREN SEMICOLON

    LPAREN          shift and go to state 120


state 94

    (85) variableAsignation -> ID EQUAL value .
    (69) arithmeticExpression -> value .

  ! reduce/reduce conflict for SEMICOLON resolved using rule 69 (arithmeticExpression -> value .)
  ! reduce/reduce conflict for RPAREN resolved using rule 69 (arithmeticExpression -> value .)
    PLUS            reduce using rule 69 (arithmeticExpression -> value .)
    MINUS           reduce using rule 69 (arithmeticExpression -> value .)
    TIMES           reduce using rule 69 (arithmeticExpression -> value .)
    DIVIDE          reduce using rule 69 (arithmeticExpression -> value .)
    MOD             reduce using rule 69 (arithmeticExpression -> value .)
    EXP             reduce using rule 69 (arithmeticExpression -> value .)
    SEMICOLON       reduce using rule 69 (arithmeticExpression -> value .)
    RPAREN          reduce using rule 69 (arithmeticExpression -> value .)

  ! SEMICOLON       [ reduce using rule 85 (variableAsignation -> ID EQUAL value .) ]
  ! RPAREN          [ reduce using rule 85 (variableAsignation -> ID EQUAL value .) ]


state 95

    (86) variableAsignation -> ID EQUAL arithmeticExpression .
    (70) arithmeticExpression -> arithmeticExpression . arithmeticOperator arithmeticExpression
    (78) arithmeticOperator -> . PLUS
    (79) arithmeticOperator -> . MINUS
    (80) arithmeticOperator -> . TIMES
    (81) arithmeticOperator -> . DIVIDE
    (82) arithmeticOperator -> . MOD
    (83) arithmeticOperator -> . EXP

    SEMICOLON       reduce using rule 86 (variableAsignation -> ID EQUAL arithmeticExpression .)
    RPAREN          reduce using rule 86 (variableAsignation -> ID EQUAL arithmeticExpression .)
    PLUS            shift and go to state 43
    MINUS           shift and go to state 44
    TIMES           shift and go to state 45
    DIVIDE          shift and go to state 46
    MOD             shift and go to state 47
    EXP             shift and go to state 48

    arithmeticOperator             shift and go to state 42

state 96

    (41) arrayDeclaration -> ARRAY . arraysValues RPAREN
    (46) arrayValue -> ARRAY . values RPAREN
    (44) arraysValues -> . arrayValue
    (45) arraysValues -> . arraysValues COMMA arrayValue
    (66) values -> . value
    (67) values -> . values COMMA value
    (46) arrayValue -> . ARRAY values RPAREN
    (47) arrayValue -> . LSQUARE values RSQUARE
    (72) value -> . ID
    (73) value -> . INTEGER
    (74) value -> . FLOAT
    (75) value -> . STRING
    (76) value -> . BOOL
    (77) value -> . NULL

    ARRAY           shift and go to state 121
    LSQUARE         shift and go to state 125
    ID              shift and go to state 59
    INTEGER         shift and go to state 36
    FLOAT           shift and go to state 37
    STRING          shift and go to state 38
    BOOL            shift and go to state 39
    NULL            shift and go to state 40

    arraysValues                   shift and go to state 122
    values                         shift and go to state 123
    arrayValue                     shift and go to state 124
    value                          shift and go to state 69

state 97

    (42) arrayDeclaration -> LSQUARE . arraysValues RSQUARE
    (47) arrayValue -> LSQUARE . values RSQUARE
    (44) arraysValues -> . arrayValue
    (45) arraysValues -> . arraysValues COMMA arrayValue
    (66) values -> . value
    (67) values -> . values COMMA value
    (46) arrayValue -> . ARRAY values RPAREN
    (47) arrayValue -> . LSQUARE values RSQUARE
    (72) value -> . ID
    (73) value -> . INTEGER
    (74) value -> . FLOAT
    (75) value -> . STRING
    (76) value -> . BOOL
    (77) value -> . NULL

    ARRAY           shift and go to state 121
    LSQUARE         shift and go to state 125
    ID              shift and go to state 59
    INTEGER         shift and go to state 36
    FLOAT           shift and go to state 37
    STRING          shift and go to state 38
    BOOL            shift and go to state 39
    NULL            shift and go to state 40

    arraysValues                   shift and go to state 126
    values                         shift and go to state 127
    arrayValue                     shift and go to state 124
    value                          shift and go to state 69

state 98

    (43) arrayDeclaration -> arrayValue .

    SEMICOLON       reduce using rule 43 (arrayDeclaration -> arrayValue .)


state 99

    (52) queueEnqueue -> ID OBJOP PUSH . LPAREN value RPAREN SEMICOLON
    (49) stackPush -> ID OBJOP PUSH . LPAREN value RPAREN SEMICOLON

    LPAREN          shift and go to state 128


state 100

    (53) queueDequeue -> ID OBJOP POP . SEMICOLON
    (50) stackPop -> ID OBJOP POP . SEMICOLON

    SEMICOLON       shift and go to state 129


state 101

    (54) defineFunction -> FUNCTION ID LPAREN . arguments RPAREN LCURLY cuerpo RCURLY
    (55) defineFunction -> FUNCTION ID LPAREN . RPAREN LCURLY cuerpo RCURLY
    (56) arguments -> . ID
    (57) arguments -> . ID COMMA arguments

    RPAREN          shift and go to state 131
    ID              shift and go to state 104

    arguments                      shift and go to state 130

state 102

    (58) anonymousFunction -> FUNCTION LPAREN RPAREN . LCURLY cuerpo RCURLY

    LCURLY          shift and go to state 132


state 103

    (59) anonymousFunction -> FUNCTION LPAREN arguments . RPAREN LCURLY cuerpo RCURLY

    RPAREN          shift and go to state 133


state 104

    (56) arguments -> ID .
    (57) arguments -> ID . COMMA arguments

    RPAREN          reduce using rule 56 (arguments -> ID .)
    COMMA           shift and go to state 134


state 105

    (60) arrowFunction -> FN LPAREN ID . RPAREN FNARROW arrowBody SEMICOLON

    RPAREN          shift and go to state 135


state 106

    (63) echo -> ECHO values SEMICOLON .

    OPEN_TAG        reduce using rule 63 (echo -> ECHO values SEMICOLON .)
    CLOSE_TAG       reduce using rule 63 (echo -> ECHO values SEMICOLON .)
    LPAREN          reduce using rule 63 (echo -> ECHO values SEMICOLON .)
    IF              reduce using rule 63 (echo -> ECHO values SEMICOLON .)
    FOR             reduce using rule 63 (echo -> ECHO values SEMICOLON .)
    SWITCH          reduce using rule 63 (echo -> ECHO values SEMICOLON .)
    ID              reduce using rule 63 (echo -> ECHO values SEMICOLON .)
    FUNCTION        reduce using rule 63 (echo -> ECHO values SEMICOLON .)
    FN              reduce using rule 63 (echo -> ECHO values SEMICOLON .)
    ECHO            reduce using rule 63 (echo -> ECHO values SEMICOLON .)
    PRINT           reduce using rule 63 (echo -> ECHO values SEMICOLON .)
    INTEGER         reduce using rule 63 (echo -> ECHO values SEMICOLON .)
    FLOAT           reduce using rule 63 (echo -> ECHO values SEMICOLON .)
    STRING          reduce using rule 63 (echo -> ECHO values SEMICOLON .)
    BOOL            reduce using rule 63 (echo -> ECHO values SEMICOLON .)
    NULL            reduce using rule 63 (echo -> ECHO values SEMICOLON .)
    $end            reduce using rule 63 (echo -> ECHO values SEMICOLON .)
    RCURLY          reduce using rule 63 (echo -> ECHO values SEMICOLON .)
    CONTINUE        reduce using rule 63 (echo -> ECHO values SEMICOLON .)
    SEMICOLON       reduce using rule 63 (echo -> ECHO values SEMICOLON .)
    BREAK           reduce using rule 63 (echo -> ECHO values SEMICOLON .)


state 107

    (67) values -> values COMMA . value
    (72) value -> . ID
    (73) value -> . INTEGER
    (74) value -> . FLOAT
    (75) value -> . STRING
    (76) value -> . BOOL
    (77) value -> . NULL

    ID              shift and go to state 59
    INTEGER         shift and go to state 36
    FLOAT           shift and go to state 37
    STRING          shift and go to state 38
    BOOL            shift and go to state 39
    NULL            shift and go to state 40

    value                          shift and go to state 136

state 108

    (64) print -> PRINT LPAREN values . RPAREN SEMICOLON
    (67) values -> values . COMMA value

    RPAREN          shift and go to state 137
    COMMA           shift and go to state 107


state 109

    (65) print -> PRINT value SEMICOLON .

    OPEN_TAG        reduce using rule 65 (print -> PRINT value SEMICOLON .)
    CLOSE_TAG       reduce using rule 65 (print -> PRINT value SEMICOLON .)
    LPAREN          reduce using rule 65 (print -> PRINT value SEMICOLON .)
    IF              reduce using rule 65 (print -> PRINT value SEMICOLON .)
    FOR             reduce using rule 65 (print -> PRINT value SEMICOLON .)
    SWITCH          reduce using rule 65 (print -> PRINT value SEMICOLON .)
    ID              reduce using rule 65 (print -> PRINT value SEMICOLON .)
    FUNCTION        reduce using rule 65 (print -> PRINT value SEMICOLON .)
    FN              reduce using rule 65 (print -> PRINT value SEMICOLON .)
    ECHO            reduce using rule 65 (print -> PRINT value SEMICOLON .)
    PRINT           reduce using rule 65 (print -> PRINT value SEMICOLON .)
    INTEGER         reduce using rule 65 (print -> PRINT value SEMICOLON .)
    FLOAT           reduce using rule 65 (print -> PRINT value SEMICOLON .)
    STRING          reduce using rule 65 (print -> PRINT value SEMICOLON .)
    BOOL            reduce using rule 65 (print -> PRINT value SEMICOLON .)
    NULL            reduce using rule 65 (print -> PRINT value SEMICOLON .)
    $end            reduce using rule 65 (print -> PRINT value SEMICOLON .)
    RCURLY          reduce using rule 65 (print -> PRINT value SEMICOLON .)
    CONTINUE        reduce using rule 65 (print -> PRINT value SEMICOLON .)
    SEMICOLON       reduce using rule 65 (print -> PRINT value SEMICOLON .)
    BREAK           reduce using rule 65 (print -> PRINT value SEMICOLON .)


state 110

    (96) logicalCondition -> comparingValue conditionOperator comparingValue .

    OPEN_TAG        reduce using rule 96 (logicalCondition -> comparingValue conditionOperator comparingValue .)
    CLOSE_TAG       reduce using rule 96 (logicalCondition -> comparingValue conditionOperator comparingValue .)
    LPAREN          reduce using rule 96 (logicalCondition -> comparingValue conditionOperator comparingValue .)
    IF              reduce using rule 96 (logicalCondition -> comparingValue conditionOperator comparingValue .)
    FOR             reduce using rule 96 (logicalCondition -> comparingValue conditionOperator comparingValue .)
    SWITCH          reduce using rule 96 (logicalCondition -> comparingValue conditionOperator comparingValue .)
    ID              reduce using rule 96 (logicalCondition -> comparingValue conditionOperator comparingValue .)
    FUNCTION        reduce using rule 96 (logicalCondition -> comparingValue conditionOperator comparingValue .)
    FN              reduce using rule 96 (logicalCondition -> comparingValue conditionOperator comparingValue .)
    ECHO            reduce using rule 96 (logicalCondition -> comparingValue conditionOperator comparingValue .)
    PRINT           reduce using rule 96 (logicalCondition -> comparingValue conditionOperator comparingValue .)
    INTEGER         reduce using rule 96 (logicalCondition -> comparingValue conditionOperator comparingValue .)
    FLOAT           reduce using rule 96 (logicalCondition -> comparingValue conditionOperator comparingValue .)
    STRING          reduce using rule 96 (logicalCondition -> comparingValue conditionOperator comparingValue .)
    BOOL            reduce using rule 96 (logicalCondition -> comparingValue conditionOperator comparingValue .)
    NULL            reduce using rule 96 (logicalCondition -> comparingValue conditionOperator comparingValue .)
    $end            reduce using rule 96 (logicalCondition -> comparingValue conditionOperator comparingValue .)
    RPAREN          reduce using rule 96 (logicalCondition -> comparingValue conditionOperator comparingValue .)
    RCURLY          reduce using rule 96 (logicalCondition -> comparingValue conditionOperator comparingValue .)
    CONTINUE        reduce using rule 96 (logicalCondition -> comparingValue conditionOperator comparingValue .)
    SEMICOLON       reduce using rule 96 (logicalCondition -> comparingValue conditionOperator comparingValue .)
    BREAK           reduce using rule 96 (logicalCondition -> comparingValue conditionOperator comparingValue .)


state 111

    (29) if_elseStatement -> IF LPAREN logicalCondition RPAREN . LCURLY ifStatementBody RCURLY ELSE ifStatementBody
    (30) if_elseStatement -> IF LPAREN logicalCondition RPAREN . LCURLY ifStatementBody

    LCURLY          shift and go to state 138


state 112

    (34) forStatement -> FOR LPAREN forStatementCondition RPAREN . LCURLY forStatementBody RCURLY

    LCURLY          shift and go to state 139


state 113

    (35) forStatementCondition -> SEMICOLON SEMICOLON .

    RPAREN          reduce using rule 35 (forStatementCondition -> SEMICOLON SEMICOLON .)


state 114

    (36) forStatementCondition -> variableAsignation SEMICOLON . SEMICOLON variableAsignation
    (37) forStatementCondition -> variableAsignation SEMICOLON . comparingValue SEMICOLON variableAsignation
    (94) comparingValue -> . value comparingSign value
    (72) value -> . ID
    (73) value -> . INTEGER
    (74) value -> . FLOAT
    (75) value -> . STRING
    (76) value -> . BOOL
    (77) value -> . NULL

    SEMICOLON       shift and go to state 140
    ID              shift and go to state 59
    INTEGER         shift and go to state 36
    FLOAT           shift and go to state 37
    STRING          shift and go to state 38
    BOOL            shift and go to state 39
    NULL            shift and go to state 40

    comparingValue                 shift and go to state 141
    value                          shift and go to state 85

state 115

    (85) variableAsignation -> ID EQUAL . value
    (86) variableAsignation -> ID EQUAL . arithmeticExpression
    (72) value -> . ID
    (73) value -> . INTEGER
    (74) value -> . FLOAT
    (75) value -> . STRING
    (76) value -> . BOOL
    (77) value -> . NULL
    (69) arithmeticExpression -> . value
    (70) arithmeticExpression -> . arithmeticExpression arithmeticOperator arithmeticExpression
    (71) arithmeticExpression -> . LPAREN arithmeticExpression RPAREN

    ID              shift and go to state 59
    INTEGER         shift and go to state 36
    FLOAT           shift and go to state 37
    STRING          shift and go to state 38
    BOOL            shift and go to state 39
    NULL            shift and go to state 40
    LPAREN          shift and go to state 79

    value                          shift and go to state 94
    arithmeticExpression           shift and go to state 95

state 116

    (24) switchStatement -> SWITCH LPAREN value RPAREN . LCURLY switchCases switchDefault RCURLY

    LCURLY          shift and go to state 142


state 117

    (40) arrayAsignation -> ID EQUAL arrayDeclaration SEMICOLON .

    OPEN_TAG        reduce using rule 40 (arrayAsignation -> ID EQUAL arrayDeclaration SEMICOLON .)
    CLOSE_TAG       reduce using rule 40 (arrayAsignation -> ID EQUAL arrayDeclaration SEMICOLON .)
    LPAREN          reduce using rule 40 (arrayAsignation -> ID EQUAL arrayDeclaration SEMICOLON .)
    IF              reduce using rule 40 (arrayAsignation -> ID EQUAL arrayDeclaration SEMICOLON .)
    FOR             reduce using rule 40 (arrayAsignation -> ID EQUAL arrayDeclaration SEMICOLON .)
    SWITCH          reduce using rule 40 (arrayAsignation -> ID EQUAL arrayDeclaration SEMICOLON .)
    ID              reduce using rule 40 (arrayAsignation -> ID EQUAL arrayDeclaration SEMICOLON .)
    FUNCTION        reduce using rule 40 (arrayAsignation -> ID EQUAL arrayDeclaration SEMICOLON .)
    FN              reduce using rule 40 (arrayAsignation -> ID EQUAL arrayDeclaration SEMICOLON .)
    ECHO            reduce using rule 40 (arrayAsignation -> ID EQUAL arrayDeclaration SEMICOLON .)
    PRINT           reduce using rule 40 (arrayAsignation -> ID EQUAL arrayDeclaration SEMICOLON .)
    INTEGER         reduce using rule 40 (arrayAsignation -> ID EQUAL arrayDeclaration SEMICOLON .)
    FLOAT           reduce using rule 40 (arrayAsignation -> ID EQUAL arrayDeclaration SEMICOLON .)
    STRING          reduce using rule 40 (arrayAsignation -> ID EQUAL arrayDeclaration SEMICOLON .)
    BOOL            reduce using rule 40 (arrayAsignation -> ID EQUAL arrayDeclaration SEMICOLON .)
    NULL            reduce using rule 40 (arrayAsignation -> ID EQUAL arrayDeclaration SEMICOLON .)
    $end            reduce using rule 40 (arrayAsignation -> ID EQUAL arrayDeclaration SEMICOLON .)
    RCURLY          reduce using rule 40 (arrayAsignation -> ID EQUAL arrayDeclaration SEMICOLON .)
    CONTINUE        reduce using rule 40 (arrayAsignation -> ID EQUAL arrayDeclaration SEMICOLON .)
    SEMICOLON       reduce using rule 40 (arrayAsignation -> ID EQUAL arrayDeclaration SEMICOLON .)
    BREAK           reduce using rule 40 (arrayAsignation -> ID EQUAL arrayDeclaration SEMICOLON .)


state 118

    (51) queueDeclaration -> ID EQUAL NEW QUEUE . SEMICOLON

    SEMICOLON       shift and go to state 143


state 119

    (48) stackDeclaration -> ID EQUAL NEW STACK . SEMICOLON

    SEMICOLON       shift and go to state 144


state 120

    (68) fgets -> ID EQUAL FGETS LPAREN . STDIN RPAREN SEMICOLON

    STDIN           shift and go to state 145


state 121

    (46) arrayValue -> ARRAY . values RPAREN
    (66) values -> . value
    (67) values -> . values COMMA value
    (72) value -> . ID
    (73) value -> . INTEGER
    (74) value -> . FLOAT
    (75) value -> . STRING
    (76) value -> . BOOL
    (77) value -> . NULL

    ID              shift and go to state 59
    INTEGER         shift and go to state 36
    FLOAT           shift and go to state 37
    STRING          shift and go to state 38
    BOOL            shift and go to state 39
    NULL            shift and go to state 40

    values                         shift and go to state 123
    value                          shift and go to state 69

state 122

    (41) arrayDeclaration -> ARRAY arraysValues . RPAREN
    (45) arraysValues -> arraysValues . COMMA arrayValue

    RPAREN          shift and go to state 146
    COMMA           shift and go to state 147


state 123

    (46) arrayValue -> ARRAY values . RPAREN
    (67) values -> values . COMMA value

    RPAREN          shift and go to state 148
    COMMA           shift and go to state 107


state 124

    (44) arraysValues -> arrayValue .

    RPAREN          reduce using rule 44 (arraysValues -> arrayValue .)
    COMMA           reduce using rule 44 (arraysValues -> arrayValue .)
    RSQUARE         reduce using rule 44 (arraysValues -> arrayValue .)


state 125

    (47) arrayValue -> LSQUARE . values RSQUARE
    (66) values -> . value
    (67) values -> . values COMMA value
    (72) value -> . ID
    (73) value -> . INTEGER
    (74) value -> . FLOAT
    (75) value -> . STRING
    (76) value -> . BOOL
    (77) value -> . NULL

    ID              shift and go to state 59
    INTEGER         shift and go to state 36
    FLOAT           shift and go to state 37
    STRING          shift and go to state 38
    BOOL            shift and go to state 39
    NULL            shift and go to state 40

    values                         shift and go to state 127
    value                          shift and go to state 69

state 126

    (42) arrayDeclaration -> LSQUARE arraysValues . RSQUARE
    (45) arraysValues -> arraysValues . COMMA arrayValue

    RSQUARE         shift and go to state 149
    COMMA           shift and go to state 147


state 127

    (47) arrayValue -> LSQUARE values . RSQUARE
    (67) values -> values . COMMA value

    RSQUARE         shift and go to state 150
    COMMA           shift and go to state 107


state 128

    (52) queueEnqueue -> ID OBJOP PUSH LPAREN . value RPAREN SEMICOLON
    (49) stackPush -> ID OBJOP PUSH LPAREN . value RPAREN SEMICOLON
    (72) value -> . ID
    (73) value -> . INTEGER
    (74) value -> . FLOAT
    (75) value -> . STRING
    (76) value -> . BOOL
    (77) value -> . NULL

    ID              shift and go to state 59
    INTEGER         shift and go to state 36
    FLOAT           shift and go to state 37
    STRING          shift and go to state 38
    BOOL            shift and go to state 39
    NULL            shift and go to state 40

    value                          shift and go to state 151

state 129

    (53) queueDequeue -> ID OBJOP POP SEMICOLON .
    (50) stackPop -> ID OBJOP POP SEMICOLON .

  ! reduce/reduce conflict for OPEN_TAG resolved using rule 50 (stackPop -> ID OBJOP POP SEMICOLON .)
  ! reduce/reduce conflict for CLOSE_TAG resolved using rule 50 (stackPop -> ID OBJOP POP SEMICOLON .)
  ! reduce/reduce conflict for LPAREN resolved using rule 50 (stackPop -> ID OBJOP POP SEMICOLON .)
  ! reduce/reduce conflict for IF resolved using rule 50 (stackPop -> ID OBJOP POP SEMICOLON .)
  ! reduce/reduce conflict for FOR resolved using rule 50 (stackPop -> ID OBJOP POP SEMICOLON .)
  ! reduce/reduce conflict for SWITCH resolved using rule 50 (stackPop -> ID OBJOP POP SEMICOLON .)
  ! reduce/reduce conflict for ID resolved using rule 50 (stackPop -> ID OBJOP POP SEMICOLON .)
  ! reduce/reduce conflict for FUNCTION resolved using rule 50 (stackPop -> ID OBJOP POP SEMICOLON .)
  ! reduce/reduce conflict for FN resolved using rule 50 (stackPop -> ID OBJOP POP SEMICOLON .)
  ! reduce/reduce conflict for ECHO resolved using rule 50 (stackPop -> ID OBJOP POP SEMICOLON .)
  ! reduce/reduce conflict for PRINT resolved using rule 50 (stackPop -> ID OBJOP POP SEMICOLON .)
  ! reduce/reduce conflict for INTEGER resolved using rule 50 (stackPop -> ID OBJOP POP SEMICOLON .)
  ! reduce/reduce conflict for FLOAT resolved using rule 50 (stackPop -> ID OBJOP POP SEMICOLON .)
  ! reduce/reduce conflict for STRING resolved using rule 50 (stackPop -> ID OBJOP POP SEMICOLON .)
  ! reduce/reduce conflict for BOOL resolved using rule 50 (stackPop -> ID OBJOP POP SEMICOLON .)
  ! reduce/reduce conflict for NULL resolved using rule 50 (stackPop -> ID OBJOP POP SEMICOLON .)
  ! reduce/reduce conflict for $end resolved using rule 50 (stackPop -> ID OBJOP POP SEMICOLON .)
  ! reduce/reduce conflict for RCURLY resolved using rule 50 (stackPop -> ID OBJOP POP SEMICOLON .)
  ! reduce/reduce conflict for CONTINUE resolved using rule 50 (stackPop -> ID OBJOP POP SEMICOLON .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 50 (stackPop -> ID OBJOP POP SEMICOLON .)
  ! reduce/reduce conflict for BREAK resolved using rule 50 (stackPop -> ID OBJOP POP SEMICOLON .)
    OPEN_TAG        reduce using rule 50 (stackPop -> ID OBJOP POP SEMICOLON .)
    CLOSE_TAG       reduce using rule 50 (stackPop -> ID OBJOP POP SEMICOLON .)
    LPAREN          reduce using rule 50 (stackPop -> ID OBJOP POP SEMICOLON .)
    IF              reduce using rule 50 (stackPop -> ID OBJOP POP SEMICOLON .)
    FOR             reduce using rule 50 (stackPop -> ID OBJOP POP SEMICOLON .)
    SWITCH          reduce using rule 50 (stackPop -> ID OBJOP POP SEMICOLON .)
    ID              reduce using rule 50 (stackPop -> ID OBJOP POP SEMICOLON .)
    FUNCTION        reduce using rule 50 (stackPop -> ID OBJOP POP SEMICOLON .)
    FN              reduce using rule 50 (stackPop -> ID OBJOP POP SEMICOLON .)
    ECHO            reduce using rule 50 (stackPop -> ID OBJOP POP SEMICOLON .)
    PRINT           reduce using rule 50 (stackPop -> ID OBJOP POP SEMICOLON .)
    INTEGER         reduce using rule 50 (stackPop -> ID OBJOP POP SEMICOLON .)
    FLOAT           reduce using rule 50 (stackPop -> ID OBJOP POP SEMICOLON .)
    STRING          reduce using rule 50 (stackPop -> ID OBJOP POP SEMICOLON .)
    BOOL            reduce using rule 50 (stackPop -> ID OBJOP POP SEMICOLON .)
    NULL            reduce using rule 50 (stackPop -> ID OBJOP POP SEMICOLON .)
    $end            reduce using rule 50 (stackPop -> ID OBJOP POP SEMICOLON .)
    RCURLY          reduce using rule 50 (stackPop -> ID OBJOP POP SEMICOLON .)
    CONTINUE        reduce using rule 50 (stackPop -> ID OBJOP POP SEMICOLON .)
    SEMICOLON       reduce using rule 50 (stackPop -> ID OBJOP POP SEMICOLON .)
    BREAK           reduce using rule 50 (stackPop -> ID OBJOP POP SEMICOLON .)

  ! OPEN_TAG        [ reduce using rule 53 (queueDequeue -> ID OBJOP POP SEMICOLON .) ]
  ! CLOSE_TAG       [ reduce using rule 53 (queueDequeue -> ID OBJOP POP SEMICOLON .) ]
  ! LPAREN          [ reduce using rule 53 (queueDequeue -> ID OBJOP POP SEMICOLON .) ]
  ! IF              [ reduce using rule 53 (queueDequeue -> ID OBJOP POP SEMICOLON .) ]
  ! FOR             [ reduce using rule 53 (queueDequeue -> ID OBJOP POP SEMICOLON .) ]
  ! SWITCH          [ reduce using rule 53 (queueDequeue -> ID OBJOP POP SEMICOLON .) ]
  ! ID              [ reduce using rule 53 (queueDequeue -> ID OBJOP POP SEMICOLON .) ]
  ! FUNCTION        [ reduce using rule 53 (queueDequeue -> ID OBJOP POP SEMICOLON .) ]
  ! FN              [ reduce using rule 53 (queueDequeue -> ID OBJOP POP SEMICOLON .) ]
  ! ECHO            [ reduce using rule 53 (queueDequeue -> ID OBJOP POP SEMICOLON .) ]
  ! PRINT           [ reduce using rule 53 (queueDequeue -> ID OBJOP POP SEMICOLON .) ]
  ! INTEGER         [ reduce using rule 53 (queueDequeue -> ID OBJOP POP SEMICOLON .) ]
  ! FLOAT           [ reduce using rule 53 (queueDequeue -> ID OBJOP POP SEMICOLON .) ]
  ! STRING          [ reduce using rule 53 (queueDequeue -> ID OBJOP POP SEMICOLON .) ]
  ! BOOL            [ reduce using rule 53 (queueDequeue -> ID OBJOP POP SEMICOLON .) ]
  ! NULL            [ reduce using rule 53 (queueDequeue -> ID OBJOP POP SEMICOLON .) ]
  ! $end            [ reduce using rule 53 (queueDequeue -> ID OBJOP POP SEMICOLON .) ]
  ! RCURLY          [ reduce using rule 53 (queueDequeue -> ID OBJOP POP SEMICOLON .) ]
  ! CONTINUE        [ reduce using rule 53 (queueDequeue -> ID OBJOP POP SEMICOLON .) ]
  ! SEMICOLON       [ reduce using rule 53 (queueDequeue -> ID OBJOP POP SEMICOLON .) ]
  ! BREAK           [ reduce using rule 53 (queueDequeue -> ID OBJOP POP SEMICOLON .) ]


state 130

    (54) defineFunction -> FUNCTION ID LPAREN arguments . RPAREN LCURLY cuerpo RCURLY

    RPAREN          shift and go to state 152


state 131

    (55) defineFunction -> FUNCTION ID LPAREN RPAREN . LCURLY cuerpo RCURLY

    LCURLY          shift and go to state 153


state 132

    (58) anonymousFunction -> FUNCTION LPAREN RPAREN LCURLY . cuerpo RCURLY
    (3) cuerpo -> . arithmeticExpression
    (4) cuerpo -> . if_elseStatement
    (5) cuerpo -> . forStatement
    (6) cuerpo -> . switchStatement
    (7) cuerpo -> . arrayAsignation
    (8) cuerpo -> . queueDeclaration
    (9) cuerpo -> . queueEnqueue
    (10) cuerpo -> . queueDequeue
    (11) cuerpo -> . defineFunction
    (12) cuerpo -> . anonymousFunction
    (13) cuerpo -> . arrowFunction
    (14) cuerpo -> . echo
    (15) cuerpo -> . fgets
    (16) cuerpo -> . stackDeclaration
    (17) cuerpo -> . stackPush
    (18) cuerpo -> . stackPop
    (19) cuerpo -> . line
    (20) cuerpo -> . print
    (21) cuerpo -> . logicalCondition
    (22) cuerpo -> . OPEN_TAG
    (23) cuerpo -> . CLOSE_TAG
    (69) arithmeticExpression -> . value
    (70) arithmeticExpression -> . arithmeticExpression arithmeticOperator arithmeticExpression
    (71) arithmeticExpression -> . LPAREN arithmeticExpression RPAREN
    (29) if_elseStatement -> . IF LPAREN logicalCondition RPAREN LCURLY ifStatementBody RCURLY ELSE ifStatementBody
    (30) if_elseStatement -> . IF LPAREN logicalCondition RPAREN LCURLY ifStatementBody
    (34) forStatement -> . FOR LPAREN forStatementCondition RPAREN LCURLY forStatementBody RCURLY
    (24) switchStatement -> . SWITCH LPAREN value RPAREN LCURLY switchCases switchDefault RCURLY
    (40) arrayAsignation -> . ID EQUAL arrayDeclaration SEMICOLON
    (51) queueDeclaration -> . ID EQUAL NEW QUEUE SEMICOLON
    (52) queueEnqueue -> . ID OBJOP PUSH LPAREN value RPAREN SEMICOLON
    (53) queueDequeue -> . ID OBJOP POP SEMICOLON
    (54) defineFunction -> . FUNCTION ID LPAREN arguments RPAREN LCURLY cuerpo RCURLY
    (55) defineFunction -> . FUNCTION ID LPAREN RPAREN LCURLY cuerpo RCURLY
    (58) anonymousFunction -> . FUNCTION LPAREN RPAREN LCURLY cuerpo RCURLY
    (59) anonymousFunction -> . FUNCTION LPAREN arguments RPAREN LCURLY cuerpo RCURLY
    (60) arrowFunction -> . FN LPAREN ID RPAREN FNARROW arrowBody SEMICOLON
    (63) echo -> . ECHO values SEMICOLON
    (68) fgets -> . ID EQUAL FGETS LPAREN STDIN RPAREN SEMICOLON
    (48) stackDeclaration -> . ID EQUAL NEW STACK SEMICOLON
    (49) stackPush -> . ID OBJOP PUSH LPAREN value RPAREN SEMICOLON
    (50) stackPop -> . ID OBJOP POP SEMICOLON
    (84) line -> . variableAsignation SEMICOLON
    (64) print -> . PRINT LPAREN values RPAREN SEMICOLON
    (65) print -> . PRINT value SEMICOLON
    (95) logicalCondition -> . comparingValue
    (96) logicalCondition -> . comparingValue conditionOperator comparingValue
    (97) logicalCondition -> . LPAREN logicalCondition RPAREN
    (72) value -> . ID
    (73) value -> . INTEGER
    (74) value -> . FLOAT
    (75) value -> . STRING
    (76) value -> . BOOL
    (77) value -> . NULL
    (85) variableAsignation -> . ID EQUAL value
    (86) variableAsignation -> . ID EQUAL arithmeticExpression
    (94) comparingValue -> . value comparingSign value

    OPEN_TAG        shift and go to state 22
    CLOSE_TAG       shift and go to state 23
    LPAREN          shift and go to state 25
    IF              shift and go to state 26
    FOR             shift and go to state 27
    SWITCH          shift and go to state 28
    ID              shift and go to state 29
    FUNCTION        shift and go to state 30
    FN              shift and go to state 31
    ECHO            shift and go to state 32
    PRINT           shift and go to state 34
    INTEGER         shift and go to state 36
    FLOAT           shift and go to state 37
    STRING          shift and go to state 38
    BOOL            shift and go to state 39
    NULL            shift and go to state 40

    cuerpo                         shift and go to state 154
    arithmeticExpression           shift and go to state 3
    if_elseStatement               shift and go to state 4
    forStatement                   shift and go to state 5
    switchStatement                shift and go to state 6
    arrayAsignation                shift and go to state 7
    queueDeclaration               shift and go to state 8
    queueEnqueue                   shift and go to state 9
    queueDequeue                   shift and go to state 10
    defineFunction                 shift and go to state 11
    anonymousFunction              shift and go to state 12
    arrowFunction                  shift and go to state 13
    echo                           shift and go to state 14
    fgets                          shift and go to state 15
    stackDeclaration               shift and go to state 16
    stackPush                      shift and go to state 17
    stackPop                       shift and go to state 18
    line                           shift and go to state 19
    print                          shift and go to state 20
    logicalCondition               shift and go to state 21
    value                          shift and go to state 24
    variableAsignation             shift and go to state 33
    comparingValue                 shift and go to state 35

state 133

    (59) anonymousFunction -> FUNCTION LPAREN arguments RPAREN . LCURLY cuerpo RCURLY

    LCURLY          shift and go to state 155


state 134

    (57) arguments -> ID COMMA . arguments
    (56) arguments -> . ID
    (57) arguments -> . ID COMMA arguments

    ID              shift and go to state 104

    arguments                      shift and go to state 156

state 135

    (60) arrowFunction -> FN LPAREN ID RPAREN . FNARROW arrowBody SEMICOLON

    FNARROW         shift and go to state 157


state 136

    (67) values -> values COMMA value .

    SEMICOLON       reduce using rule 67 (values -> values COMMA value .)
    COMMA           reduce using rule 67 (values -> values COMMA value .)
    RPAREN          reduce using rule 67 (values -> values COMMA value .)
    RSQUARE         reduce using rule 67 (values -> values COMMA value .)


state 137

    (64) print -> PRINT LPAREN values RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 158


state 138

    (29) if_elseStatement -> IF LPAREN logicalCondition RPAREN LCURLY . ifStatementBody RCURLY ELSE ifStatementBody
    (30) if_elseStatement -> IF LPAREN logicalCondition RPAREN LCURLY . ifStatementBody
    (31) ifStatementBody -> . cuerpo
    (32) ifStatementBody -> . cuerpo CONTINUE SEMICOLON
    (33) ifStatementBody -> . ifStatementBody cuerpo
    (3) cuerpo -> . arithmeticExpression
    (4) cuerpo -> . if_elseStatement
    (5) cuerpo -> . forStatement
    (6) cuerpo -> . switchStatement
    (7) cuerpo -> . arrayAsignation
    (8) cuerpo -> . queueDeclaration
    (9) cuerpo -> . queueEnqueue
    (10) cuerpo -> . queueDequeue
    (11) cuerpo -> . defineFunction
    (12) cuerpo -> . anonymousFunction
    (13) cuerpo -> . arrowFunction
    (14) cuerpo -> . echo
    (15) cuerpo -> . fgets
    (16) cuerpo -> . stackDeclaration
    (17) cuerpo -> . stackPush
    (18) cuerpo -> . stackPop
    (19) cuerpo -> . line
    (20) cuerpo -> . print
    (21) cuerpo -> . logicalCondition
    (22) cuerpo -> . OPEN_TAG
    (23) cuerpo -> . CLOSE_TAG
    (69) arithmeticExpression -> . value
    (70) arithmeticExpression -> . arithmeticExpression arithmeticOperator arithmeticExpression
    (71) arithmeticExpression -> . LPAREN arithmeticExpression RPAREN
    (29) if_elseStatement -> . IF LPAREN logicalCondition RPAREN LCURLY ifStatementBody RCURLY ELSE ifStatementBody
    (30) if_elseStatement -> . IF LPAREN logicalCondition RPAREN LCURLY ifStatementBody
    (34) forStatement -> . FOR LPAREN forStatementCondition RPAREN LCURLY forStatementBody RCURLY
    (24) switchStatement -> . SWITCH LPAREN value RPAREN LCURLY switchCases switchDefault RCURLY
    (40) arrayAsignation -> . ID EQUAL arrayDeclaration SEMICOLON
    (51) queueDeclaration -> . ID EQUAL NEW QUEUE SEMICOLON
    (52) queueEnqueue -> . ID OBJOP PUSH LPAREN value RPAREN SEMICOLON
    (53) queueDequeue -> . ID OBJOP POP SEMICOLON
    (54) defineFunction -> . FUNCTION ID LPAREN arguments RPAREN LCURLY cuerpo RCURLY
    (55) defineFunction -> . FUNCTION ID LPAREN RPAREN LCURLY cuerpo RCURLY
    (58) anonymousFunction -> . FUNCTION LPAREN RPAREN LCURLY cuerpo RCURLY
    (59) anonymousFunction -> . FUNCTION LPAREN arguments RPAREN LCURLY cuerpo RCURLY
    (60) arrowFunction -> . FN LPAREN ID RPAREN FNARROW arrowBody SEMICOLON
    (63) echo -> . ECHO values SEMICOLON
    (68) fgets -> . ID EQUAL FGETS LPAREN STDIN RPAREN SEMICOLON
    (48) stackDeclaration -> . ID EQUAL NEW STACK SEMICOLON
    (49) stackPush -> . ID OBJOP PUSH LPAREN value RPAREN SEMICOLON
    (50) stackPop -> . ID OBJOP POP SEMICOLON
    (84) line -> . variableAsignation SEMICOLON
    (64) print -> . PRINT LPAREN values RPAREN SEMICOLON
    (65) print -> . PRINT value SEMICOLON
    (95) logicalCondition -> . comparingValue
    (96) logicalCondition -> . comparingValue conditionOperator comparingValue
    (97) logicalCondition -> . LPAREN logicalCondition RPAREN
    (72) value -> . ID
    (73) value -> . INTEGER
    (74) value -> . FLOAT
    (75) value -> . STRING
    (76) value -> . BOOL
    (77) value -> . NULL
    (85) variableAsignation -> . ID EQUAL value
    (86) variableAsignation -> . ID EQUAL arithmeticExpression
    (94) comparingValue -> . value comparingSign value

    OPEN_TAG        shift and go to state 22
    CLOSE_TAG       shift and go to state 23
    LPAREN          shift and go to state 25
    IF              shift and go to state 26
    FOR             shift and go to state 27
    SWITCH          shift and go to state 28
    ID              shift and go to state 29
    FUNCTION        shift and go to state 30
    FN              shift and go to state 31
    ECHO            shift and go to state 32
    PRINT           shift and go to state 34
    INTEGER         shift and go to state 36
    FLOAT           shift and go to state 37
    STRING          shift and go to state 38
    BOOL            shift and go to state 39
    NULL            shift and go to state 40

    logicalCondition               shift and go to state 21
    ifStatementBody                shift and go to state 159
    cuerpo                         shift and go to state 160
    arithmeticExpression           shift and go to state 3
    if_elseStatement               shift and go to state 4
    forStatement                   shift and go to state 5
    switchStatement                shift and go to state 6
    arrayAsignation                shift and go to state 7
    queueDeclaration               shift and go to state 8
    queueEnqueue                   shift and go to state 9
    queueDequeue                   shift and go to state 10
    defineFunction                 shift and go to state 11
    anonymousFunction              shift and go to state 12
    arrowFunction                  shift and go to state 13
    echo                           shift and go to state 14
    fgets                          shift and go to state 15
    stackDeclaration               shift and go to state 16
    stackPush                      shift and go to state 17
    stackPop                       shift and go to state 18
    line                           shift and go to state 19
    print                          shift and go to state 20
    value                          shift and go to state 24
    variableAsignation             shift and go to state 33
    comparingValue                 shift and go to state 35

state 139

    (34) forStatement -> FOR LPAREN forStatementCondition RPAREN LCURLY . forStatementBody RCURLY
    (38) forStatementBody -> . cuerpo
    (39) forStatementBody -> . forStatementBody cuerpo
    (3) cuerpo -> . arithmeticExpression
    (4) cuerpo -> . if_elseStatement
    (5) cuerpo -> . forStatement
    (6) cuerpo -> . switchStatement
    (7) cuerpo -> . arrayAsignation
    (8) cuerpo -> . queueDeclaration
    (9) cuerpo -> . queueEnqueue
    (10) cuerpo -> . queueDequeue
    (11) cuerpo -> . defineFunction
    (12) cuerpo -> . anonymousFunction
    (13) cuerpo -> . arrowFunction
    (14) cuerpo -> . echo
    (15) cuerpo -> . fgets
    (16) cuerpo -> . stackDeclaration
    (17) cuerpo -> . stackPush
    (18) cuerpo -> . stackPop
    (19) cuerpo -> . line
    (20) cuerpo -> . print
    (21) cuerpo -> . logicalCondition
    (22) cuerpo -> . OPEN_TAG
    (23) cuerpo -> . CLOSE_TAG
    (69) arithmeticExpression -> . value
    (70) arithmeticExpression -> . arithmeticExpression arithmeticOperator arithmeticExpression
    (71) arithmeticExpression -> . LPAREN arithmeticExpression RPAREN
    (29) if_elseStatement -> . IF LPAREN logicalCondition RPAREN LCURLY ifStatementBody RCURLY ELSE ifStatementBody
    (30) if_elseStatement -> . IF LPAREN logicalCondition RPAREN LCURLY ifStatementBody
    (34) forStatement -> . FOR LPAREN forStatementCondition RPAREN LCURLY forStatementBody RCURLY
    (24) switchStatement -> . SWITCH LPAREN value RPAREN LCURLY switchCases switchDefault RCURLY
    (40) arrayAsignation -> . ID EQUAL arrayDeclaration SEMICOLON
    (51) queueDeclaration -> . ID EQUAL NEW QUEUE SEMICOLON
    (52) queueEnqueue -> . ID OBJOP PUSH LPAREN value RPAREN SEMICOLON
    (53) queueDequeue -> . ID OBJOP POP SEMICOLON
    (54) defineFunction -> . FUNCTION ID LPAREN arguments RPAREN LCURLY cuerpo RCURLY
    (55) defineFunction -> . FUNCTION ID LPAREN RPAREN LCURLY cuerpo RCURLY
    (58) anonymousFunction -> . FUNCTION LPAREN RPAREN LCURLY cuerpo RCURLY
    (59) anonymousFunction -> . FUNCTION LPAREN arguments RPAREN LCURLY cuerpo RCURLY
    (60) arrowFunction -> . FN LPAREN ID RPAREN FNARROW arrowBody SEMICOLON
    (63) echo -> . ECHO values SEMICOLON
    (68) fgets -> . ID EQUAL FGETS LPAREN STDIN RPAREN SEMICOLON
    (48) stackDeclaration -> . ID EQUAL NEW STACK SEMICOLON
    (49) stackPush -> . ID OBJOP PUSH LPAREN value RPAREN SEMICOLON
    (50) stackPop -> . ID OBJOP POP SEMICOLON
    (84) line -> . variableAsignation SEMICOLON
    (64) print -> . PRINT LPAREN values RPAREN SEMICOLON
    (65) print -> . PRINT value SEMICOLON
    (95) logicalCondition -> . comparingValue
    (96) logicalCondition -> . comparingValue conditionOperator comparingValue
    (97) logicalCondition -> . LPAREN logicalCondition RPAREN
    (72) value -> . ID
    (73) value -> . INTEGER
    (74) value -> . FLOAT
    (75) value -> . STRING
    (76) value -> . BOOL
    (77) value -> . NULL
    (85) variableAsignation -> . ID EQUAL value
    (86) variableAsignation -> . ID EQUAL arithmeticExpression
    (94) comparingValue -> . value comparingSign value

    OPEN_TAG        shift and go to state 22
    CLOSE_TAG       shift and go to state 23
    LPAREN          shift and go to state 25
    IF              shift and go to state 26
    FOR             shift and go to state 27
    SWITCH          shift and go to state 28
    ID              shift and go to state 29
    FUNCTION        shift and go to state 30
    FN              shift and go to state 31
    ECHO            shift and go to state 32
    PRINT           shift and go to state 34
    INTEGER         shift and go to state 36
    FLOAT           shift and go to state 37
    STRING          shift and go to state 38
    BOOL            shift and go to state 39
    NULL            shift and go to state 40

    forStatementBody               shift and go to state 161
    cuerpo                         shift and go to state 162
    arithmeticExpression           shift and go to state 3
    if_elseStatement               shift and go to state 4
    forStatement                   shift and go to state 5
    switchStatement                shift and go to state 6
    arrayAsignation                shift and go to state 7
    queueDeclaration               shift and go to state 8
    queueEnqueue                   shift and go to state 9
    queueDequeue                   shift and go to state 10
    defineFunction                 shift and go to state 11
    anonymousFunction              shift and go to state 12
    arrowFunction                  shift and go to state 13
    echo                           shift and go to state 14
    fgets                          shift and go to state 15
    stackDeclaration               shift and go to state 16
    stackPush                      shift and go to state 17
    stackPop                       shift and go to state 18
    line                           shift and go to state 19
    print                          shift and go to state 20
    logicalCondition               shift and go to state 21
    value                          shift and go to state 24
    variableAsignation             shift and go to state 33
    comparingValue                 shift and go to state 35

state 140

    (36) forStatementCondition -> variableAsignation SEMICOLON SEMICOLON . variableAsignation
    (85) variableAsignation -> . ID EQUAL value
    (86) variableAsignation -> . ID EQUAL arithmeticExpression

    ID              shift and go to state 89

    variableAsignation             shift and go to state 163

state 141

    (37) forStatementCondition -> variableAsignation SEMICOLON comparingValue . SEMICOLON variableAsignation

    SEMICOLON       shift and go to state 164


state 142

    (24) switchStatement -> SWITCH LPAREN value RPAREN LCURLY . switchCases switchDefault RCURLY
    (27) switchCases -> . switchCase
    (28) switchCases -> . switchCases switchCase
    (26) switchCase -> . CASE value COLON programa BREAK SEMICOLON

    CASE            shift and go to state 167

    switchCases                    shift and go to state 165
    switchCase                     shift and go to state 166

state 143

    (51) queueDeclaration -> ID EQUAL NEW QUEUE SEMICOLON .

    OPEN_TAG        reduce using rule 51 (queueDeclaration -> ID EQUAL NEW QUEUE SEMICOLON .)
    CLOSE_TAG       reduce using rule 51 (queueDeclaration -> ID EQUAL NEW QUEUE SEMICOLON .)
    LPAREN          reduce using rule 51 (queueDeclaration -> ID EQUAL NEW QUEUE SEMICOLON .)
    IF              reduce using rule 51 (queueDeclaration -> ID EQUAL NEW QUEUE SEMICOLON .)
    FOR             reduce using rule 51 (queueDeclaration -> ID EQUAL NEW QUEUE SEMICOLON .)
    SWITCH          reduce using rule 51 (queueDeclaration -> ID EQUAL NEW QUEUE SEMICOLON .)
    ID              reduce using rule 51 (queueDeclaration -> ID EQUAL NEW QUEUE SEMICOLON .)
    FUNCTION        reduce using rule 51 (queueDeclaration -> ID EQUAL NEW QUEUE SEMICOLON .)
    FN              reduce using rule 51 (queueDeclaration -> ID EQUAL NEW QUEUE SEMICOLON .)
    ECHO            reduce using rule 51 (queueDeclaration -> ID EQUAL NEW QUEUE SEMICOLON .)
    PRINT           reduce using rule 51 (queueDeclaration -> ID EQUAL NEW QUEUE SEMICOLON .)
    INTEGER         reduce using rule 51 (queueDeclaration -> ID EQUAL NEW QUEUE SEMICOLON .)
    FLOAT           reduce using rule 51 (queueDeclaration -> ID EQUAL NEW QUEUE SEMICOLON .)
    STRING          reduce using rule 51 (queueDeclaration -> ID EQUAL NEW QUEUE SEMICOLON .)
    BOOL            reduce using rule 51 (queueDeclaration -> ID EQUAL NEW QUEUE SEMICOLON .)
    NULL            reduce using rule 51 (queueDeclaration -> ID EQUAL NEW QUEUE SEMICOLON .)
    $end            reduce using rule 51 (queueDeclaration -> ID EQUAL NEW QUEUE SEMICOLON .)
    RCURLY          reduce using rule 51 (queueDeclaration -> ID EQUAL NEW QUEUE SEMICOLON .)
    CONTINUE        reduce using rule 51 (queueDeclaration -> ID EQUAL NEW QUEUE SEMICOLON .)
    SEMICOLON       reduce using rule 51 (queueDeclaration -> ID EQUAL NEW QUEUE SEMICOLON .)
    BREAK           reduce using rule 51 (queueDeclaration -> ID EQUAL NEW QUEUE SEMICOLON .)


state 144

    (48) stackDeclaration -> ID EQUAL NEW STACK SEMICOLON .

    OPEN_TAG        reduce using rule 48 (stackDeclaration -> ID EQUAL NEW STACK SEMICOLON .)
    CLOSE_TAG       reduce using rule 48 (stackDeclaration -> ID EQUAL NEW STACK SEMICOLON .)
    LPAREN          reduce using rule 48 (stackDeclaration -> ID EQUAL NEW STACK SEMICOLON .)
    IF              reduce using rule 48 (stackDeclaration -> ID EQUAL NEW STACK SEMICOLON .)
    FOR             reduce using rule 48 (stackDeclaration -> ID EQUAL NEW STACK SEMICOLON .)
    SWITCH          reduce using rule 48 (stackDeclaration -> ID EQUAL NEW STACK SEMICOLON .)
    ID              reduce using rule 48 (stackDeclaration -> ID EQUAL NEW STACK SEMICOLON .)
    FUNCTION        reduce using rule 48 (stackDeclaration -> ID EQUAL NEW STACK SEMICOLON .)
    FN              reduce using rule 48 (stackDeclaration -> ID EQUAL NEW STACK SEMICOLON .)
    ECHO            reduce using rule 48 (stackDeclaration -> ID EQUAL NEW STACK SEMICOLON .)
    PRINT           reduce using rule 48 (stackDeclaration -> ID EQUAL NEW STACK SEMICOLON .)
    INTEGER         reduce using rule 48 (stackDeclaration -> ID EQUAL NEW STACK SEMICOLON .)
    FLOAT           reduce using rule 48 (stackDeclaration -> ID EQUAL NEW STACK SEMICOLON .)
    STRING          reduce using rule 48 (stackDeclaration -> ID EQUAL NEW STACK SEMICOLON .)
    BOOL            reduce using rule 48 (stackDeclaration -> ID EQUAL NEW STACK SEMICOLON .)
    NULL            reduce using rule 48 (stackDeclaration -> ID EQUAL NEW STACK SEMICOLON .)
    $end            reduce using rule 48 (stackDeclaration -> ID EQUAL NEW STACK SEMICOLON .)
    RCURLY          reduce using rule 48 (stackDeclaration -> ID EQUAL NEW STACK SEMICOLON .)
    CONTINUE        reduce using rule 48 (stackDeclaration -> ID EQUAL NEW STACK SEMICOLON .)
    SEMICOLON       reduce using rule 48 (stackDeclaration -> ID EQUAL NEW STACK SEMICOLON .)
    BREAK           reduce using rule 48 (stackDeclaration -> ID EQUAL NEW STACK SEMICOLON .)


state 145

    (68) fgets -> ID EQUAL FGETS LPAREN STDIN . RPAREN SEMICOLON

    RPAREN          shift and go to state 168


state 146

    (41) arrayDeclaration -> ARRAY arraysValues RPAREN .

    SEMICOLON       reduce using rule 41 (arrayDeclaration -> ARRAY arraysValues RPAREN .)


state 147

    (45) arraysValues -> arraysValues COMMA . arrayValue
    (46) arrayValue -> . ARRAY values RPAREN
    (47) arrayValue -> . LSQUARE values RSQUARE

    ARRAY           shift and go to state 121
    LSQUARE         shift and go to state 125

    arrayValue                     shift and go to state 169

state 148

    (46) arrayValue -> ARRAY values RPAREN .

    SEMICOLON       reduce using rule 46 (arrayValue -> ARRAY values RPAREN .)
    RPAREN          reduce using rule 46 (arrayValue -> ARRAY values RPAREN .)
    COMMA           reduce using rule 46 (arrayValue -> ARRAY values RPAREN .)
    RSQUARE         reduce using rule 46 (arrayValue -> ARRAY values RPAREN .)


state 149

    (42) arrayDeclaration -> LSQUARE arraysValues RSQUARE .

    SEMICOLON       reduce using rule 42 (arrayDeclaration -> LSQUARE arraysValues RSQUARE .)


state 150

    (47) arrayValue -> LSQUARE values RSQUARE .

    SEMICOLON       reduce using rule 47 (arrayValue -> LSQUARE values RSQUARE .)
    RPAREN          reduce using rule 47 (arrayValue -> LSQUARE values RSQUARE .)
    COMMA           reduce using rule 47 (arrayValue -> LSQUARE values RSQUARE .)
    RSQUARE         reduce using rule 47 (arrayValue -> LSQUARE values RSQUARE .)


state 151

    (52) queueEnqueue -> ID OBJOP PUSH LPAREN value . RPAREN SEMICOLON
    (49) stackPush -> ID OBJOP PUSH LPAREN value . RPAREN SEMICOLON

    RPAREN          shift and go to state 170


state 152

    (54) defineFunction -> FUNCTION ID LPAREN arguments RPAREN . LCURLY cuerpo RCURLY

    LCURLY          shift and go to state 171


state 153

    (55) defineFunction -> FUNCTION ID LPAREN RPAREN LCURLY . cuerpo RCURLY
    (3) cuerpo -> . arithmeticExpression
    (4) cuerpo -> . if_elseStatement
    (5) cuerpo -> . forStatement
    (6) cuerpo -> . switchStatement
    (7) cuerpo -> . arrayAsignation
    (8) cuerpo -> . queueDeclaration
    (9) cuerpo -> . queueEnqueue
    (10) cuerpo -> . queueDequeue
    (11) cuerpo -> . defineFunction
    (12) cuerpo -> . anonymousFunction
    (13) cuerpo -> . arrowFunction
    (14) cuerpo -> . echo
    (15) cuerpo -> . fgets
    (16) cuerpo -> . stackDeclaration
    (17) cuerpo -> . stackPush
    (18) cuerpo -> . stackPop
    (19) cuerpo -> . line
    (20) cuerpo -> . print
    (21) cuerpo -> . logicalCondition
    (22) cuerpo -> . OPEN_TAG
    (23) cuerpo -> . CLOSE_TAG
    (69) arithmeticExpression -> . value
    (70) arithmeticExpression -> . arithmeticExpression arithmeticOperator arithmeticExpression
    (71) arithmeticExpression -> . LPAREN arithmeticExpression RPAREN
    (29) if_elseStatement -> . IF LPAREN logicalCondition RPAREN LCURLY ifStatementBody RCURLY ELSE ifStatementBody
    (30) if_elseStatement -> . IF LPAREN logicalCondition RPAREN LCURLY ifStatementBody
    (34) forStatement -> . FOR LPAREN forStatementCondition RPAREN LCURLY forStatementBody RCURLY
    (24) switchStatement -> . SWITCH LPAREN value RPAREN LCURLY switchCases switchDefault RCURLY
    (40) arrayAsignation -> . ID EQUAL arrayDeclaration SEMICOLON
    (51) queueDeclaration -> . ID EQUAL NEW QUEUE SEMICOLON
    (52) queueEnqueue -> . ID OBJOP PUSH LPAREN value RPAREN SEMICOLON
    (53) queueDequeue -> . ID OBJOP POP SEMICOLON
    (54) defineFunction -> . FUNCTION ID LPAREN arguments RPAREN LCURLY cuerpo RCURLY
    (55) defineFunction -> . FUNCTION ID LPAREN RPAREN LCURLY cuerpo RCURLY
    (58) anonymousFunction -> . FUNCTION LPAREN RPAREN LCURLY cuerpo RCURLY
    (59) anonymousFunction -> . FUNCTION LPAREN arguments RPAREN LCURLY cuerpo RCURLY
    (60) arrowFunction -> . FN LPAREN ID RPAREN FNARROW arrowBody SEMICOLON
    (63) echo -> . ECHO values SEMICOLON
    (68) fgets -> . ID EQUAL FGETS LPAREN STDIN RPAREN SEMICOLON
    (48) stackDeclaration -> . ID EQUAL NEW STACK SEMICOLON
    (49) stackPush -> . ID OBJOP PUSH LPAREN value RPAREN SEMICOLON
    (50) stackPop -> . ID OBJOP POP SEMICOLON
    (84) line -> . variableAsignation SEMICOLON
    (64) print -> . PRINT LPAREN values RPAREN SEMICOLON
    (65) print -> . PRINT value SEMICOLON
    (95) logicalCondition -> . comparingValue
    (96) logicalCondition -> . comparingValue conditionOperator comparingValue
    (97) logicalCondition -> . LPAREN logicalCondition RPAREN
    (72) value -> . ID
    (73) value -> . INTEGER
    (74) value -> . FLOAT
    (75) value -> . STRING
    (76) value -> . BOOL
    (77) value -> . NULL
    (85) variableAsignation -> . ID EQUAL value
    (86) variableAsignation -> . ID EQUAL arithmeticExpression
    (94) comparingValue -> . value comparingSign value

    OPEN_TAG        shift and go to state 22
    CLOSE_TAG       shift and go to state 23
    LPAREN          shift and go to state 25
    IF              shift and go to state 26
    FOR             shift and go to state 27
    SWITCH          shift and go to state 28
    ID              shift and go to state 29
    FUNCTION        shift and go to state 30
    FN              shift and go to state 31
    ECHO            shift and go to state 32
    PRINT           shift and go to state 34
    INTEGER         shift and go to state 36
    FLOAT           shift and go to state 37
    STRING          shift and go to state 38
    BOOL            shift and go to state 39
    NULL            shift and go to state 40

    cuerpo                         shift and go to state 172
    arithmeticExpression           shift and go to state 3
    if_elseStatement               shift and go to state 4
    forStatement                   shift and go to state 5
    switchStatement                shift and go to state 6
    arrayAsignation                shift and go to state 7
    queueDeclaration               shift and go to state 8
    queueEnqueue                   shift and go to state 9
    queueDequeue                   shift and go to state 10
    defineFunction                 shift and go to state 11
    anonymousFunction              shift and go to state 12
    arrowFunction                  shift and go to state 13
    echo                           shift and go to state 14
    fgets                          shift and go to state 15
    stackDeclaration               shift and go to state 16
    stackPush                      shift and go to state 17
    stackPop                       shift and go to state 18
    line                           shift and go to state 19
    print                          shift and go to state 20
    logicalCondition               shift and go to state 21
    value                          shift and go to state 24
    variableAsignation             shift and go to state 33
    comparingValue                 shift and go to state 35

state 154

    (58) anonymousFunction -> FUNCTION LPAREN RPAREN LCURLY cuerpo . RCURLY

    RCURLY          shift and go to state 173


state 155

    (59) anonymousFunction -> FUNCTION LPAREN arguments RPAREN LCURLY . cuerpo RCURLY
    (3) cuerpo -> . arithmeticExpression
    (4) cuerpo -> . if_elseStatement
    (5) cuerpo -> . forStatement
    (6) cuerpo -> . switchStatement
    (7) cuerpo -> . arrayAsignation
    (8) cuerpo -> . queueDeclaration
    (9) cuerpo -> . queueEnqueue
    (10) cuerpo -> . queueDequeue
    (11) cuerpo -> . defineFunction
    (12) cuerpo -> . anonymousFunction
    (13) cuerpo -> . arrowFunction
    (14) cuerpo -> . echo
    (15) cuerpo -> . fgets
    (16) cuerpo -> . stackDeclaration
    (17) cuerpo -> . stackPush
    (18) cuerpo -> . stackPop
    (19) cuerpo -> . line
    (20) cuerpo -> . print
    (21) cuerpo -> . logicalCondition
    (22) cuerpo -> . OPEN_TAG
    (23) cuerpo -> . CLOSE_TAG
    (69) arithmeticExpression -> . value
    (70) arithmeticExpression -> . arithmeticExpression arithmeticOperator arithmeticExpression
    (71) arithmeticExpression -> . LPAREN arithmeticExpression RPAREN
    (29) if_elseStatement -> . IF LPAREN logicalCondition RPAREN LCURLY ifStatementBody RCURLY ELSE ifStatementBody
    (30) if_elseStatement -> . IF LPAREN logicalCondition RPAREN LCURLY ifStatementBody
    (34) forStatement -> . FOR LPAREN forStatementCondition RPAREN LCURLY forStatementBody RCURLY
    (24) switchStatement -> . SWITCH LPAREN value RPAREN LCURLY switchCases switchDefault RCURLY
    (40) arrayAsignation -> . ID EQUAL arrayDeclaration SEMICOLON
    (51) queueDeclaration -> . ID EQUAL NEW QUEUE SEMICOLON
    (52) queueEnqueue -> . ID OBJOP PUSH LPAREN value RPAREN SEMICOLON
    (53) queueDequeue -> . ID OBJOP POP SEMICOLON
    (54) defineFunction -> . FUNCTION ID LPAREN arguments RPAREN LCURLY cuerpo RCURLY
    (55) defineFunction -> . FUNCTION ID LPAREN RPAREN LCURLY cuerpo RCURLY
    (58) anonymousFunction -> . FUNCTION LPAREN RPAREN LCURLY cuerpo RCURLY
    (59) anonymousFunction -> . FUNCTION LPAREN arguments RPAREN LCURLY cuerpo RCURLY
    (60) arrowFunction -> . FN LPAREN ID RPAREN FNARROW arrowBody SEMICOLON
    (63) echo -> . ECHO values SEMICOLON
    (68) fgets -> . ID EQUAL FGETS LPAREN STDIN RPAREN SEMICOLON
    (48) stackDeclaration -> . ID EQUAL NEW STACK SEMICOLON
    (49) stackPush -> . ID OBJOP PUSH LPAREN value RPAREN SEMICOLON
    (50) stackPop -> . ID OBJOP POP SEMICOLON
    (84) line -> . variableAsignation SEMICOLON
    (64) print -> . PRINT LPAREN values RPAREN SEMICOLON
    (65) print -> . PRINT value SEMICOLON
    (95) logicalCondition -> . comparingValue
    (96) logicalCondition -> . comparingValue conditionOperator comparingValue
    (97) logicalCondition -> . LPAREN logicalCondition RPAREN
    (72) value -> . ID
    (73) value -> . INTEGER
    (74) value -> . FLOAT
    (75) value -> . STRING
    (76) value -> . BOOL
    (77) value -> . NULL
    (85) variableAsignation -> . ID EQUAL value
    (86) variableAsignation -> . ID EQUAL arithmeticExpression
    (94) comparingValue -> . value comparingSign value

    OPEN_TAG        shift and go to state 22
    CLOSE_TAG       shift and go to state 23
    LPAREN          shift and go to state 25
    IF              shift and go to state 26
    FOR             shift and go to state 27
    SWITCH          shift and go to state 28
    ID              shift and go to state 29
    FUNCTION        shift and go to state 30
    FN              shift and go to state 31
    ECHO            shift and go to state 32
    PRINT           shift and go to state 34
    INTEGER         shift and go to state 36
    FLOAT           shift and go to state 37
    STRING          shift and go to state 38
    BOOL            shift and go to state 39
    NULL            shift and go to state 40

    cuerpo                         shift and go to state 174
    arithmeticExpression           shift and go to state 3
    if_elseStatement               shift and go to state 4
    forStatement                   shift and go to state 5
    switchStatement                shift and go to state 6
    arrayAsignation                shift and go to state 7
    queueDeclaration               shift and go to state 8
    queueEnqueue                   shift and go to state 9
    queueDequeue                   shift and go to state 10
    defineFunction                 shift and go to state 11
    anonymousFunction              shift and go to state 12
    arrowFunction                  shift and go to state 13
    echo                           shift and go to state 14
    fgets                          shift and go to state 15
    stackDeclaration               shift and go to state 16
    stackPush                      shift and go to state 17
    stackPop                       shift and go to state 18
    line                           shift and go to state 19
    print                          shift and go to state 20
    logicalCondition               shift and go to state 21
    value                          shift and go to state 24
    variableAsignation             shift and go to state 33
    comparingValue                 shift and go to state 35

state 156

    (57) arguments -> ID COMMA arguments .

    RPAREN          reduce using rule 57 (arguments -> ID COMMA arguments .)


state 157

    (60) arrowFunction -> FN LPAREN ID RPAREN FNARROW . arrowBody SEMICOLON
    (61) arrowBody -> . FN LPAREN ID RPAREN FNARROW arrowBody
    (62) arrowBody -> . cuerpo
    (3) cuerpo -> . arithmeticExpression
    (4) cuerpo -> . if_elseStatement
    (5) cuerpo -> . forStatement
    (6) cuerpo -> . switchStatement
    (7) cuerpo -> . arrayAsignation
    (8) cuerpo -> . queueDeclaration
    (9) cuerpo -> . queueEnqueue
    (10) cuerpo -> . queueDequeue
    (11) cuerpo -> . defineFunction
    (12) cuerpo -> . anonymousFunction
    (13) cuerpo -> . arrowFunction
    (14) cuerpo -> . echo
    (15) cuerpo -> . fgets
    (16) cuerpo -> . stackDeclaration
    (17) cuerpo -> . stackPush
    (18) cuerpo -> . stackPop
    (19) cuerpo -> . line
    (20) cuerpo -> . print
    (21) cuerpo -> . logicalCondition
    (22) cuerpo -> . OPEN_TAG
    (23) cuerpo -> . CLOSE_TAG
    (69) arithmeticExpression -> . value
    (70) arithmeticExpression -> . arithmeticExpression arithmeticOperator arithmeticExpression
    (71) arithmeticExpression -> . LPAREN arithmeticExpression RPAREN
    (29) if_elseStatement -> . IF LPAREN logicalCondition RPAREN LCURLY ifStatementBody RCURLY ELSE ifStatementBody
    (30) if_elseStatement -> . IF LPAREN logicalCondition RPAREN LCURLY ifStatementBody
    (34) forStatement -> . FOR LPAREN forStatementCondition RPAREN LCURLY forStatementBody RCURLY
    (24) switchStatement -> . SWITCH LPAREN value RPAREN LCURLY switchCases switchDefault RCURLY
    (40) arrayAsignation -> . ID EQUAL arrayDeclaration SEMICOLON
    (51) queueDeclaration -> . ID EQUAL NEW QUEUE SEMICOLON
    (52) queueEnqueue -> . ID OBJOP PUSH LPAREN value RPAREN SEMICOLON
    (53) queueDequeue -> . ID OBJOP POP SEMICOLON
    (54) defineFunction -> . FUNCTION ID LPAREN arguments RPAREN LCURLY cuerpo RCURLY
    (55) defineFunction -> . FUNCTION ID LPAREN RPAREN LCURLY cuerpo RCURLY
    (58) anonymousFunction -> . FUNCTION LPAREN RPAREN LCURLY cuerpo RCURLY
    (59) anonymousFunction -> . FUNCTION LPAREN arguments RPAREN LCURLY cuerpo RCURLY
    (60) arrowFunction -> . FN LPAREN ID RPAREN FNARROW arrowBody SEMICOLON
    (63) echo -> . ECHO values SEMICOLON
    (68) fgets -> . ID EQUAL FGETS LPAREN STDIN RPAREN SEMICOLON
    (48) stackDeclaration -> . ID EQUAL NEW STACK SEMICOLON
    (49) stackPush -> . ID OBJOP PUSH LPAREN value RPAREN SEMICOLON
    (50) stackPop -> . ID OBJOP POP SEMICOLON
    (84) line -> . variableAsignation SEMICOLON
    (64) print -> . PRINT LPAREN values RPAREN SEMICOLON
    (65) print -> . PRINT value SEMICOLON
    (95) logicalCondition -> . comparingValue
    (96) logicalCondition -> . comparingValue conditionOperator comparingValue
    (97) logicalCondition -> . LPAREN logicalCondition RPAREN
    (72) value -> . ID
    (73) value -> . INTEGER
    (74) value -> . FLOAT
    (75) value -> . STRING
    (76) value -> . BOOL
    (77) value -> . NULL
    (85) variableAsignation -> . ID EQUAL value
    (86) variableAsignation -> . ID EQUAL arithmeticExpression
    (94) comparingValue -> . value comparingSign value

    FN              shift and go to state 175
    OPEN_TAG        shift and go to state 22
    CLOSE_TAG       shift and go to state 23
    LPAREN          shift and go to state 25
    IF              shift and go to state 26
    FOR             shift and go to state 27
    SWITCH          shift and go to state 28
    ID              shift and go to state 29
    FUNCTION        shift and go to state 30
    ECHO            shift and go to state 32
    PRINT           shift and go to state 34
    INTEGER         shift and go to state 36
    FLOAT           shift and go to state 37
    STRING          shift and go to state 38
    BOOL            shift and go to state 39
    NULL            shift and go to state 40

    arrowBody                      shift and go to state 176
    cuerpo                         shift and go to state 177
    arithmeticExpression           shift and go to state 3
    if_elseStatement               shift and go to state 4
    forStatement                   shift and go to state 5
    switchStatement                shift and go to state 6
    arrayAsignation                shift and go to state 7
    queueDeclaration               shift and go to state 8
    queueEnqueue                   shift and go to state 9
    queueDequeue                   shift and go to state 10
    defineFunction                 shift and go to state 11
    anonymousFunction              shift and go to state 12
    arrowFunction                  shift and go to state 13
    echo                           shift and go to state 14
    fgets                          shift and go to state 15
    stackDeclaration               shift and go to state 16
    stackPush                      shift and go to state 17
    stackPop                       shift and go to state 18
    line                           shift and go to state 19
    print                          shift and go to state 20
    logicalCondition               shift and go to state 21
    value                          shift and go to state 24
    variableAsignation             shift and go to state 33
    comparingValue                 shift and go to state 35

state 158

    (64) print -> PRINT LPAREN values RPAREN SEMICOLON .

    OPEN_TAG        reduce using rule 64 (print -> PRINT LPAREN values RPAREN SEMICOLON .)
    CLOSE_TAG       reduce using rule 64 (print -> PRINT LPAREN values RPAREN SEMICOLON .)
    LPAREN          reduce using rule 64 (print -> PRINT LPAREN values RPAREN SEMICOLON .)
    IF              reduce using rule 64 (print -> PRINT LPAREN values RPAREN SEMICOLON .)
    FOR             reduce using rule 64 (print -> PRINT LPAREN values RPAREN SEMICOLON .)
    SWITCH          reduce using rule 64 (print -> PRINT LPAREN values RPAREN SEMICOLON .)
    ID              reduce using rule 64 (print -> PRINT LPAREN values RPAREN SEMICOLON .)
    FUNCTION        reduce using rule 64 (print -> PRINT LPAREN values RPAREN SEMICOLON .)
    FN              reduce using rule 64 (print -> PRINT LPAREN values RPAREN SEMICOLON .)
    ECHO            reduce using rule 64 (print -> PRINT LPAREN values RPAREN SEMICOLON .)
    PRINT           reduce using rule 64 (print -> PRINT LPAREN values RPAREN SEMICOLON .)
    INTEGER         reduce using rule 64 (print -> PRINT LPAREN values RPAREN SEMICOLON .)
    FLOAT           reduce using rule 64 (print -> PRINT LPAREN values RPAREN SEMICOLON .)
    STRING          reduce using rule 64 (print -> PRINT LPAREN values RPAREN SEMICOLON .)
    BOOL            reduce using rule 64 (print -> PRINT LPAREN values RPAREN SEMICOLON .)
    NULL            reduce using rule 64 (print -> PRINT LPAREN values RPAREN SEMICOLON .)
    $end            reduce using rule 64 (print -> PRINT LPAREN values RPAREN SEMICOLON .)
    RCURLY          reduce using rule 64 (print -> PRINT LPAREN values RPAREN SEMICOLON .)
    CONTINUE        reduce using rule 64 (print -> PRINT LPAREN values RPAREN SEMICOLON .)
    SEMICOLON       reduce using rule 64 (print -> PRINT LPAREN values RPAREN SEMICOLON .)
    BREAK           reduce using rule 64 (print -> PRINT LPAREN values RPAREN SEMICOLON .)


state 159

    (29) if_elseStatement -> IF LPAREN logicalCondition RPAREN LCURLY ifStatementBody . RCURLY ELSE ifStatementBody
    (30) if_elseStatement -> IF LPAREN logicalCondition RPAREN LCURLY ifStatementBody .
    (33) ifStatementBody -> ifStatementBody . cuerpo
    (3) cuerpo -> . arithmeticExpression
    (4) cuerpo -> . if_elseStatement
    (5) cuerpo -> . forStatement
    (6) cuerpo -> . switchStatement
    (7) cuerpo -> . arrayAsignation
    (8) cuerpo -> . queueDeclaration
    (9) cuerpo -> . queueEnqueue
    (10) cuerpo -> . queueDequeue
    (11) cuerpo -> . defineFunction
    (12) cuerpo -> . anonymousFunction
    (13) cuerpo -> . arrowFunction
    (14) cuerpo -> . echo
    (15) cuerpo -> . fgets
    (16) cuerpo -> . stackDeclaration
    (17) cuerpo -> . stackPush
    (18) cuerpo -> . stackPop
    (19) cuerpo -> . line
    (20) cuerpo -> . print
    (21) cuerpo -> . logicalCondition
    (22) cuerpo -> . OPEN_TAG
    (23) cuerpo -> . CLOSE_TAG
    (69) arithmeticExpression -> . value
    (70) arithmeticExpression -> . arithmeticExpression arithmeticOperator arithmeticExpression
    (71) arithmeticExpression -> . LPAREN arithmeticExpression RPAREN
    (29) if_elseStatement -> . IF LPAREN logicalCondition RPAREN LCURLY ifStatementBody RCURLY ELSE ifStatementBody
    (30) if_elseStatement -> . IF LPAREN logicalCondition RPAREN LCURLY ifStatementBody
    (34) forStatement -> . FOR LPAREN forStatementCondition RPAREN LCURLY forStatementBody RCURLY
    (24) switchStatement -> . SWITCH LPAREN value RPAREN LCURLY switchCases switchDefault RCURLY
    (40) arrayAsignation -> . ID EQUAL arrayDeclaration SEMICOLON
    (51) queueDeclaration -> . ID EQUAL NEW QUEUE SEMICOLON
    (52) queueEnqueue -> . ID OBJOP PUSH LPAREN value RPAREN SEMICOLON
    (53) queueDequeue -> . ID OBJOP POP SEMICOLON
    (54) defineFunction -> . FUNCTION ID LPAREN arguments RPAREN LCURLY cuerpo RCURLY
    (55) defineFunction -> . FUNCTION ID LPAREN RPAREN LCURLY cuerpo RCURLY
    (58) anonymousFunction -> . FUNCTION LPAREN RPAREN LCURLY cuerpo RCURLY
    (59) anonymousFunction -> . FUNCTION LPAREN arguments RPAREN LCURLY cuerpo RCURLY
    (60) arrowFunction -> . FN LPAREN ID RPAREN FNARROW arrowBody SEMICOLON
    (63) echo -> . ECHO values SEMICOLON
    (68) fgets -> . ID EQUAL FGETS LPAREN STDIN RPAREN SEMICOLON
    (48) stackDeclaration -> . ID EQUAL NEW STACK SEMICOLON
    (49) stackPush -> . ID OBJOP PUSH LPAREN value RPAREN SEMICOLON
    (50) stackPop -> . ID OBJOP POP SEMICOLON
    (84) line -> . variableAsignation SEMICOLON
    (64) print -> . PRINT LPAREN values RPAREN SEMICOLON
    (65) print -> . PRINT value SEMICOLON
    (95) logicalCondition -> . comparingValue
    (96) logicalCondition -> . comparingValue conditionOperator comparingValue
    (97) logicalCondition -> . LPAREN logicalCondition RPAREN
    (72) value -> . ID
    (73) value -> . INTEGER
    (74) value -> . FLOAT
    (75) value -> . STRING
    (76) value -> . BOOL
    (77) value -> . NULL
    (85) variableAsignation -> . ID EQUAL value
    (86) variableAsignation -> . ID EQUAL arithmeticExpression
    (94) comparingValue -> . value comparingSign value

  ! shift/reduce conflict for RCURLY resolved as shift
  ! shift/reduce conflict for OPEN_TAG resolved as shift
  ! shift/reduce conflict for CLOSE_TAG resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for SWITCH resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for FUNCTION resolved as shift
  ! shift/reduce conflict for FN resolved as shift
  ! shift/reduce conflict for ECHO resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for BOOL resolved as shift
  ! shift/reduce conflict for NULL resolved as shift
    RCURLY          shift and go to state 178
    $end            reduce using rule 30 (if_elseStatement -> IF LPAREN logicalCondition RPAREN LCURLY ifStatementBody .)
    CONTINUE        reduce using rule 30 (if_elseStatement -> IF LPAREN logicalCondition RPAREN LCURLY ifStatementBody .)
    SEMICOLON       reduce using rule 30 (if_elseStatement -> IF LPAREN logicalCondition RPAREN LCURLY ifStatementBody .)
    BREAK           reduce using rule 30 (if_elseStatement -> IF LPAREN logicalCondition RPAREN LCURLY ifStatementBody .)
    OPEN_TAG        shift and go to state 22
    CLOSE_TAG       shift and go to state 23
    LPAREN          shift and go to state 25
    IF              shift and go to state 26
    FOR             shift and go to state 27
    SWITCH          shift and go to state 28
    ID              shift and go to state 29
    FUNCTION        shift and go to state 30
    FN              shift and go to state 31
    ECHO            shift and go to state 32
    PRINT           shift and go to state 34
    INTEGER         shift and go to state 36
    FLOAT           shift and go to state 37
    STRING          shift and go to state 38
    BOOL            shift and go to state 39
    NULL            shift and go to state 40

  ! OPEN_TAG        [ reduce using rule 30 (if_elseStatement -> IF LPAREN logicalCondition RPAREN LCURLY ifStatementBody .) ]
  ! CLOSE_TAG       [ reduce using rule 30 (if_elseStatement -> IF LPAREN logicalCondition RPAREN LCURLY ifStatementBody .) ]
  ! LPAREN          [ reduce using rule 30 (if_elseStatement -> IF LPAREN logicalCondition RPAREN LCURLY ifStatementBody .) ]
  ! IF              [ reduce using rule 30 (if_elseStatement -> IF LPAREN logicalCondition RPAREN LCURLY ifStatementBody .) ]
  ! FOR             [ reduce using rule 30 (if_elseStatement -> IF LPAREN logicalCondition RPAREN LCURLY ifStatementBody .) ]
  ! SWITCH          [ reduce using rule 30 (if_elseStatement -> IF LPAREN logicalCondition RPAREN LCURLY ifStatementBody .) ]
  ! ID              [ reduce using rule 30 (if_elseStatement -> IF LPAREN logicalCondition RPAREN LCURLY ifStatementBody .) ]
  ! FUNCTION        [ reduce using rule 30 (if_elseStatement -> IF LPAREN logicalCondition RPAREN LCURLY ifStatementBody .) ]
  ! FN              [ reduce using rule 30 (if_elseStatement -> IF LPAREN logicalCondition RPAREN LCURLY ifStatementBody .) ]
  ! ECHO            [ reduce using rule 30 (if_elseStatement -> IF LPAREN logicalCondition RPAREN LCURLY ifStatementBody .) ]
  ! PRINT           [ reduce using rule 30 (if_elseStatement -> IF LPAREN logicalCondition RPAREN LCURLY ifStatementBody .) ]
  ! INTEGER         [ reduce using rule 30 (if_elseStatement -> IF LPAREN logicalCondition RPAREN LCURLY ifStatementBody .) ]
  ! FLOAT           [ reduce using rule 30 (if_elseStatement -> IF LPAREN logicalCondition RPAREN LCURLY ifStatementBody .) ]
  ! STRING          [ reduce using rule 30 (if_elseStatement -> IF LPAREN logicalCondition RPAREN LCURLY ifStatementBody .) ]
  ! BOOL            [ reduce using rule 30 (if_elseStatement -> IF LPAREN logicalCondition RPAREN LCURLY ifStatementBody .) ]
  ! NULL            [ reduce using rule 30 (if_elseStatement -> IF LPAREN logicalCondition RPAREN LCURLY ifStatementBody .) ]
  ! RCURLY          [ reduce using rule 30 (if_elseStatement -> IF LPAREN logicalCondition RPAREN LCURLY ifStatementBody .) ]

    logicalCondition               shift and go to state 21
    cuerpo                         shift and go to state 179
    arithmeticExpression           shift and go to state 3
    if_elseStatement               shift and go to state 4
    forStatement                   shift and go to state 5
    switchStatement                shift and go to state 6
    arrayAsignation                shift and go to state 7
    queueDeclaration               shift and go to state 8
    queueEnqueue                   shift and go to state 9
    queueDequeue                   shift and go to state 10
    defineFunction                 shift and go to state 11
    anonymousFunction              shift and go to state 12
    arrowFunction                  shift and go to state 13
    echo                           shift and go to state 14
    fgets                          shift and go to state 15
    stackDeclaration               shift and go to state 16
    stackPush                      shift and go to state 17
    stackPop                       shift and go to state 18
    line                           shift and go to state 19
    print                          shift and go to state 20
    value                          shift and go to state 24
    variableAsignation             shift and go to state 33
    comparingValue                 shift and go to state 35

state 160

    (31) ifStatementBody -> cuerpo .
    (32) ifStatementBody -> cuerpo . CONTINUE SEMICOLON

  ! shift/reduce conflict for CONTINUE resolved as shift
    RCURLY          reduce using rule 31 (ifStatementBody -> cuerpo .)
    OPEN_TAG        reduce using rule 31 (ifStatementBody -> cuerpo .)
    CLOSE_TAG       reduce using rule 31 (ifStatementBody -> cuerpo .)
    LPAREN          reduce using rule 31 (ifStatementBody -> cuerpo .)
    IF              reduce using rule 31 (ifStatementBody -> cuerpo .)
    FOR             reduce using rule 31 (ifStatementBody -> cuerpo .)
    SWITCH          reduce using rule 31 (ifStatementBody -> cuerpo .)
    ID              reduce using rule 31 (ifStatementBody -> cuerpo .)
    FUNCTION        reduce using rule 31 (ifStatementBody -> cuerpo .)
    FN              reduce using rule 31 (ifStatementBody -> cuerpo .)
    ECHO            reduce using rule 31 (ifStatementBody -> cuerpo .)
    PRINT           reduce using rule 31 (ifStatementBody -> cuerpo .)
    INTEGER         reduce using rule 31 (ifStatementBody -> cuerpo .)
    FLOAT           reduce using rule 31 (ifStatementBody -> cuerpo .)
    STRING          reduce using rule 31 (ifStatementBody -> cuerpo .)
    BOOL            reduce using rule 31 (ifStatementBody -> cuerpo .)
    NULL            reduce using rule 31 (ifStatementBody -> cuerpo .)
    $end            reduce using rule 31 (ifStatementBody -> cuerpo .)
    SEMICOLON       reduce using rule 31 (ifStatementBody -> cuerpo .)
    BREAK           reduce using rule 31 (ifStatementBody -> cuerpo .)
    CONTINUE        shift and go to state 180

  ! CONTINUE        [ reduce using rule 31 (ifStatementBody -> cuerpo .) ]


state 161

    (34) forStatement -> FOR LPAREN forStatementCondition RPAREN LCURLY forStatementBody . RCURLY
    (39) forStatementBody -> forStatementBody . cuerpo
    (3) cuerpo -> . arithmeticExpression
    (4) cuerpo -> . if_elseStatement
    (5) cuerpo -> . forStatement
    (6) cuerpo -> . switchStatement
    (7) cuerpo -> . arrayAsignation
    (8) cuerpo -> . queueDeclaration
    (9) cuerpo -> . queueEnqueue
    (10) cuerpo -> . queueDequeue
    (11) cuerpo -> . defineFunction
    (12) cuerpo -> . anonymousFunction
    (13) cuerpo -> . arrowFunction
    (14) cuerpo -> . echo
    (15) cuerpo -> . fgets
    (16) cuerpo -> . stackDeclaration
    (17) cuerpo -> . stackPush
    (18) cuerpo -> . stackPop
    (19) cuerpo -> . line
    (20) cuerpo -> . print
    (21) cuerpo -> . logicalCondition
    (22) cuerpo -> . OPEN_TAG
    (23) cuerpo -> . CLOSE_TAG
    (69) arithmeticExpression -> . value
    (70) arithmeticExpression -> . arithmeticExpression arithmeticOperator arithmeticExpression
    (71) arithmeticExpression -> . LPAREN arithmeticExpression RPAREN
    (29) if_elseStatement -> . IF LPAREN logicalCondition RPAREN LCURLY ifStatementBody RCURLY ELSE ifStatementBody
    (30) if_elseStatement -> . IF LPAREN logicalCondition RPAREN LCURLY ifStatementBody
    (34) forStatement -> . FOR LPAREN forStatementCondition RPAREN LCURLY forStatementBody RCURLY
    (24) switchStatement -> . SWITCH LPAREN value RPAREN LCURLY switchCases switchDefault RCURLY
    (40) arrayAsignation -> . ID EQUAL arrayDeclaration SEMICOLON
    (51) queueDeclaration -> . ID EQUAL NEW QUEUE SEMICOLON
    (52) queueEnqueue -> . ID OBJOP PUSH LPAREN value RPAREN SEMICOLON
    (53) queueDequeue -> . ID OBJOP POP SEMICOLON
    (54) defineFunction -> . FUNCTION ID LPAREN arguments RPAREN LCURLY cuerpo RCURLY
    (55) defineFunction -> . FUNCTION ID LPAREN RPAREN LCURLY cuerpo RCURLY
    (58) anonymousFunction -> . FUNCTION LPAREN RPAREN LCURLY cuerpo RCURLY
    (59) anonymousFunction -> . FUNCTION LPAREN arguments RPAREN LCURLY cuerpo RCURLY
    (60) arrowFunction -> . FN LPAREN ID RPAREN FNARROW arrowBody SEMICOLON
    (63) echo -> . ECHO values SEMICOLON
    (68) fgets -> . ID EQUAL FGETS LPAREN STDIN RPAREN SEMICOLON
    (48) stackDeclaration -> . ID EQUAL NEW STACK SEMICOLON
    (49) stackPush -> . ID OBJOP PUSH LPAREN value RPAREN SEMICOLON
    (50) stackPop -> . ID OBJOP POP SEMICOLON
    (84) line -> . variableAsignation SEMICOLON
    (64) print -> . PRINT LPAREN values RPAREN SEMICOLON
    (65) print -> . PRINT value SEMICOLON
    (95) logicalCondition -> . comparingValue
    (96) logicalCondition -> . comparingValue conditionOperator comparingValue
    (97) logicalCondition -> . LPAREN logicalCondition RPAREN
    (72) value -> . ID
    (73) value -> . INTEGER
    (74) value -> . FLOAT
    (75) value -> . STRING
    (76) value -> . BOOL
    (77) value -> . NULL
    (85) variableAsignation -> . ID EQUAL value
    (86) variableAsignation -> . ID EQUAL arithmeticExpression
    (94) comparingValue -> . value comparingSign value

    RCURLY          shift and go to state 181
    OPEN_TAG        shift and go to state 22
    CLOSE_TAG       shift and go to state 23
    LPAREN          shift and go to state 25
    IF              shift and go to state 26
    FOR             shift and go to state 27
    SWITCH          shift and go to state 28
    ID              shift and go to state 29
    FUNCTION        shift and go to state 30
    FN              shift and go to state 31
    ECHO            shift and go to state 32
    PRINT           shift and go to state 34
    INTEGER         shift and go to state 36
    FLOAT           shift and go to state 37
    STRING          shift and go to state 38
    BOOL            shift and go to state 39
    NULL            shift and go to state 40

    cuerpo                         shift and go to state 182
    arithmeticExpression           shift and go to state 3
    if_elseStatement               shift and go to state 4
    forStatement                   shift and go to state 5
    switchStatement                shift and go to state 6
    arrayAsignation                shift and go to state 7
    queueDeclaration               shift and go to state 8
    queueEnqueue                   shift and go to state 9
    queueDequeue                   shift and go to state 10
    defineFunction                 shift and go to state 11
    anonymousFunction              shift and go to state 12
    arrowFunction                  shift and go to state 13
    echo                           shift and go to state 14
    fgets                          shift and go to state 15
    stackDeclaration               shift and go to state 16
    stackPush                      shift and go to state 17
    stackPop                       shift and go to state 18
    line                           shift and go to state 19
    print                          shift and go to state 20
    logicalCondition               shift and go to state 21
    value                          shift and go to state 24
    variableAsignation             shift and go to state 33
    comparingValue                 shift and go to state 35

state 162

    (38) forStatementBody -> cuerpo .

    RCURLY          reduce using rule 38 (forStatementBody -> cuerpo .)
    OPEN_TAG        reduce using rule 38 (forStatementBody -> cuerpo .)
    CLOSE_TAG       reduce using rule 38 (forStatementBody -> cuerpo .)
    LPAREN          reduce using rule 38 (forStatementBody -> cuerpo .)
    IF              reduce using rule 38 (forStatementBody -> cuerpo .)
    FOR             reduce using rule 38 (forStatementBody -> cuerpo .)
    SWITCH          reduce using rule 38 (forStatementBody -> cuerpo .)
    ID              reduce using rule 38 (forStatementBody -> cuerpo .)
    FUNCTION        reduce using rule 38 (forStatementBody -> cuerpo .)
    FN              reduce using rule 38 (forStatementBody -> cuerpo .)
    ECHO            reduce using rule 38 (forStatementBody -> cuerpo .)
    PRINT           reduce using rule 38 (forStatementBody -> cuerpo .)
    INTEGER         reduce using rule 38 (forStatementBody -> cuerpo .)
    FLOAT           reduce using rule 38 (forStatementBody -> cuerpo .)
    STRING          reduce using rule 38 (forStatementBody -> cuerpo .)
    BOOL            reduce using rule 38 (forStatementBody -> cuerpo .)
    NULL            reduce using rule 38 (forStatementBody -> cuerpo .)


state 163

    (36) forStatementCondition -> variableAsignation SEMICOLON SEMICOLON variableAsignation .

    RPAREN          reduce using rule 36 (forStatementCondition -> variableAsignation SEMICOLON SEMICOLON variableAsignation .)


state 164

    (37) forStatementCondition -> variableAsignation SEMICOLON comparingValue SEMICOLON . variableAsignation
    (85) variableAsignation -> . ID EQUAL value
    (86) variableAsignation -> . ID EQUAL arithmeticExpression

    ID              shift and go to state 89

    variableAsignation             shift and go to state 183

state 165

    (24) switchStatement -> SWITCH LPAREN value RPAREN LCURLY switchCases . switchDefault RCURLY
    (28) switchCases -> switchCases . switchCase
    (25) switchDefault -> . DEFAULT COLON programa
    (26) switchCase -> . CASE value COLON programa BREAK SEMICOLON

    DEFAULT         shift and go to state 186
    CASE            shift and go to state 167

    switchDefault                  shift and go to state 184
    switchCase                     shift and go to state 185

state 166

    (27) switchCases -> switchCase .

    DEFAULT         reduce using rule 27 (switchCases -> switchCase .)
    CASE            reduce using rule 27 (switchCases -> switchCase .)


state 167

    (26) switchCase -> CASE . value COLON programa BREAK SEMICOLON
    (72) value -> . ID
    (73) value -> . INTEGER
    (74) value -> . FLOAT
    (75) value -> . STRING
    (76) value -> . BOOL
    (77) value -> . NULL

    ID              shift and go to state 59
    INTEGER         shift and go to state 36
    FLOAT           shift and go to state 37
    STRING          shift and go to state 38
    BOOL            shift and go to state 39
    NULL            shift and go to state 40

    value                          shift and go to state 187

state 168

    (68) fgets -> ID EQUAL FGETS LPAREN STDIN RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 188


state 169

    (45) arraysValues -> arraysValues COMMA arrayValue .

    RPAREN          reduce using rule 45 (arraysValues -> arraysValues COMMA arrayValue .)
    COMMA           reduce using rule 45 (arraysValues -> arraysValues COMMA arrayValue .)
    RSQUARE         reduce using rule 45 (arraysValues -> arraysValues COMMA arrayValue .)


state 170

    (52) queueEnqueue -> ID OBJOP PUSH LPAREN value RPAREN . SEMICOLON
    (49) stackPush -> ID OBJOP PUSH LPAREN value RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 189


state 171

    (54) defineFunction -> FUNCTION ID LPAREN arguments RPAREN LCURLY . cuerpo RCURLY
    (3) cuerpo -> . arithmeticExpression
    (4) cuerpo -> . if_elseStatement
    (5) cuerpo -> . forStatement
    (6) cuerpo -> . switchStatement
    (7) cuerpo -> . arrayAsignation
    (8) cuerpo -> . queueDeclaration
    (9) cuerpo -> . queueEnqueue
    (10) cuerpo -> . queueDequeue
    (11) cuerpo -> . defineFunction
    (12) cuerpo -> . anonymousFunction
    (13) cuerpo -> . arrowFunction
    (14) cuerpo -> . echo
    (15) cuerpo -> . fgets
    (16) cuerpo -> . stackDeclaration
    (17) cuerpo -> . stackPush
    (18) cuerpo -> . stackPop
    (19) cuerpo -> . line
    (20) cuerpo -> . print
    (21) cuerpo -> . logicalCondition
    (22) cuerpo -> . OPEN_TAG
    (23) cuerpo -> . CLOSE_TAG
    (69) arithmeticExpression -> . value
    (70) arithmeticExpression -> . arithmeticExpression arithmeticOperator arithmeticExpression
    (71) arithmeticExpression -> . LPAREN arithmeticExpression RPAREN
    (29) if_elseStatement -> . IF LPAREN logicalCondition RPAREN LCURLY ifStatementBody RCURLY ELSE ifStatementBody
    (30) if_elseStatement -> . IF LPAREN logicalCondition RPAREN LCURLY ifStatementBody
    (34) forStatement -> . FOR LPAREN forStatementCondition RPAREN LCURLY forStatementBody RCURLY
    (24) switchStatement -> . SWITCH LPAREN value RPAREN LCURLY switchCases switchDefault RCURLY
    (40) arrayAsignation -> . ID EQUAL arrayDeclaration SEMICOLON
    (51) queueDeclaration -> . ID EQUAL NEW QUEUE SEMICOLON
    (52) queueEnqueue -> . ID OBJOP PUSH LPAREN value RPAREN SEMICOLON
    (53) queueDequeue -> . ID OBJOP POP SEMICOLON
    (54) defineFunction -> . FUNCTION ID LPAREN arguments RPAREN LCURLY cuerpo RCURLY
    (55) defineFunction -> . FUNCTION ID LPAREN RPAREN LCURLY cuerpo RCURLY
    (58) anonymousFunction -> . FUNCTION LPAREN RPAREN LCURLY cuerpo RCURLY
    (59) anonymousFunction -> . FUNCTION LPAREN arguments RPAREN LCURLY cuerpo RCURLY
    (60) arrowFunction -> . FN LPAREN ID RPAREN FNARROW arrowBody SEMICOLON
    (63) echo -> . ECHO values SEMICOLON
    (68) fgets -> . ID EQUAL FGETS LPAREN STDIN RPAREN SEMICOLON
    (48) stackDeclaration -> . ID EQUAL NEW STACK SEMICOLON
    (49) stackPush -> . ID OBJOP PUSH LPAREN value RPAREN SEMICOLON
    (50) stackPop -> . ID OBJOP POP SEMICOLON
    (84) line -> . variableAsignation SEMICOLON
    (64) print -> . PRINT LPAREN values RPAREN SEMICOLON
    (65) print -> . PRINT value SEMICOLON
    (95) logicalCondition -> . comparingValue
    (96) logicalCondition -> . comparingValue conditionOperator comparingValue
    (97) logicalCondition -> . LPAREN logicalCondition RPAREN
    (72) value -> . ID
    (73) value -> . INTEGER
    (74) value -> . FLOAT
    (75) value -> . STRING
    (76) value -> . BOOL
    (77) value -> . NULL
    (85) variableAsignation -> . ID EQUAL value
    (86) variableAsignation -> . ID EQUAL arithmeticExpression
    (94) comparingValue -> . value comparingSign value

    OPEN_TAG        shift and go to state 22
    CLOSE_TAG       shift and go to state 23
    LPAREN          shift and go to state 25
    IF              shift and go to state 26
    FOR             shift and go to state 27
    SWITCH          shift and go to state 28
    ID              shift and go to state 29
    FUNCTION        shift and go to state 30
    FN              shift and go to state 31
    ECHO            shift and go to state 32
    PRINT           shift and go to state 34
    INTEGER         shift and go to state 36
    FLOAT           shift and go to state 37
    STRING          shift and go to state 38
    BOOL            shift and go to state 39
    NULL            shift and go to state 40

    cuerpo                         shift and go to state 190
    arithmeticExpression           shift and go to state 3
    if_elseStatement               shift and go to state 4
    forStatement                   shift and go to state 5
    switchStatement                shift and go to state 6
    arrayAsignation                shift and go to state 7
    queueDeclaration               shift and go to state 8
    queueEnqueue                   shift and go to state 9
    queueDequeue                   shift and go to state 10
    defineFunction                 shift and go to state 11
    anonymousFunction              shift and go to state 12
    arrowFunction                  shift and go to state 13
    echo                           shift and go to state 14
    fgets                          shift and go to state 15
    stackDeclaration               shift and go to state 16
    stackPush                      shift and go to state 17
    stackPop                       shift and go to state 18
    line                           shift and go to state 19
    print                          shift and go to state 20
    logicalCondition               shift and go to state 21
    value                          shift and go to state 24
    variableAsignation             shift and go to state 33
    comparingValue                 shift and go to state 35

state 172

    (55) defineFunction -> FUNCTION ID LPAREN RPAREN LCURLY cuerpo . RCURLY

    RCURLY          shift and go to state 191


state 173

    (58) anonymousFunction -> FUNCTION LPAREN RPAREN LCURLY cuerpo RCURLY .

    OPEN_TAG        reduce using rule 58 (anonymousFunction -> FUNCTION LPAREN RPAREN LCURLY cuerpo RCURLY .)
    CLOSE_TAG       reduce using rule 58 (anonymousFunction -> FUNCTION LPAREN RPAREN LCURLY cuerpo RCURLY .)
    LPAREN          reduce using rule 58 (anonymousFunction -> FUNCTION LPAREN RPAREN LCURLY cuerpo RCURLY .)
    IF              reduce using rule 58 (anonymousFunction -> FUNCTION LPAREN RPAREN LCURLY cuerpo RCURLY .)
    FOR             reduce using rule 58 (anonymousFunction -> FUNCTION LPAREN RPAREN LCURLY cuerpo RCURLY .)
    SWITCH          reduce using rule 58 (anonymousFunction -> FUNCTION LPAREN RPAREN LCURLY cuerpo RCURLY .)
    ID              reduce using rule 58 (anonymousFunction -> FUNCTION LPAREN RPAREN LCURLY cuerpo RCURLY .)
    FUNCTION        reduce using rule 58 (anonymousFunction -> FUNCTION LPAREN RPAREN LCURLY cuerpo RCURLY .)
    FN              reduce using rule 58 (anonymousFunction -> FUNCTION LPAREN RPAREN LCURLY cuerpo RCURLY .)
    ECHO            reduce using rule 58 (anonymousFunction -> FUNCTION LPAREN RPAREN LCURLY cuerpo RCURLY .)
    PRINT           reduce using rule 58 (anonymousFunction -> FUNCTION LPAREN RPAREN LCURLY cuerpo RCURLY .)
    INTEGER         reduce using rule 58 (anonymousFunction -> FUNCTION LPAREN RPAREN LCURLY cuerpo RCURLY .)
    FLOAT           reduce using rule 58 (anonymousFunction -> FUNCTION LPAREN RPAREN LCURLY cuerpo RCURLY .)
    STRING          reduce using rule 58 (anonymousFunction -> FUNCTION LPAREN RPAREN LCURLY cuerpo RCURLY .)
    BOOL            reduce using rule 58 (anonymousFunction -> FUNCTION LPAREN RPAREN LCURLY cuerpo RCURLY .)
    NULL            reduce using rule 58 (anonymousFunction -> FUNCTION LPAREN RPAREN LCURLY cuerpo RCURLY .)
    $end            reduce using rule 58 (anonymousFunction -> FUNCTION LPAREN RPAREN LCURLY cuerpo RCURLY .)
    RCURLY          reduce using rule 58 (anonymousFunction -> FUNCTION LPAREN RPAREN LCURLY cuerpo RCURLY .)
    CONTINUE        reduce using rule 58 (anonymousFunction -> FUNCTION LPAREN RPAREN LCURLY cuerpo RCURLY .)
    SEMICOLON       reduce using rule 58 (anonymousFunction -> FUNCTION LPAREN RPAREN LCURLY cuerpo RCURLY .)
    BREAK           reduce using rule 58 (anonymousFunction -> FUNCTION LPAREN RPAREN LCURLY cuerpo RCURLY .)


state 174

    (59) anonymousFunction -> FUNCTION LPAREN arguments RPAREN LCURLY cuerpo . RCURLY

    RCURLY          shift and go to state 192


state 175

    (61) arrowBody -> FN . LPAREN ID RPAREN FNARROW arrowBody
    (60) arrowFunction -> FN . LPAREN ID RPAREN FNARROW arrowBody SEMICOLON

    LPAREN          shift and go to state 193


state 176

    (60) arrowFunction -> FN LPAREN ID RPAREN FNARROW arrowBody . SEMICOLON

    SEMICOLON       shift and go to state 194


state 177

    (62) arrowBody -> cuerpo .

    SEMICOLON       reduce using rule 62 (arrowBody -> cuerpo .)


state 178

    (29) if_elseStatement -> IF LPAREN logicalCondition RPAREN LCURLY ifStatementBody RCURLY . ELSE ifStatementBody

    ELSE            shift and go to state 195


state 179

    (33) ifStatementBody -> ifStatementBody cuerpo .

    CONTINUE        reduce using rule 33 (ifStatementBody -> ifStatementBody cuerpo .)
    RCURLY          reduce using rule 33 (ifStatementBody -> ifStatementBody cuerpo .)
    OPEN_TAG        reduce using rule 33 (ifStatementBody -> ifStatementBody cuerpo .)
    CLOSE_TAG       reduce using rule 33 (ifStatementBody -> ifStatementBody cuerpo .)
    LPAREN          reduce using rule 33 (ifStatementBody -> ifStatementBody cuerpo .)
    IF              reduce using rule 33 (ifStatementBody -> ifStatementBody cuerpo .)
    FOR             reduce using rule 33 (ifStatementBody -> ifStatementBody cuerpo .)
    SWITCH          reduce using rule 33 (ifStatementBody -> ifStatementBody cuerpo .)
    ID              reduce using rule 33 (ifStatementBody -> ifStatementBody cuerpo .)
    FUNCTION        reduce using rule 33 (ifStatementBody -> ifStatementBody cuerpo .)
    FN              reduce using rule 33 (ifStatementBody -> ifStatementBody cuerpo .)
    ECHO            reduce using rule 33 (ifStatementBody -> ifStatementBody cuerpo .)
    PRINT           reduce using rule 33 (ifStatementBody -> ifStatementBody cuerpo .)
    INTEGER         reduce using rule 33 (ifStatementBody -> ifStatementBody cuerpo .)
    FLOAT           reduce using rule 33 (ifStatementBody -> ifStatementBody cuerpo .)
    STRING          reduce using rule 33 (ifStatementBody -> ifStatementBody cuerpo .)
    BOOL            reduce using rule 33 (ifStatementBody -> ifStatementBody cuerpo .)
    NULL            reduce using rule 33 (ifStatementBody -> ifStatementBody cuerpo .)
    $end            reduce using rule 33 (ifStatementBody -> ifStatementBody cuerpo .)
    SEMICOLON       reduce using rule 33 (ifStatementBody -> ifStatementBody cuerpo .)
    BREAK           reduce using rule 33 (ifStatementBody -> ifStatementBody cuerpo .)


state 180

    (32) ifStatementBody -> cuerpo CONTINUE . SEMICOLON

    SEMICOLON       shift and go to state 196


state 181

    (34) forStatement -> FOR LPAREN forStatementCondition RPAREN LCURLY forStatementBody RCURLY .

    OPEN_TAG        reduce using rule 34 (forStatement -> FOR LPAREN forStatementCondition RPAREN LCURLY forStatementBody RCURLY .)
    CLOSE_TAG       reduce using rule 34 (forStatement -> FOR LPAREN forStatementCondition RPAREN LCURLY forStatementBody RCURLY .)
    LPAREN          reduce using rule 34 (forStatement -> FOR LPAREN forStatementCondition RPAREN LCURLY forStatementBody RCURLY .)
    IF              reduce using rule 34 (forStatement -> FOR LPAREN forStatementCondition RPAREN LCURLY forStatementBody RCURLY .)
    FOR             reduce using rule 34 (forStatement -> FOR LPAREN forStatementCondition RPAREN LCURLY forStatementBody RCURLY .)
    SWITCH          reduce using rule 34 (forStatement -> FOR LPAREN forStatementCondition RPAREN LCURLY forStatementBody RCURLY .)
    ID              reduce using rule 34 (forStatement -> FOR LPAREN forStatementCondition RPAREN LCURLY forStatementBody RCURLY .)
    FUNCTION        reduce using rule 34 (forStatement -> FOR LPAREN forStatementCondition RPAREN LCURLY forStatementBody RCURLY .)
    FN              reduce using rule 34 (forStatement -> FOR LPAREN forStatementCondition RPAREN LCURLY forStatementBody RCURLY .)
    ECHO            reduce using rule 34 (forStatement -> FOR LPAREN forStatementCondition RPAREN LCURLY forStatementBody RCURLY .)
    PRINT           reduce using rule 34 (forStatement -> FOR LPAREN forStatementCondition RPAREN LCURLY forStatementBody RCURLY .)
    INTEGER         reduce using rule 34 (forStatement -> FOR LPAREN forStatementCondition RPAREN LCURLY forStatementBody RCURLY .)
    FLOAT           reduce using rule 34 (forStatement -> FOR LPAREN forStatementCondition RPAREN LCURLY forStatementBody RCURLY .)
    STRING          reduce using rule 34 (forStatement -> FOR LPAREN forStatementCondition RPAREN LCURLY forStatementBody RCURLY .)
    BOOL            reduce using rule 34 (forStatement -> FOR LPAREN forStatementCondition RPAREN LCURLY forStatementBody RCURLY .)
    NULL            reduce using rule 34 (forStatement -> FOR LPAREN forStatementCondition RPAREN LCURLY forStatementBody RCURLY .)
    $end            reduce using rule 34 (forStatement -> FOR LPAREN forStatementCondition RPAREN LCURLY forStatementBody RCURLY .)
    RCURLY          reduce using rule 34 (forStatement -> FOR LPAREN forStatementCondition RPAREN LCURLY forStatementBody RCURLY .)
    CONTINUE        reduce using rule 34 (forStatement -> FOR LPAREN forStatementCondition RPAREN LCURLY forStatementBody RCURLY .)
    SEMICOLON       reduce using rule 34 (forStatement -> FOR LPAREN forStatementCondition RPAREN LCURLY forStatementBody RCURLY .)
    BREAK           reduce using rule 34 (forStatement -> FOR LPAREN forStatementCondition RPAREN LCURLY forStatementBody RCURLY .)


state 182

    (39) forStatementBody -> forStatementBody cuerpo .

    RCURLY          reduce using rule 39 (forStatementBody -> forStatementBody cuerpo .)
    OPEN_TAG        reduce using rule 39 (forStatementBody -> forStatementBody cuerpo .)
    CLOSE_TAG       reduce using rule 39 (forStatementBody -> forStatementBody cuerpo .)
    LPAREN          reduce using rule 39 (forStatementBody -> forStatementBody cuerpo .)
    IF              reduce using rule 39 (forStatementBody -> forStatementBody cuerpo .)
    FOR             reduce using rule 39 (forStatementBody -> forStatementBody cuerpo .)
    SWITCH          reduce using rule 39 (forStatementBody -> forStatementBody cuerpo .)
    ID              reduce using rule 39 (forStatementBody -> forStatementBody cuerpo .)
    FUNCTION        reduce using rule 39 (forStatementBody -> forStatementBody cuerpo .)
    FN              reduce using rule 39 (forStatementBody -> forStatementBody cuerpo .)
    ECHO            reduce using rule 39 (forStatementBody -> forStatementBody cuerpo .)
    PRINT           reduce using rule 39 (forStatementBody -> forStatementBody cuerpo .)
    INTEGER         reduce using rule 39 (forStatementBody -> forStatementBody cuerpo .)
    FLOAT           reduce using rule 39 (forStatementBody -> forStatementBody cuerpo .)
    STRING          reduce using rule 39 (forStatementBody -> forStatementBody cuerpo .)
    BOOL            reduce using rule 39 (forStatementBody -> forStatementBody cuerpo .)
    NULL            reduce using rule 39 (forStatementBody -> forStatementBody cuerpo .)


state 183

    (37) forStatementCondition -> variableAsignation SEMICOLON comparingValue SEMICOLON variableAsignation .

    RPAREN          reduce using rule 37 (forStatementCondition -> variableAsignation SEMICOLON comparingValue SEMICOLON variableAsignation .)


state 184

    (24) switchStatement -> SWITCH LPAREN value RPAREN LCURLY switchCases switchDefault . RCURLY

    RCURLY          shift and go to state 197


state 185

    (28) switchCases -> switchCases switchCase .

    DEFAULT         reduce using rule 28 (switchCases -> switchCases switchCase .)
    CASE            reduce using rule 28 (switchCases -> switchCases switchCase .)


state 186

    (25) switchDefault -> DEFAULT . COLON programa

    COLON           shift and go to state 198


state 187

    (26) switchCase -> CASE value . COLON programa BREAK SEMICOLON

    COLON           shift and go to state 199


state 188

    (68) fgets -> ID EQUAL FGETS LPAREN STDIN RPAREN SEMICOLON .

    OPEN_TAG        reduce using rule 68 (fgets -> ID EQUAL FGETS LPAREN STDIN RPAREN SEMICOLON .)
    CLOSE_TAG       reduce using rule 68 (fgets -> ID EQUAL FGETS LPAREN STDIN RPAREN SEMICOLON .)
    LPAREN          reduce using rule 68 (fgets -> ID EQUAL FGETS LPAREN STDIN RPAREN SEMICOLON .)
    IF              reduce using rule 68 (fgets -> ID EQUAL FGETS LPAREN STDIN RPAREN SEMICOLON .)
    FOR             reduce using rule 68 (fgets -> ID EQUAL FGETS LPAREN STDIN RPAREN SEMICOLON .)
    SWITCH          reduce using rule 68 (fgets -> ID EQUAL FGETS LPAREN STDIN RPAREN SEMICOLON .)
    ID              reduce using rule 68 (fgets -> ID EQUAL FGETS LPAREN STDIN RPAREN SEMICOLON .)
    FUNCTION        reduce using rule 68 (fgets -> ID EQUAL FGETS LPAREN STDIN RPAREN SEMICOLON .)
    FN              reduce using rule 68 (fgets -> ID EQUAL FGETS LPAREN STDIN RPAREN SEMICOLON .)
    ECHO            reduce using rule 68 (fgets -> ID EQUAL FGETS LPAREN STDIN RPAREN SEMICOLON .)
    PRINT           reduce using rule 68 (fgets -> ID EQUAL FGETS LPAREN STDIN RPAREN SEMICOLON .)
    INTEGER         reduce using rule 68 (fgets -> ID EQUAL FGETS LPAREN STDIN RPAREN SEMICOLON .)
    FLOAT           reduce using rule 68 (fgets -> ID EQUAL FGETS LPAREN STDIN RPAREN SEMICOLON .)
    STRING          reduce using rule 68 (fgets -> ID EQUAL FGETS LPAREN STDIN RPAREN SEMICOLON .)
    BOOL            reduce using rule 68 (fgets -> ID EQUAL FGETS LPAREN STDIN RPAREN SEMICOLON .)
    NULL            reduce using rule 68 (fgets -> ID EQUAL FGETS LPAREN STDIN RPAREN SEMICOLON .)
    $end            reduce using rule 68 (fgets -> ID EQUAL FGETS LPAREN STDIN RPAREN SEMICOLON .)
    RCURLY          reduce using rule 68 (fgets -> ID EQUAL FGETS LPAREN STDIN RPAREN SEMICOLON .)
    CONTINUE        reduce using rule 68 (fgets -> ID EQUAL FGETS LPAREN STDIN RPAREN SEMICOLON .)
    SEMICOLON       reduce using rule 68 (fgets -> ID EQUAL FGETS LPAREN STDIN RPAREN SEMICOLON .)
    BREAK           reduce using rule 68 (fgets -> ID EQUAL FGETS LPAREN STDIN RPAREN SEMICOLON .)


state 189

    (52) queueEnqueue -> ID OBJOP PUSH LPAREN value RPAREN SEMICOLON .
    (49) stackPush -> ID OBJOP PUSH LPAREN value RPAREN SEMICOLON .

  ! reduce/reduce conflict for OPEN_TAG resolved using rule 49 (stackPush -> ID OBJOP PUSH LPAREN value RPAREN SEMICOLON .)
  ! reduce/reduce conflict for CLOSE_TAG resolved using rule 49 (stackPush -> ID OBJOP PUSH LPAREN value RPAREN SEMICOLON .)
  ! reduce/reduce conflict for LPAREN resolved using rule 49 (stackPush -> ID OBJOP PUSH LPAREN value RPAREN SEMICOLON .)
  ! reduce/reduce conflict for IF resolved using rule 49 (stackPush -> ID OBJOP PUSH LPAREN value RPAREN SEMICOLON .)
  ! reduce/reduce conflict for FOR resolved using rule 49 (stackPush -> ID OBJOP PUSH LPAREN value RPAREN SEMICOLON .)
  ! reduce/reduce conflict for SWITCH resolved using rule 49 (stackPush -> ID OBJOP PUSH LPAREN value RPAREN SEMICOLON .)
  ! reduce/reduce conflict for ID resolved using rule 49 (stackPush -> ID OBJOP PUSH LPAREN value RPAREN SEMICOLON .)
  ! reduce/reduce conflict for FUNCTION resolved using rule 49 (stackPush -> ID OBJOP PUSH LPAREN value RPAREN SEMICOLON .)
  ! reduce/reduce conflict for FN resolved using rule 49 (stackPush -> ID OBJOP PUSH LPAREN value RPAREN SEMICOLON .)
  ! reduce/reduce conflict for ECHO resolved using rule 49 (stackPush -> ID OBJOP PUSH LPAREN value RPAREN SEMICOLON .)
  ! reduce/reduce conflict for PRINT resolved using rule 49 (stackPush -> ID OBJOP PUSH LPAREN value RPAREN SEMICOLON .)
  ! reduce/reduce conflict for INTEGER resolved using rule 49 (stackPush -> ID OBJOP PUSH LPAREN value RPAREN SEMICOLON .)
  ! reduce/reduce conflict for FLOAT resolved using rule 49 (stackPush -> ID OBJOP PUSH LPAREN value RPAREN SEMICOLON .)
  ! reduce/reduce conflict for STRING resolved using rule 49 (stackPush -> ID OBJOP PUSH LPAREN value RPAREN SEMICOLON .)
  ! reduce/reduce conflict for BOOL resolved using rule 49 (stackPush -> ID OBJOP PUSH LPAREN value RPAREN SEMICOLON .)
  ! reduce/reduce conflict for NULL resolved using rule 49 (stackPush -> ID OBJOP PUSH LPAREN value RPAREN SEMICOLON .)
  ! reduce/reduce conflict for $end resolved using rule 49 (stackPush -> ID OBJOP PUSH LPAREN value RPAREN SEMICOLON .)
  ! reduce/reduce conflict for RCURLY resolved using rule 49 (stackPush -> ID OBJOP PUSH LPAREN value RPAREN SEMICOLON .)
  ! reduce/reduce conflict for CONTINUE resolved using rule 49 (stackPush -> ID OBJOP PUSH LPAREN value RPAREN SEMICOLON .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 49 (stackPush -> ID OBJOP PUSH LPAREN value RPAREN SEMICOLON .)
  ! reduce/reduce conflict for BREAK resolved using rule 49 (stackPush -> ID OBJOP PUSH LPAREN value RPAREN SEMICOLON .)
    OPEN_TAG        reduce using rule 49 (stackPush -> ID OBJOP PUSH LPAREN value RPAREN SEMICOLON .)
    CLOSE_TAG       reduce using rule 49 (stackPush -> ID OBJOP PUSH LPAREN value RPAREN SEMICOLON .)
    LPAREN          reduce using rule 49 (stackPush -> ID OBJOP PUSH LPAREN value RPAREN SEMICOLON .)
    IF              reduce using rule 49 (stackPush -> ID OBJOP PUSH LPAREN value RPAREN SEMICOLON .)
    FOR             reduce using rule 49 (stackPush -> ID OBJOP PUSH LPAREN value RPAREN SEMICOLON .)
    SWITCH          reduce using rule 49 (stackPush -> ID OBJOP PUSH LPAREN value RPAREN SEMICOLON .)
    ID              reduce using rule 49 (stackPush -> ID OBJOP PUSH LPAREN value RPAREN SEMICOLON .)
    FUNCTION        reduce using rule 49 (stackPush -> ID OBJOP PUSH LPAREN value RPAREN SEMICOLON .)
    FN              reduce using rule 49 (stackPush -> ID OBJOP PUSH LPAREN value RPAREN SEMICOLON .)
    ECHO            reduce using rule 49 (stackPush -> ID OBJOP PUSH LPAREN value RPAREN SEMICOLON .)
    PRINT           reduce using rule 49 (stackPush -> ID OBJOP PUSH LPAREN value RPAREN SEMICOLON .)
    INTEGER         reduce using rule 49 (stackPush -> ID OBJOP PUSH LPAREN value RPAREN SEMICOLON .)
    FLOAT           reduce using rule 49 (stackPush -> ID OBJOP PUSH LPAREN value RPAREN SEMICOLON .)
    STRING          reduce using rule 49 (stackPush -> ID OBJOP PUSH LPAREN value RPAREN SEMICOLON .)
    BOOL            reduce using rule 49 (stackPush -> ID OBJOP PUSH LPAREN value RPAREN SEMICOLON .)
    NULL            reduce using rule 49 (stackPush -> ID OBJOP PUSH LPAREN value RPAREN SEMICOLON .)
    $end            reduce using rule 49 (stackPush -> ID OBJOP PUSH LPAREN value RPAREN SEMICOLON .)
    RCURLY          reduce using rule 49 (stackPush -> ID OBJOP PUSH LPAREN value RPAREN SEMICOLON .)
    CONTINUE        reduce using rule 49 (stackPush -> ID OBJOP PUSH LPAREN value RPAREN SEMICOLON .)
    SEMICOLON       reduce using rule 49 (stackPush -> ID OBJOP PUSH LPAREN value RPAREN SEMICOLON .)
    BREAK           reduce using rule 49 (stackPush -> ID OBJOP PUSH LPAREN value RPAREN SEMICOLON .)

  ! OPEN_TAG        [ reduce using rule 52 (queueEnqueue -> ID OBJOP PUSH LPAREN value RPAREN SEMICOLON .) ]
  ! CLOSE_TAG       [ reduce using rule 52 (queueEnqueue -> ID OBJOP PUSH LPAREN value RPAREN SEMICOLON .) ]
  ! LPAREN          [ reduce using rule 52 (queueEnqueue -> ID OBJOP PUSH LPAREN value RPAREN SEMICOLON .) ]
  ! IF              [ reduce using rule 52 (queueEnqueue -> ID OBJOP PUSH LPAREN value RPAREN SEMICOLON .) ]
  ! FOR             [ reduce using rule 52 (queueEnqueue -> ID OBJOP PUSH LPAREN value RPAREN SEMICOLON .) ]
  ! SWITCH          [ reduce using rule 52 (queueEnqueue -> ID OBJOP PUSH LPAREN value RPAREN SEMICOLON .) ]
  ! ID              [ reduce using rule 52 (queueEnqueue -> ID OBJOP PUSH LPAREN value RPAREN SEMICOLON .) ]
  ! FUNCTION        [ reduce using rule 52 (queueEnqueue -> ID OBJOP PUSH LPAREN value RPAREN SEMICOLON .) ]
  ! FN              [ reduce using rule 52 (queueEnqueue -> ID OBJOP PUSH LPAREN value RPAREN SEMICOLON .) ]
  ! ECHO            [ reduce using rule 52 (queueEnqueue -> ID OBJOP PUSH LPAREN value RPAREN SEMICOLON .) ]
  ! PRINT           [ reduce using rule 52 (queueEnqueue -> ID OBJOP PUSH LPAREN value RPAREN SEMICOLON .) ]
  ! INTEGER         [ reduce using rule 52 (queueEnqueue -> ID OBJOP PUSH LPAREN value RPAREN SEMICOLON .) ]
  ! FLOAT           [ reduce using rule 52 (queueEnqueue -> ID OBJOP PUSH LPAREN value RPAREN SEMICOLON .) ]
  ! STRING          [ reduce using rule 52 (queueEnqueue -> ID OBJOP PUSH LPAREN value RPAREN SEMICOLON .) ]
  ! BOOL            [ reduce using rule 52 (queueEnqueue -> ID OBJOP PUSH LPAREN value RPAREN SEMICOLON .) ]
  ! NULL            [ reduce using rule 52 (queueEnqueue -> ID OBJOP PUSH LPAREN value RPAREN SEMICOLON .) ]
  ! $end            [ reduce using rule 52 (queueEnqueue -> ID OBJOP PUSH LPAREN value RPAREN SEMICOLON .) ]
  ! RCURLY          [ reduce using rule 52 (queueEnqueue -> ID OBJOP PUSH LPAREN value RPAREN SEMICOLON .) ]
  ! CONTINUE        [ reduce using rule 52 (queueEnqueue -> ID OBJOP PUSH LPAREN value RPAREN SEMICOLON .) ]
  ! SEMICOLON       [ reduce using rule 52 (queueEnqueue -> ID OBJOP PUSH LPAREN value RPAREN SEMICOLON .) ]
  ! BREAK           [ reduce using rule 52 (queueEnqueue -> ID OBJOP PUSH LPAREN value RPAREN SEMICOLON .) ]


state 190

    (54) defineFunction -> FUNCTION ID LPAREN arguments RPAREN LCURLY cuerpo . RCURLY

    RCURLY          shift and go to state 200


state 191

    (55) defineFunction -> FUNCTION ID LPAREN RPAREN LCURLY cuerpo RCURLY .

    OPEN_TAG        reduce using rule 55 (defineFunction -> FUNCTION ID LPAREN RPAREN LCURLY cuerpo RCURLY .)
    CLOSE_TAG       reduce using rule 55 (defineFunction -> FUNCTION ID LPAREN RPAREN LCURLY cuerpo RCURLY .)
    LPAREN          reduce using rule 55 (defineFunction -> FUNCTION ID LPAREN RPAREN LCURLY cuerpo RCURLY .)
    IF              reduce using rule 55 (defineFunction -> FUNCTION ID LPAREN RPAREN LCURLY cuerpo RCURLY .)
    FOR             reduce using rule 55 (defineFunction -> FUNCTION ID LPAREN RPAREN LCURLY cuerpo RCURLY .)
    SWITCH          reduce using rule 55 (defineFunction -> FUNCTION ID LPAREN RPAREN LCURLY cuerpo RCURLY .)
    ID              reduce using rule 55 (defineFunction -> FUNCTION ID LPAREN RPAREN LCURLY cuerpo RCURLY .)
    FUNCTION        reduce using rule 55 (defineFunction -> FUNCTION ID LPAREN RPAREN LCURLY cuerpo RCURLY .)
    FN              reduce using rule 55 (defineFunction -> FUNCTION ID LPAREN RPAREN LCURLY cuerpo RCURLY .)
    ECHO            reduce using rule 55 (defineFunction -> FUNCTION ID LPAREN RPAREN LCURLY cuerpo RCURLY .)
    PRINT           reduce using rule 55 (defineFunction -> FUNCTION ID LPAREN RPAREN LCURLY cuerpo RCURLY .)
    INTEGER         reduce using rule 55 (defineFunction -> FUNCTION ID LPAREN RPAREN LCURLY cuerpo RCURLY .)
    FLOAT           reduce using rule 55 (defineFunction -> FUNCTION ID LPAREN RPAREN LCURLY cuerpo RCURLY .)
    STRING          reduce using rule 55 (defineFunction -> FUNCTION ID LPAREN RPAREN LCURLY cuerpo RCURLY .)
    BOOL            reduce using rule 55 (defineFunction -> FUNCTION ID LPAREN RPAREN LCURLY cuerpo RCURLY .)
    NULL            reduce using rule 55 (defineFunction -> FUNCTION ID LPAREN RPAREN LCURLY cuerpo RCURLY .)
    $end            reduce using rule 55 (defineFunction -> FUNCTION ID LPAREN RPAREN LCURLY cuerpo RCURLY .)
    RCURLY          reduce using rule 55 (defineFunction -> FUNCTION ID LPAREN RPAREN LCURLY cuerpo RCURLY .)
    CONTINUE        reduce using rule 55 (defineFunction -> FUNCTION ID LPAREN RPAREN LCURLY cuerpo RCURLY .)
    SEMICOLON       reduce using rule 55 (defineFunction -> FUNCTION ID LPAREN RPAREN LCURLY cuerpo RCURLY .)
    BREAK           reduce using rule 55 (defineFunction -> FUNCTION ID LPAREN RPAREN LCURLY cuerpo RCURLY .)


state 192

    (59) anonymousFunction -> FUNCTION LPAREN arguments RPAREN LCURLY cuerpo RCURLY .

    OPEN_TAG        reduce using rule 59 (anonymousFunction -> FUNCTION LPAREN arguments RPAREN LCURLY cuerpo RCURLY .)
    CLOSE_TAG       reduce using rule 59 (anonymousFunction -> FUNCTION LPAREN arguments RPAREN LCURLY cuerpo RCURLY .)
    LPAREN          reduce using rule 59 (anonymousFunction -> FUNCTION LPAREN arguments RPAREN LCURLY cuerpo RCURLY .)
    IF              reduce using rule 59 (anonymousFunction -> FUNCTION LPAREN arguments RPAREN LCURLY cuerpo RCURLY .)
    FOR             reduce using rule 59 (anonymousFunction -> FUNCTION LPAREN arguments RPAREN LCURLY cuerpo RCURLY .)
    SWITCH          reduce using rule 59 (anonymousFunction -> FUNCTION LPAREN arguments RPAREN LCURLY cuerpo RCURLY .)
    ID              reduce using rule 59 (anonymousFunction -> FUNCTION LPAREN arguments RPAREN LCURLY cuerpo RCURLY .)
    FUNCTION        reduce using rule 59 (anonymousFunction -> FUNCTION LPAREN arguments RPAREN LCURLY cuerpo RCURLY .)
    FN              reduce using rule 59 (anonymousFunction -> FUNCTION LPAREN arguments RPAREN LCURLY cuerpo RCURLY .)
    ECHO            reduce using rule 59 (anonymousFunction -> FUNCTION LPAREN arguments RPAREN LCURLY cuerpo RCURLY .)
    PRINT           reduce using rule 59 (anonymousFunction -> FUNCTION LPAREN arguments RPAREN LCURLY cuerpo RCURLY .)
    INTEGER         reduce using rule 59 (anonymousFunction -> FUNCTION LPAREN arguments RPAREN LCURLY cuerpo RCURLY .)
    FLOAT           reduce using rule 59 (anonymousFunction -> FUNCTION LPAREN arguments RPAREN LCURLY cuerpo RCURLY .)
    STRING          reduce using rule 59 (anonymousFunction -> FUNCTION LPAREN arguments RPAREN LCURLY cuerpo RCURLY .)
    BOOL            reduce using rule 59 (anonymousFunction -> FUNCTION LPAREN arguments RPAREN LCURLY cuerpo RCURLY .)
    NULL            reduce using rule 59 (anonymousFunction -> FUNCTION LPAREN arguments RPAREN LCURLY cuerpo RCURLY .)
    $end            reduce using rule 59 (anonymousFunction -> FUNCTION LPAREN arguments RPAREN LCURLY cuerpo RCURLY .)
    RCURLY          reduce using rule 59 (anonymousFunction -> FUNCTION LPAREN arguments RPAREN LCURLY cuerpo RCURLY .)
    CONTINUE        reduce using rule 59 (anonymousFunction -> FUNCTION LPAREN arguments RPAREN LCURLY cuerpo RCURLY .)
    SEMICOLON       reduce using rule 59 (anonymousFunction -> FUNCTION LPAREN arguments RPAREN LCURLY cuerpo RCURLY .)
    BREAK           reduce using rule 59 (anonymousFunction -> FUNCTION LPAREN arguments RPAREN LCURLY cuerpo RCURLY .)


state 193

    (61) arrowBody -> FN LPAREN . ID RPAREN FNARROW arrowBody
    (60) arrowFunction -> FN LPAREN . ID RPAREN FNARROW arrowBody SEMICOLON

    ID              shift and go to state 201


state 194

    (60) arrowFunction -> FN LPAREN ID RPAREN FNARROW arrowBody SEMICOLON .

    OPEN_TAG        reduce using rule 60 (arrowFunction -> FN LPAREN ID RPAREN FNARROW arrowBody SEMICOLON .)
    CLOSE_TAG       reduce using rule 60 (arrowFunction -> FN LPAREN ID RPAREN FNARROW arrowBody SEMICOLON .)
    LPAREN          reduce using rule 60 (arrowFunction -> FN LPAREN ID RPAREN FNARROW arrowBody SEMICOLON .)
    IF              reduce using rule 60 (arrowFunction -> FN LPAREN ID RPAREN FNARROW arrowBody SEMICOLON .)
    FOR             reduce using rule 60 (arrowFunction -> FN LPAREN ID RPAREN FNARROW arrowBody SEMICOLON .)
    SWITCH          reduce using rule 60 (arrowFunction -> FN LPAREN ID RPAREN FNARROW arrowBody SEMICOLON .)
    ID              reduce using rule 60 (arrowFunction -> FN LPAREN ID RPAREN FNARROW arrowBody SEMICOLON .)
    FUNCTION        reduce using rule 60 (arrowFunction -> FN LPAREN ID RPAREN FNARROW arrowBody SEMICOLON .)
    FN              reduce using rule 60 (arrowFunction -> FN LPAREN ID RPAREN FNARROW arrowBody SEMICOLON .)
    ECHO            reduce using rule 60 (arrowFunction -> FN LPAREN ID RPAREN FNARROW arrowBody SEMICOLON .)
    PRINT           reduce using rule 60 (arrowFunction -> FN LPAREN ID RPAREN FNARROW arrowBody SEMICOLON .)
    INTEGER         reduce using rule 60 (arrowFunction -> FN LPAREN ID RPAREN FNARROW arrowBody SEMICOLON .)
    FLOAT           reduce using rule 60 (arrowFunction -> FN LPAREN ID RPAREN FNARROW arrowBody SEMICOLON .)
    STRING          reduce using rule 60 (arrowFunction -> FN LPAREN ID RPAREN FNARROW arrowBody SEMICOLON .)
    BOOL            reduce using rule 60 (arrowFunction -> FN LPAREN ID RPAREN FNARROW arrowBody SEMICOLON .)
    NULL            reduce using rule 60 (arrowFunction -> FN LPAREN ID RPAREN FNARROW arrowBody SEMICOLON .)
    $end            reduce using rule 60 (arrowFunction -> FN LPAREN ID RPAREN FNARROW arrowBody SEMICOLON .)
    RCURLY          reduce using rule 60 (arrowFunction -> FN LPAREN ID RPAREN FNARROW arrowBody SEMICOLON .)
    CONTINUE        reduce using rule 60 (arrowFunction -> FN LPAREN ID RPAREN FNARROW arrowBody SEMICOLON .)
    SEMICOLON       reduce using rule 60 (arrowFunction -> FN LPAREN ID RPAREN FNARROW arrowBody SEMICOLON .)
    BREAK           reduce using rule 60 (arrowFunction -> FN LPAREN ID RPAREN FNARROW arrowBody SEMICOLON .)


state 195

    (29) if_elseStatement -> IF LPAREN logicalCondition RPAREN LCURLY ifStatementBody RCURLY ELSE . ifStatementBody
    (31) ifStatementBody -> . cuerpo
    (32) ifStatementBody -> . cuerpo CONTINUE SEMICOLON
    (33) ifStatementBody -> . ifStatementBody cuerpo
    (3) cuerpo -> . arithmeticExpression
    (4) cuerpo -> . if_elseStatement
    (5) cuerpo -> . forStatement
    (6) cuerpo -> . switchStatement
    (7) cuerpo -> . arrayAsignation
    (8) cuerpo -> . queueDeclaration
    (9) cuerpo -> . queueEnqueue
    (10) cuerpo -> . queueDequeue
    (11) cuerpo -> . defineFunction
    (12) cuerpo -> . anonymousFunction
    (13) cuerpo -> . arrowFunction
    (14) cuerpo -> . echo
    (15) cuerpo -> . fgets
    (16) cuerpo -> . stackDeclaration
    (17) cuerpo -> . stackPush
    (18) cuerpo -> . stackPop
    (19) cuerpo -> . line
    (20) cuerpo -> . print
    (21) cuerpo -> . logicalCondition
    (22) cuerpo -> . OPEN_TAG
    (23) cuerpo -> . CLOSE_TAG
    (69) arithmeticExpression -> . value
    (70) arithmeticExpression -> . arithmeticExpression arithmeticOperator arithmeticExpression
    (71) arithmeticExpression -> . LPAREN arithmeticExpression RPAREN
    (29) if_elseStatement -> . IF LPAREN logicalCondition RPAREN LCURLY ifStatementBody RCURLY ELSE ifStatementBody
    (30) if_elseStatement -> . IF LPAREN logicalCondition RPAREN LCURLY ifStatementBody
    (34) forStatement -> . FOR LPAREN forStatementCondition RPAREN LCURLY forStatementBody RCURLY
    (24) switchStatement -> . SWITCH LPAREN value RPAREN LCURLY switchCases switchDefault RCURLY
    (40) arrayAsignation -> . ID EQUAL arrayDeclaration SEMICOLON
    (51) queueDeclaration -> . ID EQUAL NEW QUEUE SEMICOLON
    (52) queueEnqueue -> . ID OBJOP PUSH LPAREN value RPAREN SEMICOLON
    (53) queueDequeue -> . ID OBJOP POP SEMICOLON
    (54) defineFunction -> . FUNCTION ID LPAREN arguments RPAREN LCURLY cuerpo RCURLY
    (55) defineFunction -> . FUNCTION ID LPAREN RPAREN LCURLY cuerpo RCURLY
    (58) anonymousFunction -> . FUNCTION LPAREN RPAREN LCURLY cuerpo RCURLY
    (59) anonymousFunction -> . FUNCTION LPAREN arguments RPAREN LCURLY cuerpo RCURLY
    (60) arrowFunction -> . FN LPAREN ID RPAREN FNARROW arrowBody SEMICOLON
    (63) echo -> . ECHO values SEMICOLON
    (68) fgets -> . ID EQUAL FGETS LPAREN STDIN RPAREN SEMICOLON
    (48) stackDeclaration -> . ID EQUAL NEW STACK SEMICOLON
    (49) stackPush -> . ID OBJOP PUSH LPAREN value RPAREN SEMICOLON
    (50) stackPop -> . ID OBJOP POP SEMICOLON
    (84) line -> . variableAsignation SEMICOLON
    (64) print -> . PRINT LPAREN values RPAREN SEMICOLON
    (65) print -> . PRINT value SEMICOLON
    (95) logicalCondition -> . comparingValue
    (96) logicalCondition -> . comparingValue conditionOperator comparingValue
    (97) logicalCondition -> . LPAREN logicalCondition RPAREN
    (72) value -> . ID
    (73) value -> . INTEGER
    (74) value -> . FLOAT
    (75) value -> . STRING
    (76) value -> . BOOL
    (77) value -> . NULL
    (85) variableAsignation -> . ID EQUAL value
    (86) variableAsignation -> . ID EQUAL arithmeticExpression
    (94) comparingValue -> . value comparingSign value

    OPEN_TAG        shift and go to state 22
    CLOSE_TAG       shift and go to state 23
    LPAREN          shift and go to state 25
    IF              shift and go to state 26
    FOR             shift and go to state 27
    SWITCH          shift and go to state 28
    ID              shift and go to state 29
    FUNCTION        shift and go to state 30
    FN              shift and go to state 31
    ECHO            shift and go to state 32
    PRINT           shift and go to state 34
    INTEGER         shift and go to state 36
    FLOAT           shift and go to state 37
    STRING          shift and go to state 38
    BOOL            shift and go to state 39
    NULL            shift and go to state 40

    logicalCondition               shift and go to state 21
    ifStatementBody                shift and go to state 202
    cuerpo                         shift and go to state 160
    arithmeticExpression           shift and go to state 3
    if_elseStatement               shift and go to state 4
    forStatement                   shift and go to state 5
    switchStatement                shift and go to state 6
    arrayAsignation                shift and go to state 7
    queueDeclaration               shift and go to state 8
    queueEnqueue                   shift and go to state 9
    queueDequeue                   shift and go to state 10
    defineFunction                 shift and go to state 11
    anonymousFunction              shift and go to state 12
    arrowFunction                  shift and go to state 13
    echo                           shift and go to state 14
    fgets                          shift and go to state 15
    stackDeclaration               shift and go to state 16
    stackPush                      shift and go to state 17
    stackPop                       shift and go to state 18
    line                           shift and go to state 19
    print                          shift and go to state 20
    value                          shift and go to state 24
    variableAsignation             shift and go to state 33
    comparingValue                 shift and go to state 35

state 196

    (32) ifStatementBody -> cuerpo CONTINUE SEMICOLON .

    CONTINUE        reduce using rule 32 (ifStatementBody -> cuerpo CONTINUE SEMICOLON .)
    RCURLY          reduce using rule 32 (ifStatementBody -> cuerpo CONTINUE SEMICOLON .)
    OPEN_TAG        reduce using rule 32 (ifStatementBody -> cuerpo CONTINUE SEMICOLON .)
    CLOSE_TAG       reduce using rule 32 (ifStatementBody -> cuerpo CONTINUE SEMICOLON .)
    LPAREN          reduce using rule 32 (ifStatementBody -> cuerpo CONTINUE SEMICOLON .)
    IF              reduce using rule 32 (ifStatementBody -> cuerpo CONTINUE SEMICOLON .)
    FOR             reduce using rule 32 (ifStatementBody -> cuerpo CONTINUE SEMICOLON .)
    SWITCH          reduce using rule 32 (ifStatementBody -> cuerpo CONTINUE SEMICOLON .)
    ID              reduce using rule 32 (ifStatementBody -> cuerpo CONTINUE SEMICOLON .)
    FUNCTION        reduce using rule 32 (ifStatementBody -> cuerpo CONTINUE SEMICOLON .)
    FN              reduce using rule 32 (ifStatementBody -> cuerpo CONTINUE SEMICOLON .)
    ECHO            reduce using rule 32 (ifStatementBody -> cuerpo CONTINUE SEMICOLON .)
    PRINT           reduce using rule 32 (ifStatementBody -> cuerpo CONTINUE SEMICOLON .)
    INTEGER         reduce using rule 32 (ifStatementBody -> cuerpo CONTINUE SEMICOLON .)
    FLOAT           reduce using rule 32 (ifStatementBody -> cuerpo CONTINUE SEMICOLON .)
    STRING          reduce using rule 32 (ifStatementBody -> cuerpo CONTINUE SEMICOLON .)
    BOOL            reduce using rule 32 (ifStatementBody -> cuerpo CONTINUE SEMICOLON .)
    NULL            reduce using rule 32 (ifStatementBody -> cuerpo CONTINUE SEMICOLON .)
    $end            reduce using rule 32 (ifStatementBody -> cuerpo CONTINUE SEMICOLON .)
    SEMICOLON       reduce using rule 32 (ifStatementBody -> cuerpo CONTINUE SEMICOLON .)
    BREAK           reduce using rule 32 (ifStatementBody -> cuerpo CONTINUE SEMICOLON .)


state 197

    (24) switchStatement -> SWITCH LPAREN value RPAREN LCURLY switchCases switchDefault RCURLY .

    OPEN_TAG        reduce using rule 24 (switchStatement -> SWITCH LPAREN value RPAREN LCURLY switchCases switchDefault RCURLY .)
    CLOSE_TAG       reduce using rule 24 (switchStatement -> SWITCH LPAREN value RPAREN LCURLY switchCases switchDefault RCURLY .)
    LPAREN          reduce using rule 24 (switchStatement -> SWITCH LPAREN value RPAREN LCURLY switchCases switchDefault RCURLY .)
    IF              reduce using rule 24 (switchStatement -> SWITCH LPAREN value RPAREN LCURLY switchCases switchDefault RCURLY .)
    FOR             reduce using rule 24 (switchStatement -> SWITCH LPAREN value RPAREN LCURLY switchCases switchDefault RCURLY .)
    SWITCH          reduce using rule 24 (switchStatement -> SWITCH LPAREN value RPAREN LCURLY switchCases switchDefault RCURLY .)
    ID              reduce using rule 24 (switchStatement -> SWITCH LPAREN value RPAREN LCURLY switchCases switchDefault RCURLY .)
    FUNCTION        reduce using rule 24 (switchStatement -> SWITCH LPAREN value RPAREN LCURLY switchCases switchDefault RCURLY .)
    FN              reduce using rule 24 (switchStatement -> SWITCH LPAREN value RPAREN LCURLY switchCases switchDefault RCURLY .)
    ECHO            reduce using rule 24 (switchStatement -> SWITCH LPAREN value RPAREN LCURLY switchCases switchDefault RCURLY .)
    PRINT           reduce using rule 24 (switchStatement -> SWITCH LPAREN value RPAREN LCURLY switchCases switchDefault RCURLY .)
    INTEGER         reduce using rule 24 (switchStatement -> SWITCH LPAREN value RPAREN LCURLY switchCases switchDefault RCURLY .)
    FLOAT           reduce using rule 24 (switchStatement -> SWITCH LPAREN value RPAREN LCURLY switchCases switchDefault RCURLY .)
    STRING          reduce using rule 24 (switchStatement -> SWITCH LPAREN value RPAREN LCURLY switchCases switchDefault RCURLY .)
    BOOL            reduce using rule 24 (switchStatement -> SWITCH LPAREN value RPAREN LCURLY switchCases switchDefault RCURLY .)
    NULL            reduce using rule 24 (switchStatement -> SWITCH LPAREN value RPAREN LCURLY switchCases switchDefault RCURLY .)
    $end            reduce using rule 24 (switchStatement -> SWITCH LPAREN value RPAREN LCURLY switchCases switchDefault RCURLY .)
    RCURLY          reduce using rule 24 (switchStatement -> SWITCH LPAREN value RPAREN LCURLY switchCases switchDefault RCURLY .)
    CONTINUE        reduce using rule 24 (switchStatement -> SWITCH LPAREN value RPAREN LCURLY switchCases switchDefault RCURLY .)
    SEMICOLON       reduce using rule 24 (switchStatement -> SWITCH LPAREN value RPAREN LCURLY switchCases switchDefault RCURLY .)
    BREAK           reduce using rule 24 (switchStatement -> SWITCH LPAREN value RPAREN LCURLY switchCases switchDefault RCURLY .)


state 198

    (25) switchDefault -> DEFAULT COLON . programa
    (1) programa -> . cuerpo
    (2) programa -> . programa cuerpo
    (3) cuerpo -> . arithmeticExpression
    (4) cuerpo -> . if_elseStatement
    (5) cuerpo -> . forStatement
    (6) cuerpo -> . switchStatement
    (7) cuerpo -> . arrayAsignation
    (8) cuerpo -> . queueDeclaration
    (9) cuerpo -> . queueEnqueue
    (10) cuerpo -> . queueDequeue
    (11) cuerpo -> . defineFunction
    (12) cuerpo -> . anonymousFunction
    (13) cuerpo -> . arrowFunction
    (14) cuerpo -> . echo
    (15) cuerpo -> . fgets
    (16) cuerpo -> . stackDeclaration
    (17) cuerpo -> . stackPush
    (18) cuerpo -> . stackPop
    (19) cuerpo -> . line
    (20) cuerpo -> . print
    (21) cuerpo -> . logicalCondition
    (22) cuerpo -> . OPEN_TAG
    (23) cuerpo -> . CLOSE_TAG
    (69) arithmeticExpression -> . value
    (70) arithmeticExpression -> . arithmeticExpression arithmeticOperator arithmeticExpression
    (71) arithmeticExpression -> . LPAREN arithmeticExpression RPAREN
    (29) if_elseStatement -> . IF LPAREN logicalCondition RPAREN LCURLY ifStatementBody RCURLY ELSE ifStatementBody
    (30) if_elseStatement -> . IF LPAREN logicalCondition RPAREN LCURLY ifStatementBody
    (34) forStatement -> . FOR LPAREN forStatementCondition RPAREN LCURLY forStatementBody RCURLY
    (24) switchStatement -> . SWITCH LPAREN value RPAREN LCURLY switchCases switchDefault RCURLY
    (40) arrayAsignation -> . ID EQUAL arrayDeclaration SEMICOLON
    (51) queueDeclaration -> . ID EQUAL NEW QUEUE SEMICOLON
    (52) queueEnqueue -> . ID OBJOP PUSH LPAREN value RPAREN SEMICOLON
    (53) queueDequeue -> . ID OBJOP POP SEMICOLON
    (54) defineFunction -> . FUNCTION ID LPAREN arguments RPAREN LCURLY cuerpo RCURLY
    (55) defineFunction -> . FUNCTION ID LPAREN RPAREN LCURLY cuerpo RCURLY
    (58) anonymousFunction -> . FUNCTION LPAREN RPAREN LCURLY cuerpo RCURLY
    (59) anonymousFunction -> . FUNCTION LPAREN arguments RPAREN LCURLY cuerpo RCURLY
    (60) arrowFunction -> . FN LPAREN ID RPAREN FNARROW arrowBody SEMICOLON
    (63) echo -> . ECHO values SEMICOLON
    (68) fgets -> . ID EQUAL FGETS LPAREN STDIN RPAREN SEMICOLON
    (48) stackDeclaration -> . ID EQUAL NEW STACK SEMICOLON
    (49) stackPush -> . ID OBJOP PUSH LPAREN value RPAREN SEMICOLON
    (50) stackPop -> . ID OBJOP POP SEMICOLON
    (84) line -> . variableAsignation SEMICOLON
    (64) print -> . PRINT LPAREN values RPAREN SEMICOLON
    (65) print -> . PRINT value SEMICOLON
    (95) logicalCondition -> . comparingValue
    (96) logicalCondition -> . comparingValue conditionOperator comparingValue
    (97) logicalCondition -> . LPAREN logicalCondition RPAREN
    (72) value -> . ID
    (73) value -> . INTEGER
    (74) value -> . FLOAT
    (75) value -> . STRING
    (76) value -> . BOOL
    (77) value -> . NULL
    (85) variableAsignation -> . ID EQUAL value
    (86) variableAsignation -> . ID EQUAL arithmeticExpression
    (94) comparingValue -> . value comparingSign value

    OPEN_TAG        shift and go to state 22
    CLOSE_TAG       shift and go to state 23
    LPAREN          shift and go to state 25
    IF              shift and go to state 26
    FOR             shift and go to state 27
    SWITCH          shift and go to state 28
    ID              shift and go to state 29
    FUNCTION        shift and go to state 30
    FN              shift and go to state 31
    ECHO            shift and go to state 32
    PRINT           shift and go to state 34
    INTEGER         shift and go to state 36
    FLOAT           shift and go to state 37
    STRING          shift and go to state 38
    BOOL            shift and go to state 39
    NULL            shift and go to state 40

    programa                       shift and go to state 203
    cuerpo                         shift and go to state 2
    arithmeticExpression           shift and go to state 3
    if_elseStatement               shift and go to state 4
    forStatement                   shift and go to state 5
    switchStatement                shift and go to state 6
    arrayAsignation                shift and go to state 7
    queueDeclaration               shift and go to state 8
    queueEnqueue                   shift and go to state 9
    queueDequeue                   shift and go to state 10
    defineFunction                 shift and go to state 11
    anonymousFunction              shift and go to state 12
    arrowFunction                  shift and go to state 13
    echo                           shift and go to state 14
    fgets                          shift and go to state 15
    stackDeclaration               shift and go to state 16
    stackPush                      shift and go to state 17
    stackPop                       shift and go to state 18
    line                           shift and go to state 19
    print                          shift and go to state 20
    logicalCondition               shift and go to state 21
    value                          shift and go to state 24
    variableAsignation             shift and go to state 33
    comparingValue                 shift and go to state 35

state 199

    (26) switchCase -> CASE value COLON . programa BREAK SEMICOLON
    (1) programa -> . cuerpo
    (2) programa -> . programa cuerpo
    (3) cuerpo -> . arithmeticExpression
    (4) cuerpo -> . if_elseStatement
    (5) cuerpo -> . forStatement
    (6) cuerpo -> . switchStatement
    (7) cuerpo -> . arrayAsignation
    (8) cuerpo -> . queueDeclaration
    (9) cuerpo -> . queueEnqueue
    (10) cuerpo -> . queueDequeue
    (11) cuerpo -> . defineFunction
    (12) cuerpo -> . anonymousFunction
    (13) cuerpo -> . arrowFunction
    (14) cuerpo -> . echo
    (15) cuerpo -> . fgets
    (16) cuerpo -> . stackDeclaration
    (17) cuerpo -> . stackPush
    (18) cuerpo -> . stackPop
    (19) cuerpo -> . line
    (20) cuerpo -> . print
    (21) cuerpo -> . logicalCondition
    (22) cuerpo -> . OPEN_TAG
    (23) cuerpo -> . CLOSE_TAG
    (69) arithmeticExpression -> . value
    (70) arithmeticExpression -> . arithmeticExpression arithmeticOperator arithmeticExpression
    (71) arithmeticExpression -> . LPAREN arithmeticExpression RPAREN
    (29) if_elseStatement -> . IF LPAREN logicalCondition RPAREN LCURLY ifStatementBody RCURLY ELSE ifStatementBody
    (30) if_elseStatement -> . IF LPAREN logicalCondition RPAREN LCURLY ifStatementBody
    (34) forStatement -> . FOR LPAREN forStatementCondition RPAREN LCURLY forStatementBody RCURLY
    (24) switchStatement -> . SWITCH LPAREN value RPAREN LCURLY switchCases switchDefault RCURLY
    (40) arrayAsignation -> . ID EQUAL arrayDeclaration SEMICOLON
    (51) queueDeclaration -> . ID EQUAL NEW QUEUE SEMICOLON
    (52) queueEnqueue -> . ID OBJOP PUSH LPAREN value RPAREN SEMICOLON
    (53) queueDequeue -> . ID OBJOP POP SEMICOLON
    (54) defineFunction -> . FUNCTION ID LPAREN arguments RPAREN LCURLY cuerpo RCURLY
    (55) defineFunction -> . FUNCTION ID LPAREN RPAREN LCURLY cuerpo RCURLY
    (58) anonymousFunction -> . FUNCTION LPAREN RPAREN LCURLY cuerpo RCURLY
    (59) anonymousFunction -> . FUNCTION LPAREN arguments RPAREN LCURLY cuerpo RCURLY
    (60) arrowFunction -> . FN LPAREN ID RPAREN FNARROW arrowBody SEMICOLON
    (63) echo -> . ECHO values SEMICOLON
    (68) fgets -> . ID EQUAL FGETS LPAREN STDIN RPAREN SEMICOLON
    (48) stackDeclaration -> . ID EQUAL NEW STACK SEMICOLON
    (49) stackPush -> . ID OBJOP PUSH LPAREN value RPAREN SEMICOLON
    (50) stackPop -> . ID OBJOP POP SEMICOLON
    (84) line -> . variableAsignation SEMICOLON
    (64) print -> . PRINT LPAREN values RPAREN SEMICOLON
    (65) print -> . PRINT value SEMICOLON
    (95) logicalCondition -> . comparingValue
    (96) logicalCondition -> . comparingValue conditionOperator comparingValue
    (97) logicalCondition -> . LPAREN logicalCondition RPAREN
    (72) value -> . ID
    (73) value -> . INTEGER
    (74) value -> . FLOAT
    (75) value -> . STRING
    (76) value -> . BOOL
    (77) value -> . NULL
    (85) variableAsignation -> . ID EQUAL value
    (86) variableAsignation -> . ID EQUAL arithmeticExpression
    (94) comparingValue -> . value comparingSign value

    OPEN_TAG        shift and go to state 22
    CLOSE_TAG       shift and go to state 23
    LPAREN          shift and go to state 25
    IF              shift and go to state 26
    FOR             shift and go to state 27
    SWITCH          shift and go to state 28
    ID              shift and go to state 29
    FUNCTION        shift and go to state 30
    FN              shift and go to state 31
    ECHO            shift and go to state 32
    PRINT           shift and go to state 34
    INTEGER         shift and go to state 36
    FLOAT           shift and go to state 37
    STRING          shift and go to state 38
    BOOL            shift and go to state 39
    NULL            shift and go to state 40

    value                          shift and go to state 24
    programa                       shift and go to state 204
    cuerpo                         shift and go to state 2
    arithmeticExpression           shift and go to state 3
    if_elseStatement               shift and go to state 4
    forStatement                   shift and go to state 5
    switchStatement                shift and go to state 6
    arrayAsignation                shift and go to state 7
    queueDeclaration               shift and go to state 8
    queueEnqueue                   shift and go to state 9
    queueDequeue                   shift and go to state 10
    defineFunction                 shift and go to state 11
    anonymousFunction              shift and go to state 12
    arrowFunction                  shift and go to state 13
    echo                           shift and go to state 14
    fgets                          shift and go to state 15
    stackDeclaration               shift and go to state 16
    stackPush                      shift and go to state 17
    stackPop                       shift and go to state 18
    line                           shift and go to state 19
    print                          shift and go to state 20
    logicalCondition               shift and go to state 21
    variableAsignation             shift and go to state 33
    comparingValue                 shift and go to state 35

state 200

    (54) defineFunction -> FUNCTION ID LPAREN arguments RPAREN LCURLY cuerpo RCURLY .

    OPEN_TAG        reduce using rule 54 (defineFunction -> FUNCTION ID LPAREN arguments RPAREN LCURLY cuerpo RCURLY .)
    CLOSE_TAG       reduce using rule 54 (defineFunction -> FUNCTION ID LPAREN arguments RPAREN LCURLY cuerpo RCURLY .)
    LPAREN          reduce using rule 54 (defineFunction -> FUNCTION ID LPAREN arguments RPAREN LCURLY cuerpo RCURLY .)
    IF              reduce using rule 54 (defineFunction -> FUNCTION ID LPAREN arguments RPAREN LCURLY cuerpo RCURLY .)
    FOR             reduce using rule 54 (defineFunction -> FUNCTION ID LPAREN arguments RPAREN LCURLY cuerpo RCURLY .)
    SWITCH          reduce using rule 54 (defineFunction -> FUNCTION ID LPAREN arguments RPAREN LCURLY cuerpo RCURLY .)
    ID              reduce using rule 54 (defineFunction -> FUNCTION ID LPAREN arguments RPAREN LCURLY cuerpo RCURLY .)
    FUNCTION        reduce using rule 54 (defineFunction -> FUNCTION ID LPAREN arguments RPAREN LCURLY cuerpo RCURLY .)
    FN              reduce using rule 54 (defineFunction -> FUNCTION ID LPAREN arguments RPAREN LCURLY cuerpo RCURLY .)
    ECHO            reduce using rule 54 (defineFunction -> FUNCTION ID LPAREN arguments RPAREN LCURLY cuerpo RCURLY .)
    PRINT           reduce using rule 54 (defineFunction -> FUNCTION ID LPAREN arguments RPAREN LCURLY cuerpo RCURLY .)
    INTEGER         reduce using rule 54 (defineFunction -> FUNCTION ID LPAREN arguments RPAREN LCURLY cuerpo RCURLY .)
    FLOAT           reduce using rule 54 (defineFunction -> FUNCTION ID LPAREN arguments RPAREN LCURLY cuerpo RCURLY .)
    STRING          reduce using rule 54 (defineFunction -> FUNCTION ID LPAREN arguments RPAREN LCURLY cuerpo RCURLY .)
    BOOL            reduce using rule 54 (defineFunction -> FUNCTION ID LPAREN arguments RPAREN LCURLY cuerpo RCURLY .)
    NULL            reduce using rule 54 (defineFunction -> FUNCTION ID LPAREN arguments RPAREN LCURLY cuerpo RCURLY .)
    $end            reduce using rule 54 (defineFunction -> FUNCTION ID LPAREN arguments RPAREN LCURLY cuerpo RCURLY .)
    RCURLY          reduce using rule 54 (defineFunction -> FUNCTION ID LPAREN arguments RPAREN LCURLY cuerpo RCURLY .)
    CONTINUE        reduce using rule 54 (defineFunction -> FUNCTION ID LPAREN arguments RPAREN LCURLY cuerpo RCURLY .)
    SEMICOLON       reduce using rule 54 (defineFunction -> FUNCTION ID LPAREN arguments RPAREN LCURLY cuerpo RCURLY .)
    BREAK           reduce using rule 54 (defineFunction -> FUNCTION ID LPAREN arguments RPAREN LCURLY cuerpo RCURLY .)


state 201

    (61) arrowBody -> FN LPAREN ID . RPAREN FNARROW arrowBody
    (60) arrowFunction -> FN LPAREN ID . RPAREN FNARROW arrowBody SEMICOLON

    RPAREN          shift and go to state 205


state 202

    (29) if_elseStatement -> IF LPAREN logicalCondition RPAREN LCURLY ifStatementBody RCURLY ELSE ifStatementBody .
    (33) ifStatementBody -> ifStatementBody . cuerpo
    (3) cuerpo -> . arithmeticExpression
    (4) cuerpo -> . if_elseStatement
    (5) cuerpo -> . forStatement
    (6) cuerpo -> . switchStatement
    (7) cuerpo -> . arrayAsignation
    (8) cuerpo -> . queueDeclaration
    (9) cuerpo -> . queueEnqueue
    (10) cuerpo -> . queueDequeue
    (11) cuerpo -> . defineFunction
    (12) cuerpo -> . anonymousFunction
    (13) cuerpo -> . arrowFunction
    (14) cuerpo -> . echo
    (15) cuerpo -> . fgets
    (16) cuerpo -> . stackDeclaration
    (17) cuerpo -> . stackPush
    (18) cuerpo -> . stackPop
    (19) cuerpo -> . line
    (20) cuerpo -> . print
    (21) cuerpo -> . logicalCondition
    (22) cuerpo -> . OPEN_TAG
    (23) cuerpo -> . CLOSE_TAG
    (69) arithmeticExpression -> . value
    (70) arithmeticExpression -> . arithmeticExpression arithmeticOperator arithmeticExpression
    (71) arithmeticExpression -> . LPAREN arithmeticExpression RPAREN
    (29) if_elseStatement -> . IF LPAREN logicalCondition RPAREN LCURLY ifStatementBody RCURLY ELSE ifStatementBody
    (30) if_elseStatement -> . IF LPAREN logicalCondition RPAREN LCURLY ifStatementBody
    (34) forStatement -> . FOR LPAREN forStatementCondition RPAREN LCURLY forStatementBody RCURLY
    (24) switchStatement -> . SWITCH LPAREN value RPAREN LCURLY switchCases switchDefault RCURLY
    (40) arrayAsignation -> . ID EQUAL arrayDeclaration SEMICOLON
    (51) queueDeclaration -> . ID EQUAL NEW QUEUE SEMICOLON
    (52) queueEnqueue -> . ID OBJOP PUSH LPAREN value RPAREN SEMICOLON
    (53) queueDequeue -> . ID OBJOP POP SEMICOLON
    (54) defineFunction -> . FUNCTION ID LPAREN arguments RPAREN LCURLY cuerpo RCURLY
    (55) defineFunction -> . FUNCTION ID LPAREN RPAREN LCURLY cuerpo RCURLY
    (58) anonymousFunction -> . FUNCTION LPAREN RPAREN LCURLY cuerpo RCURLY
    (59) anonymousFunction -> . FUNCTION LPAREN arguments RPAREN LCURLY cuerpo RCURLY
    (60) arrowFunction -> . FN LPAREN ID RPAREN FNARROW arrowBody SEMICOLON
    (63) echo -> . ECHO values SEMICOLON
    (68) fgets -> . ID EQUAL FGETS LPAREN STDIN RPAREN SEMICOLON
    (48) stackDeclaration -> . ID EQUAL NEW STACK SEMICOLON
    (49) stackPush -> . ID OBJOP PUSH LPAREN value RPAREN SEMICOLON
    (50) stackPop -> . ID OBJOP POP SEMICOLON
    (84) line -> . variableAsignation SEMICOLON
    (64) print -> . PRINT LPAREN values RPAREN SEMICOLON
    (65) print -> . PRINT value SEMICOLON
    (95) logicalCondition -> . comparingValue
    (96) logicalCondition -> . comparingValue conditionOperator comparingValue
    (97) logicalCondition -> . LPAREN logicalCondition RPAREN
    (72) value -> . ID
    (73) value -> . INTEGER
    (74) value -> . FLOAT
    (75) value -> . STRING
    (76) value -> . BOOL
    (77) value -> . NULL
    (85) variableAsignation -> . ID EQUAL value
    (86) variableAsignation -> . ID EQUAL arithmeticExpression
    (94) comparingValue -> . value comparingSign value

  ! shift/reduce conflict for OPEN_TAG resolved as shift
  ! shift/reduce conflict for CLOSE_TAG resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for SWITCH resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for FUNCTION resolved as shift
  ! shift/reduce conflict for FN resolved as shift
  ! shift/reduce conflict for ECHO resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for BOOL resolved as shift
  ! shift/reduce conflict for NULL resolved as shift
    $end            reduce using rule 29 (if_elseStatement -> IF LPAREN logicalCondition RPAREN LCURLY ifStatementBody RCURLY ELSE ifStatementBody .)
    RCURLY          reduce using rule 29 (if_elseStatement -> IF LPAREN logicalCondition RPAREN LCURLY ifStatementBody RCURLY ELSE ifStatementBody .)
    CONTINUE        reduce using rule 29 (if_elseStatement -> IF LPAREN logicalCondition RPAREN LCURLY ifStatementBody RCURLY ELSE ifStatementBody .)
    SEMICOLON       reduce using rule 29 (if_elseStatement -> IF LPAREN logicalCondition RPAREN LCURLY ifStatementBody RCURLY ELSE ifStatementBody .)
    BREAK           reduce using rule 29 (if_elseStatement -> IF LPAREN logicalCondition RPAREN LCURLY ifStatementBody RCURLY ELSE ifStatementBody .)
    OPEN_TAG        shift and go to state 22
    CLOSE_TAG       shift and go to state 23
    LPAREN          shift and go to state 25
    IF              shift and go to state 26
    FOR             shift and go to state 27
    SWITCH          shift and go to state 28
    ID              shift and go to state 29
    FUNCTION        shift and go to state 30
    FN              shift and go to state 31
    ECHO            shift and go to state 32
    PRINT           shift and go to state 34
    INTEGER         shift and go to state 36
    FLOAT           shift and go to state 37
    STRING          shift and go to state 38
    BOOL            shift and go to state 39
    NULL            shift and go to state 40

  ! OPEN_TAG        [ reduce using rule 29 (if_elseStatement -> IF LPAREN logicalCondition RPAREN LCURLY ifStatementBody RCURLY ELSE ifStatementBody .) ]
  ! CLOSE_TAG       [ reduce using rule 29 (if_elseStatement -> IF LPAREN logicalCondition RPAREN LCURLY ifStatementBody RCURLY ELSE ifStatementBody .) ]
  ! LPAREN          [ reduce using rule 29 (if_elseStatement -> IF LPAREN logicalCondition RPAREN LCURLY ifStatementBody RCURLY ELSE ifStatementBody .) ]
  ! IF              [ reduce using rule 29 (if_elseStatement -> IF LPAREN logicalCondition RPAREN LCURLY ifStatementBody RCURLY ELSE ifStatementBody .) ]
  ! FOR             [ reduce using rule 29 (if_elseStatement -> IF LPAREN logicalCondition RPAREN LCURLY ifStatementBody RCURLY ELSE ifStatementBody .) ]
  ! SWITCH          [ reduce using rule 29 (if_elseStatement -> IF LPAREN logicalCondition RPAREN LCURLY ifStatementBody RCURLY ELSE ifStatementBody .) ]
  ! ID              [ reduce using rule 29 (if_elseStatement -> IF LPAREN logicalCondition RPAREN LCURLY ifStatementBody RCURLY ELSE ifStatementBody .) ]
  ! FUNCTION        [ reduce using rule 29 (if_elseStatement -> IF LPAREN logicalCondition RPAREN LCURLY ifStatementBody RCURLY ELSE ifStatementBody .) ]
  ! FN              [ reduce using rule 29 (if_elseStatement -> IF LPAREN logicalCondition RPAREN LCURLY ifStatementBody RCURLY ELSE ifStatementBody .) ]
  ! ECHO            [ reduce using rule 29 (if_elseStatement -> IF LPAREN logicalCondition RPAREN LCURLY ifStatementBody RCURLY ELSE ifStatementBody .) ]
  ! PRINT           [ reduce using rule 29 (if_elseStatement -> IF LPAREN logicalCondition RPAREN LCURLY ifStatementBody RCURLY ELSE ifStatementBody .) ]
  ! INTEGER         [ reduce using rule 29 (if_elseStatement -> IF LPAREN logicalCondition RPAREN LCURLY ifStatementBody RCURLY ELSE ifStatementBody .) ]
  ! FLOAT           [ reduce using rule 29 (if_elseStatement -> IF LPAREN logicalCondition RPAREN LCURLY ifStatementBody RCURLY ELSE ifStatementBody .) ]
  ! STRING          [ reduce using rule 29 (if_elseStatement -> IF LPAREN logicalCondition RPAREN LCURLY ifStatementBody RCURLY ELSE ifStatementBody .) ]
  ! BOOL            [ reduce using rule 29 (if_elseStatement -> IF LPAREN logicalCondition RPAREN LCURLY ifStatementBody RCURLY ELSE ifStatementBody .) ]
  ! NULL            [ reduce using rule 29 (if_elseStatement -> IF LPAREN logicalCondition RPAREN LCURLY ifStatementBody RCURLY ELSE ifStatementBody .) ]

    logicalCondition               shift and go to state 21
    cuerpo                         shift and go to state 179
    arithmeticExpression           shift and go to state 3
    if_elseStatement               shift and go to state 4
    forStatement                   shift and go to state 5
    switchStatement                shift and go to state 6
    arrayAsignation                shift and go to state 7
    queueDeclaration               shift and go to state 8
    queueEnqueue                   shift and go to state 9
    queueDequeue                   shift and go to state 10
    defineFunction                 shift and go to state 11
    anonymousFunction              shift and go to state 12
    arrowFunction                  shift and go to state 13
    echo                           shift and go to state 14
    fgets                          shift and go to state 15
    stackDeclaration               shift and go to state 16
    stackPush                      shift and go to state 17
    stackPop                       shift and go to state 18
    line                           shift and go to state 19
    print                          shift and go to state 20
    value                          shift and go to state 24
    variableAsignation             shift and go to state 33
    comparingValue                 shift and go to state 35

state 203

    (25) switchDefault -> DEFAULT COLON programa .
    (2) programa -> programa . cuerpo
    (3) cuerpo -> . arithmeticExpression
    (4) cuerpo -> . if_elseStatement
    (5) cuerpo -> . forStatement
    (6) cuerpo -> . switchStatement
    (7) cuerpo -> . arrayAsignation
    (8) cuerpo -> . queueDeclaration
    (9) cuerpo -> . queueEnqueue
    (10) cuerpo -> . queueDequeue
    (11) cuerpo -> . defineFunction
    (12) cuerpo -> . anonymousFunction
    (13) cuerpo -> . arrowFunction
    (14) cuerpo -> . echo
    (15) cuerpo -> . fgets
    (16) cuerpo -> . stackDeclaration
    (17) cuerpo -> . stackPush
    (18) cuerpo -> . stackPop
    (19) cuerpo -> . line
    (20) cuerpo -> . print
    (21) cuerpo -> . logicalCondition
    (22) cuerpo -> . OPEN_TAG
    (23) cuerpo -> . CLOSE_TAG
    (69) arithmeticExpression -> . value
    (70) arithmeticExpression -> . arithmeticExpression arithmeticOperator arithmeticExpression
    (71) arithmeticExpression -> . LPAREN arithmeticExpression RPAREN
    (29) if_elseStatement -> . IF LPAREN logicalCondition RPAREN LCURLY ifStatementBody RCURLY ELSE ifStatementBody
    (30) if_elseStatement -> . IF LPAREN logicalCondition RPAREN LCURLY ifStatementBody
    (34) forStatement -> . FOR LPAREN forStatementCondition RPAREN LCURLY forStatementBody RCURLY
    (24) switchStatement -> . SWITCH LPAREN value RPAREN LCURLY switchCases switchDefault RCURLY
    (40) arrayAsignation -> . ID EQUAL arrayDeclaration SEMICOLON
    (51) queueDeclaration -> . ID EQUAL NEW QUEUE SEMICOLON
    (52) queueEnqueue -> . ID OBJOP PUSH LPAREN value RPAREN SEMICOLON
    (53) queueDequeue -> . ID OBJOP POP SEMICOLON
    (54) defineFunction -> . FUNCTION ID LPAREN arguments RPAREN LCURLY cuerpo RCURLY
    (55) defineFunction -> . FUNCTION ID LPAREN RPAREN LCURLY cuerpo RCURLY
    (58) anonymousFunction -> . FUNCTION LPAREN RPAREN LCURLY cuerpo RCURLY
    (59) anonymousFunction -> . FUNCTION LPAREN arguments RPAREN LCURLY cuerpo RCURLY
    (60) arrowFunction -> . FN LPAREN ID RPAREN FNARROW arrowBody SEMICOLON
    (63) echo -> . ECHO values SEMICOLON
    (68) fgets -> . ID EQUAL FGETS LPAREN STDIN RPAREN SEMICOLON
    (48) stackDeclaration -> . ID EQUAL NEW STACK SEMICOLON
    (49) stackPush -> . ID OBJOP PUSH LPAREN value RPAREN SEMICOLON
    (50) stackPop -> . ID OBJOP POP SEMICOLON
    (84) line -> . variableAsignation SEMICOLON
    (64) print -> . PRINT LPAREN values RPAREN SEMICOLON
    (65) print -> . PRINT value SEMICOLON
    (95) logicalCondition -> . comparingValue
    (96) logicalCondition -> . comparingValue conditionOperator comparingValue
    (97) logicalCondition -> . LPAREN logicalCondition RPAREN
    (72) value -> . ID
    (73) value -> . INTEGER
    (74) value -> . FLOAT
    (75) value -> . STRING
    (76) value -> . BOOL
    (77) value -> . NULL
    (85) variableAsignation -> . ID EQUAL value
    (86) variableAsignation -> . ID EQUAL arithmeticExpression
    (94) comparingValue -> . value comparingSign value

    RCURLY          reduce using rule 25 (switchDefault -> DEFAULT COLON programa .)
    OPEN_TAG        shift and go to state 22
    CLOSE_TAG       shift and go to state 23
    LPAREN          shift and go to state 25
    IF              shift and go to state 26
    FOR             shift and go to state 27
    SWITCH          shift and go to state 28
    ID              shift and go to state 29
    FUNCTION        shift and go to state 30
    FN              shift and go to state 31
    ECHO            shift and go to state 32
    PRINT           shift and go to state 34
    INTEGER         shift and go to state 36
    FLOAT           shift and go to state 37
    STRING          shift and go to state 38
    BOOL            shift and go to state 39
    NULL            shift and go to state 40

    cuerpo                         shift and go to state 41
    arithmeticExpression           shift and go to state 3
    if_elseStatement               shift and go to state 4
    forStatement                   shift and go to state 5
    switchStatement                shift and go to state 6
    arrayAsignation                shift and go to state 7
    queueDeclaration               shift and go to state 8
    queueEnqueue                   shift and go to state 9
    queueDequeue                   shift and go to state 10
    defineFunction                 shift and go to state 11
    anonymousFunction              shift and go to state 12
    arrowFunction                  shift and go to state 13
    echo                           shift and go to state 14
    fgets                          shift and go to state 15
    stackDeclaration               shift and go to state 16
    stackPush                      shift and go to state 17
    stackPop                       shift and go to state 18
    line                           shift and go to state 19
    print                          shift and go to state 20
    logicalCondition               shift and go to state 21
    value                          shift and go to state 24
    variableAsignation             shift and go to state 33
    comparingValue                 shift and go to state 35

state 204

    (26) switchCase -> CASE value COLON programa . BREAK SEMICOLON
    (2) programa -> programa . cuerpo
    (3) cuerpo -> . arithmeticExpression
    (4) cuerpo -> . if_elseStatement
    (5) cuerpo -> . forStatement
    (6) cuerpo -> . switchStatement
    (7) cuerpo -> . arrayAsignation
    (8) cuerpo -> . queueDeclaration
    (9) cuerpo -> . queueEnqueue
    (10) cuerpo -> . queueDequeue
    (11) cuerpo -> . defineFunction
    (12) cuerpo -> . anonymousFunction
    (13) cuerpo -> . arrowFunction
    (14) cuerpo -> . echo
    (15) cuerpo -> . fgets
    (16) cuerpo -> . stackDeclaration
    (17) cuerpo -> . stackPush
    (18) cuerpo -> . stackPop
    (19) cuerpo -> . line
    (20) cuerpo -> . print
    (21) cuerpo -> . logicalCondition
    (22) cuerpo -> . OPEN_TAG
    (23) cuerpo -> . CLOSE_TAG
    (69) arithmeticExpression -> . value
    (70) arithmeticExpression -> . arithmeticExpression arithmeticOperator arithmeticExpression
    (71) arithmeticExpression -> . LPAREN arithmeticExpression RPAREN
    (29) if_elseStatement -> . IF LPAREN logicalCondition RPAREN LCURLY ifStatementBody RCURLY ELSE ifStatementBody
    (30) if_elseStatement -> . IF LPAREN logicalCondition RPAREN LCURLY ifStatementBody
    (34) forStatement -> . FOR LPAREN forStatementCondition RPAREN LCURLY forStatementBody RCURLY
    (24) switchStatement -> . SWITCH LPAREN value RPAREN LCURLY switchCases switchDefault RCURLY
    (40) arrayAsignation -> . ID EQUAL arrayDeclaration SEMICOLON
    (51) queueDeclaration -> . ID EQUAL NEW QUEUE SEMICOLON
    (52) queueEnqueue -> . ID OBJOP PUSH LPAREN value RPAREN SEMICOLON
    (53) queueDequeue -> . ID OBJOP POP SEMICOLON
    (54) defineFunction -> . FUNCTION ID LPAREN arguments RPAREN LCURLY cuerpo RCURLY
    (55) defineFunction -> . FUNCTION ID LPAREN RPAREN LCURLY cuerpo RCURLY
    (58) anonymousFunction -> . FUNCTION LPAREN RPAREN LCURLY cuerpo RCURLY
    (59) anonymousFunction -> . FUNCTION LPAREN arguments RPAREN LCURLY cuerpo RCURLY
    (60) arrowFunction -> . FN LPAREN ID RPAREN FNARROW arrowBody SEMICOLON
    (63) echo -> . ECHO values SEMICOLON
    (68) fgets -> . ID EQUAL FGETS LPAREN STDIN RPAREN SEMICOLON
    (48) stackDeclaration -> . ID EQUAL NEW STACK SEMICOLON
    (49) stackPush -> . ID OBJOP PUSH LPAREN value RPAREN SEMICOLON
    (50) stackPop -> . ID OBJOP POP SEMICOLON
    (84) line -> . variableAsignation SEMICOLON
    (64) print -> . PRINT LPAREN values RPAREN SEMICOLON
    (65) print -> . PRINT value SEMICOLON
    (95) logicalCondition -> . comparingValue
    (96) logicalCondition -> . comparingValue conditionOperator comparingValue
    (97) logicalCondition -> . LPAREN logicalCondition RPAREN
    (72) value -> . ID
    (73) value -> . INTEGER
    (74) value -> . FLOAT
    (75) value -> . STRING
    (76) value -> . BOOL
    (77) value -> . NULL
    (85) variableAsignation -> . ID EQUAL value
    (86) variableAsignation -> . ID EQUAL arithmeticExpression
    (94) comparingValue -> . value comparingSign value

    BREAK           shift and go to state 206
    OPEN_TAG        shift and go to state 22
    CLOSE_TAG       shift and go to state 23
    LPAREN          shift and go to state 25
    IF              shift and go to state 26
    FOR             shift and go to state 27
    SWITCH          shift and go to state 28
    ID              shift and go to state 29
    FUNCTION        shift and go to state 30
    FN              shift and go to state 31
    ECHO            shift and go to state 32
    PRINT           shift and go to state 34
    INTEGER         shift and go to state 36
    FLOAT           shift and go to state 37
    STRING          shift and go to state 38
    BOOL            shift and go to state 39
    NULL            shift and go to state 40

    value                          shift and go to state 24
    cuerpo                         shift and go to state 41
    arithmeticExpression           shift and go to state 3
    if_elseStatement               shift and go to state 4
    forStatement                   shift and go to state 5
    switchStatement                shift and go to state 6
    arrayAsignation                shift and go to state 7
    queueDeclaration               shift and go to state 8
    queueEnqueue                   shift and go to state 9
    queueDequeue                   shift and go to state 10
    defineFunction                 shift and go to state 11
    anonymousFunction              shift and go to state 12
    arrowFunction                  shift and go to state 13
    echo                           shift and go to state 14
    fgets                          shift and go to state 15
    stackDeclaration               shift and go to state 16
    stackPush                      shift and go to state 17
    stackPop                       shift and go to state 18
    line                           shift and go to state 19
    print                          shift and go to state 20
    logicalCondition               shift and go to state 21
    variableAsignation             shift and go to state 33
    comparingValue                 shift and go to state 35

state 205

    (61) arrowBody -> FN LPAREN ID RPAREN . FNARROW arrowBody
    (60) arrowFunction -> FN LPAREN ID RPAREN . FNARROW arrowBody SEMICOLON

    FNARROW         shift and go to state 207


state 206

    (26) switchCase -> CASE value COLON programa BREAK . SEMICOLON

    SEMICOLON       shift and go to state 208


state 207

    (61) arrowBody -> FN LPAREN ID RPAREN FNARROW . arrowBody
    (60) arrowFunction -> FN LPAREN ID RPAREN FNARROW . arrowBody SEMICOLON
    (61) arrowBody -> . FN LPAREN ID RPAREN FNARROW arrowBody
    (62) arrowBody -> . cuerpo
    (3) cuerpo -> . arithmeticExpression
    (4) cuerpo -> . if_elseStatement
    (5) cuerpo -> . forStatement
    (6) cuerpo -> . switchStatement
    (7) cuerpo -> . arrayAsignation
    (8) cuerpo -> . queueDeclaration
    (9) cuerpo -> . queueEnqueue
    (10) cuerpo -> . queueDequeue
    (11) cuerpo -> . defineFunction
    (12) cuerpo -> . anonymousFunction
    (13) cuerpo -> . arrowFunction
    (14) cuerpo -> . echo
    (15) cuerpo -> . fgets
    (16) cuerpo -> . stackDeclaration
    (17) cuerpo -> . stackPush
    (18) cuerpo -> . stackPop
    (19) cuerpo -> . line
    (20) cuerpo -> . print
    (21) cuerpo -> . logicalCondition
    (22) cuerpo -> . OPEN_TAG
    (23) cuerpo -> . CLOSE_TAG
    (69) arithmeticExpression -> . value
    (70) arithmeticExpression -> . arithmeticExpression arithmeticOperator arithmeticExpression
    (71) arithmeticExpression -> . LPAREN arithmeticExpression RPAREN
    (29) if_elseStatement -> . IF LPAREN logicalCondition RPAREN LCURLY ifStatementBody RCURLY ELSE ifStatementBody
    (30) if_elseStatement -> . IF LPAREN logicalCondition RPAREN LCURLY ifStatementBody
    (34) forStatement -> . FOR LPAREN forStatementCondition RPAREN LCURLY forStatementBody RCURLY
    (24) switchStatement -> . SWITCH LPAREN value RPAREN LCURLY switchCases switchDefault RCURLY
    (40) arrayAsignation -> . ID EQUAL arrayDeclaration SEMICOLON
    (51) queueDeclaration -> . ID EQUAL NEW QUEUE SEMICOLON
    (52) queueEnqueue -> . ID OBJOP PUSH LPAREN value RPAREN SEMICOLON
    (53) queueDequeue -> . ID OBJOP POP SEMICOLON
    (54) defineFunction -> . FUNCTION ID LPAREN arguments RPAREN LCURLY cuerpo RCURLY
    (55) defineFunction -> . FUNCTION ID LPAREN RPAREN LCURLY cuerpo RCURLY
    (58) anonymousFunction -> . FUNCTION LPAREN RPAREN LCURLY cuerpo RCURLY
    (59) anonymousFunction -> . FUNCTION LPAREN arguments RPAREN LCURLY cuerpo RCURLY
    (60) arrowFunction -> . FN LPAREN ID RPAREN FNARROW arrowBody SEMICOLON
    (63) echo -> . ECHO values SEMICOLON
    (68) fgets -> . ID EQUAL FGETS LPAREN STDIN RPAREN SEMICOLON
    (48) stackDeclaration -> . ID EQUAL NEW STACK SEMICOLON
    (49) stackPush -> . ID OBJOP PUSH LPAREN value RPAREN SEMICOLON
    (50) stackPop -> . ID OBJOP POP SEMICOLON
    (84) line -> . variableAsignation SEMICOLON
    (64) print -> . PRINT LPAREN values RPAREN SEMICOLON
    (65) print -> . PRINT value SEMICOLON
    (95) logicalCondition -> . comparingValue
    (96) logicalCondition -> . comparingValue conditionOperator comparingValue
    (97) logicalCondition -> . LPAREN logicalCondition RPAREN
    (72) value -> . ID
    (73) value -> . INTEGER
    (74) value -> . FLOAT
    (75) value -> . STRING
    (76) value -> . BOOL
    (77) value -> . NULL
    (85) variableAsignation -> . ID EQUAL value
    (86) variableAsignation -> . ID EQUAL arithmeticExpression
    (94) comparingValue -> . value comparingSign value

    FN              shift and go to state 175
    OPEN_TAG        shift and go to state 22
    CLOSE_TAG       shift and go to state 23
    LPAREN          shift and go to state 25
    IF              shift and go to state 26
    FOR             shift and go to state 27
    SWITCH          shift and go to state 28
    ID              shift and go to state 29
    FUNCTION        shift and go to state 30
    ECHO            shift and go to state 32
    PRINT           shift and go to state 34
    INTEGER         shift and go to state 36
    FLOAT           shift and go to state 37
    STRING          shift and go to state 38
    BOOL            shift and go to state 39
    NULL            shift and go to state 40

    arrowBody                      shift and go to state 209
    cuerpo                         shift and go to state 177
    arithmeticExpression           shift and go to state 3
    if_elseStatement               shift and go to state 4
    forStatement                   shift and go to state 5
    switchStatement                shift and go to state 6
    arrayAsignation                shift and go to state 7
    queueDeclaration               shift and go to state 8
    queueEnqueue                   shift and go to state 9
    queueDequeue                   shift and go to state 10
    defineFunction                 shift and go to state 11
    anonymousFunction              shift and go to state 12
    arrowFunction                  shift and go to state 13
    echo                           shift and go to state 14
    fgets                          shift and go to state 15
    stackDeclaration               shift and go to state 16
    stackPush                      shift and go to state 17
    stackPop                       shift and go to state 18
    line                           shift and go to state 19
    print                          shift and go to state 20
    logicalCondition               shift and go to state 21
    value                          shift and go to state 24
    variableAsignation             shift and go to state 33
    comparingValue                 shift and go to state 35

state 208

    (26) switchCase -> CASE value COLON programa BREAK SEMICOLON .

    DEFAULT         reduce using rule 26 (switchCase -> CASE value COLON programa BREAK SEMICOLON .)
    CASE            reduce using rule 26 (switchCase -> CASE value COLON programa BREAK SEMICOLON .)


state 209

    (61) arrowBody -> FN LPAREN ID RPAREN FNARROW arrowBody .
    (60) arrowFunction -> FN LPAREN ID RPAREN FNARROW arrowBody . SEMICOLON

  ! shift/reduce conflict for SEMICOLON resolved as shift
    SEMICOLON       shift and go to state 194

  ! SEMICOLON       [ reduce using rule 61 (arrowBody -> FN LPAREN ID RPAREN FNARROW arrowBody .) ]

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for PLUS in state 77 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 77 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 77 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 77 resolved as shift
WARNING: shift/reduce conflict for MOD in state 77 resolved as shift
WARNING: shift/reduce conflict for EXP in state 77 resolved as shift
WARNING: shift/reduce conflict for RCURLY in state 159 resolved as shift
WARNING: shift/reduce conflict for OPEN_TAG in state 159 resolved as shift
WARNING: shift/reduce conflict for CLOSE_TAG in state 159 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 159 resolved as shift
WARNING: shift/reduce conflict for IF in state 159 resolved as shift
WARNING: shift/reduce conflict for FOR in state 159 resolved as shift
WARNING: shift/reduce conflict for SWITCH in state 159 resolved as shift
WARNING: shift/reduce conflict for ID in state 159 resolved as shift
WARNING: shift/reduce conflict for FUNCTION in state 159 resolved as shift
WARNING: shift/reduce conflict for FN in state 159 resolved as shift
WARNING: shift/reduce conflict for ECHO in state 159 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 159 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 159 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 159 resolved as shift
WARNING: shift/reduce conflict for STRING in state 159 resolved as shift
WARNING: shift/reduce conflict for BOOL in state 159 resolved as shift
WARNING: shift/reduce conflict for NULL in state 159 resolved as shift
WARNING: shift/reduce conflict for CONTINUE in state 160 resolved as shift
WARNING: shift/reduce conflict for OPEN_TAG in state 202 resolved as shift
WARNING: shift/reduce conflict for CLOSE_TAG in state 202 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 202 resolved as shift
WARNING: shift/reduce conflict for IF in state 202 resolved as shift
WARNING: shift/reduce conflict for FOR in state 202 resolved as shift
WARNING: shift/reduce conflict for SWITCH in state 202 resolved as shift
WARNING: shift/reduce conflict for ID in state 202 resolved as shift
WARNING: shift/reduce conflict for FUNCTION in state 202 resolved as shift
WARNING: shift/reduce conflict for FN in state 202 resolved as shift
WARNING: shift/reduce conflict for ECHO in state 202 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 202 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 202 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 202 resolved as shift
WARNING: shift/reduce conflict for STRING in state 202 resolved as shift
WARNING: shift/reduce conflict for BOOL in state 202 resolved as shift
WARNING: shift/reduce conflict for NULL in state 202 resolved as shift
WARNING: shift/reduce conflict for SEMICOLON in state 209 resolved as shift
WARNING: reduce/reduce conflict in state 94 resolved using rule (arithmeticExpression -> value)
WARNING: rejected rule (variableAsignation -> ID EQUAL value) in state 94
WARNING: reduce/reduce conflict in state 129 resolved using rule (stackPop -> ID OBJOP POP SEMICOLON)
WARNING: rejected rule (queueDequeue -> ID OBJOP POP SEMICOLON) in state 129
WARNING: reduce/reduce conflict in state 189 resolved using rule (stackPush -> ID OBJOP PUSH LPAREN value RPAREN SEMICOLON)
WARNING: rejected rule (queueEnqueue -> ID OBJOP PUSH LPAREN value RPAREN SEMICOLON) in state 189
WARNING: Rule (variableAsignation -> ID EQUAL value) is never reduced
WARNING: Rule (queueDequeue -> ID OBJOP POP SEMICOLON) is never reduced
WARNING: Rule (queueEnqueue -> ID OBJOP PUSH LPAREN value RPAREN SEMICOLON) is never reduced
