Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    ABSTRACT
    BITAND
    BITNOT
    BITOR
    BOOL
    CONCATASSIGN
    DIVIDEASSIGN
    DOC_COMMENT
    DOUBLEQUOTE
    ERRORCONTROL
    EXECUTION
    EXPASSIGN
    LOGICALNOT
    MINUSASSIGN
    MODASSIGN
    NULL
    PLUSASSIGN
    QUOTE
    TIMESASSIGN

Grammar

Rule 0     S' -> programa
Rule 1     programa -> cuerpo
Rule 2     programa -> programa cuerpo
Rule 3     cuerpo -> arithmeticExpression
Rule 4     cuerpo -> if_elseStatement
Rule 5     cuerpo -> forStatement
Rule 6     cuerpo -> switchStatement
Rule 7     cuerpo -> arrayAsignation
Rule 8     cuerpo -> queueDeclaration
Rule 9     cuerpo -> queueEnqueue
Rule 10    cuerpo -> queueDequeue
Rule 11    cuerpo -> defineFunction
Rule 12    cuerpo -> anonymousFunction
Rule 13    cuerpo -> arrowFunction
Rule 14    cuerpo -> echo
Rule 15    cuerpo -> fgets
Rule 16    cuerpo -> stackDeclaration
Rule 17    cuerpo -> stackPush
Rule 18    cuerpo -> stackPop
Rule 19    cuerpo -> line
Rule 20    cuerpo -> print
Rule 21    cuerpo -> logicalCondition
Rule 22    cuerpo -> OPEN_TAG
Rule 23    cuerpo -> CLOSE_TAG
Rule 24    cuerpo -> stringConcatenation
Rule 25    cuerpo -> callFunction
Rule 26    switchStatement -> SWITCH LPAREN value RPAREN LCURLY switchCases switchDefault RCURLY
Rule 27    switchDefault -> DEFAULT COLON programa
Rule 28    switchCase -> CASE value COLON programa BREAK SEMICOLON
Rule 29    switchCases -> switchCase
Rule 30    switchCases -> switchCases switchCase
Rule 31    if_elseStatement -> IF LPAREN logicalCondition RPAREN LCURLY ifStatementBody RCURLY ELSE LCURLY ifStatementBody RCURLY
Rule 32    if_elseStatement -> IF LPAREN logicalCondition RPAREN LCURLY ifStatementBody
Rule 33    ifStatementBody -> cuerpo
Rule 34    ifStatementBody -> cuerpo CONTINUE SEMICOLON
Rule 35    ifStatementBody -> ifStatementBody cuerpo
Rule 36    forStatement -> FOR LPAREN forStatementCondition RPAREN LCURLY forStatementBody RCURLY
Rule 37    forStatementCondition -> SEMICOLON SEMICOLON
Rule 38    forStatementCondition -> variableAsignation SEMICOLON SEMICOLON variableAsignation
Rule 39    forStatementCondition -> variableAsignation SEMICOLON comparingValue SEMICOLON variableAsignation
Rule 40    forStatementBody -> cuerpo
Rule 41    forStatementBody -> forStatementBody cuerpo
Rule 42    arrayAsignation -> VAR EQUAL arrayDeclaration SEMICOLON
Rule 43    arrayDeclaration -> ARRAY arraysValues RPAREN
Rule 44    arrayDeclaration -> LSQUARE arraysValues RSQUARE
Rule 45    arrayDeclaration -> arrayValue
Rule 46    arraysValues -> arrayValue
Rule 47    arraysValues -> arraysValues COMMA arrayValue
Rule 48    arrayValue -> ARRAY values RPAREN
Rule 49    arrayValue -> LSQUARE values RSQUARE
Rule 50    stackDeclaration -> VAR EQUAL NEW STACK SEMICOLON
Rule 51    stackPush -> VAR OBJOP PUSH LPAREN value RPAREN SEMICOLON
Rule 52    stackPop -> VAR OBJOP POP SEMICOLON
Rule 53    queueDeclaration -> VAR EQUAL NEW QUEUE SEMICOLON
Rule 54    queueEnqueue -> VAR OBJOP PUSH LPAREN value RPAREN SEMICOLON
Rule 55    queueDequeue -> VAR OBJOP POP SEMICOLON
Rule 56    defineFunction -> FUNCTION ID LPAREN arguments RPAREN LCURLY programa RCURLY
Rule 57    defineFunction -> FUNCTION ID LPAREN RPAREN LCURLY programa RCURLY
Rule 58    arguments -> VAR
Rule 59    arguments -> VAR COMMA arguments
Rule 60    anonymousFunction -> FUNCTION LPAREN RPAREN LCURLY cuerpo RCURLY
Rule 61    anonymousFunction -> FUNCTION LPAREN arguments RPAREN LCURLY cuerpo RCURLY
Rule 62    arrowFunction -> FN LPAREN VAR RPAREN FNARROW arrowBody SEMICOLON
Rule 63    arrowBody -> FN LPAREN VAR RPAREN FNARROW arrowBody
Rule 64    arrowBody -> cuerpo
Rule 65    echo -> ECHO values SEMICOLON
Rule 66    print -> PRINT LPAREN values RPAREN SEMICOLON
Rule 67    print -> PRINT value SEMICOLON
Rule 68    values -> value
Rule 69    values -> values COMMA value
Rule 70    fgets -> VAR EQUAL FGETS LPAREN STDIN RPAREN SEMICOLON
Rule 71    arithmeticExpression -> value
Rule 72    arithmeticExpression -> STRING
Rule 73    arithmeticExpression -> LPAREN arithmeticExpression RPAREN
Rule 74    arithmeticExpression -> arithmeticExpression arithmeticOperator arithmeticExpression
Rule 75    callFunction -> ID LPAREN RPAREN SEMICOLON
Rule 76    callFunction -> ID LPAREN value RPAREN SEMICOLON
Rule 77    value -> VAR
Rule 78    value -> INTEGER
Rule 79    value -> FLOAT
Rule 80    value -> STRING
Rule 81    value -> stringConcatenation
Rule 82    arithmeticOperator -> PLUS
Rule 83    arithmeticOperator -> MINUS
Rule 84    arithmeticOperator -> TIMES
Rule 85    arithmeticOperator -> DIVIDE
Rule 86    arithmeticOperator -> MOD
Rule 87    arithmeticOperator -> EXP
Rule 88    line -> variableAsignation SEMICOLON
Rule 89    variableAsignation -> VAR EQUAL value
Rule 90    variableAsignation -> VAR EQUAL arithmeticExpression
Rule 91    variableAsignation -> VAR INCREMENT
Rule 92    variableAsignation -> VAR DECREMENT
Rule 93    variableAsignation -> VAR EQUAL stringConcatenation
Rule 94    variableAsignation -> VAR EQUAL anonymousFunction
Rule 95    comparingSign -> IS_EQUAL
Rule 96    comparingSign -> IDENTICAL
Rule 97    comparingSign -> NOTEQUAL
Rule 98    comparingSign -> LESSTHAN
Rule 99    comparingSign -> GREATERTHAN
Rule 100   comparingSign -> LESSEQUALTHAN
Rule 101   comparingSign -> GREATEREQUALTHAN
Rule 102   comparingValue -> value comparingSign value
Rule 103   logicalCondition -> comparingValue
Rule 104   logicalCondition -> comparingValue conditionOperator comparingValue
Rule 105   logicalCondition -> LPAREN logicalCondition RPAREN
Rule 106   conditionOperator -> AND
Rule 107   conditionOperator -> OR
Rule 108   conditionOperator -> XOR
Rule 109   stringConcatenation -> value CONCAT value
Rule 110   stringConcatenation -> stringConcatenation CONCAT stringConcatenation

Terminals, with rules where they appear

ABSTRACT             : 
AND                  : 106
ARRAY                : 43 48
BITAND               : 
BITNOT               : 
BITOR                : 
BOOL                 : 
BREAK                : 28
CASE                 : 28
CLOSE_TAG            : 23
COLON                : 27 28
COMMA                : 47 59 69
CONCAT               : 109 110
CONCATASSIGN         : 
CONTINUE             : 34
DECREMENT            : 92
DEFAULT              : 27
DIVIDE               : 85
DIVIDEASSIGN         : 
DOC_COMMENT          : 
DOUBLEQUOTE          : 
ECHO                 : 65
ELSE                 : 31
EQUAL                : 42 50 53 70 89 90 93 94
ERRORCONTROL         : 
EXECUTION            : 
EXP                  : 87
EXPASSIGN            : 
FGETS                : 70
FLOAT                : 79
FN                   : 62 63
FNARROW              : 62 63
FOR                  : 36
FUNCTION             : 56 57 60 61
GREATEREQUALTHAN     : 101
GREATERTHAN          : 99
ID                   : 56 57 75 76
IDENTICAL            : 96
IF                   : 31 32
INCREMENT            : 91
INTEGER              : 78
IS_EQUAL             : 95
LCURLY               : 26 31 31 32 36 56 57 60 61
LESSEQUALTHAN        : 100
LESSTHAN             : 98
LOGICALNOT           : 
LPAREN               : 26 31 32 36 51 54 56 57 60 61 62 63 66 70 73 75 76 105
LSQUARE              : 44 49
MINUS                : 83
MINUSASSIGN          : 
MOD                  : 86
MODASSIGN            : 
NEW                  : 50 53
NOTEQUAL             : 97
NULL                 : 
OBJOP                : 51 52 54 55
OPEN_TAG             : 22
OR                   : 107
PLUS                 : 82
PLUSASSIGN           : 
POP                  : 52 55
PRINT                : 66 67
PUSH                 : 51 54
QUEUE                : 53
QUOTE                : 
RCURLY               : 26 31 31 36 56 57 60 61
RPAREN               : 26 31 32 36 43 48 51 54 56 57 60 61 62 63 66 70 73 75 76 105
RSQUARE              : 44 49
SEMICOLON            : 28 34 37 37 38 38 39 39 42 50 51 52 53 54 55 62 65 66 67 70 75 76 88
STACK                : 50
STDIN                : 70
STRING               : 72 80
SWITCH               : 26
TIMES                : 84
TIMESASSIGN          : 
VAR                  : 42 50 51 52 53 54 55 58 59 62 63 70 77 89 90 91 92 93 94
XOR                  : 108
error                : 

Nonterminals, with rules where they appear

anonymousFunction    : 12 94
arguments            : 56 59 61
arithmeticExpression : 3 73 74 74 90
arithmeticOperator   : 74
arrayAsignation      : 7
arrayDeclaration     : 42
arrayValue           : 45 46 47
arraysValues         : 43 44 47
arrowBody            : 62 63
arrowFunction        : 13
callFunction         : 25
comparingSign        : 102
comparingValue       : 39 103 104 104
conditionOperator    : 104
cuerpo               : 1 2 33 34 35 40 41 60 61 64
defineFunction       : 11
echo                 : 14
fgets                : 15
forStatement         : 5
forStatementBody     : 36 41
forStatementCondition : 36
ifStatementBody      : 31 31 32 35
if_elseStatement     : 4
line                 : 19
logicalCondition     : 21 31 32 105
print                : 20
programa             : 2 27 28 56 57 0
queueDeclaration     : 8
queueDequeue         : 10
queueEnqueue         : 9
stackDeclaration     : 16
stackPop             : 18
stackPush            : 17
stringConcatenation  : 24 81 93 110 110
switchCase           : 29 30
switchCases          : 26 30
switchDefault        : 26
switchStatement      : 6
value                : 26 28 51 54 67 68 69 71 76 89 102 102 109 109
values               : 48 49 65 66 69
variableAsignation   : 38 38 39 39 88

Parsing method: LALR

state 0

    (0) S' -> . programa
    (1) programa -> . cuerpo
    (2) programa -> . programa cuerpo
    (3) cuerpo -> . arithmeticExpression
    (4) cuerpo -> . if_elseStatement
    (5) cuerpo -> . forStatement
    (6) cuerpo -> . switchStatement
    (7) cuerpo -> . arrayAsignation
    (8) cuerpo -> . queueDeclaration
    (9) cuerpo -> . queueEnqueue
    (10) cuerpo -> . queueDequeue
    (11) cuerpo -> . defineFunction
    (12) cuerpo -> . anonymousFunction
    (13) cuerpo -> . arrowFunction
    (14) cuerpo -> . echo
    (15) cuerpo -> . fgets
    (16) cuerpo -> . stackDeclaration
    (17) cuerpo -> . stackPush
    (18) cuerpo -> . stackPop
    (19) cuerpo -> . line
    (20) cuerpo -> . print
    (21) cuerpo -> . logicalCondition
    (22) cuerpo -> . OPEN_TAG
    (23) cuerpo -> . CLOSE_TAG
    (24) cuerpo -> . stringConcatenation
    (25) cuerpo -> . callFunction
    (71) arithmeticExpression -> . value
    (72) arithmeticExpression -> . STRING
    (73) arithmeticExpression -> . LPAREN arithmeticExpression RPAREN
    (74) arithmeticExpression -> . arithmeticExpression arithmeticOperator arithmeticExpression
    (31) if_elseStatement -> . IF LPAREN logicalCondition RPAREN LCURLY ifStatementBody RCURLY ELSE LCURLY ifStatementBody RCURLY
    (32) if_elseStatement -> . IF LPAREN logicalCondition RPAREN LCURLY ifStatementBody
    (36) forStatement -> . FOR LPAREN forStatementCondition RPAREN LCURLY forStatementBody RCURLY
    (26) switchStatement -> . SWITCH LPAREN value RPAREN LCURLY switchCases switchDefault RCURLY
    (42) arrayAsignation -> . VAR EQUAL arrayDeclaration SEMICOLON
    (53) queueDeclaration -> . VAR EQUAL NEW QUEUE SEMICOLON
    (54) queueEnqueue -> . VAR OBJOP PUSH LPAREN value RPAREN SEMICOLON
    (55) queueDequeue -> . VAR OBJOP POP SEMICOLON
    (56) defineFunction -> . FUNCTION ID LPAREN arguments RPAREN LCURLY programa RCURLY
    (57) defineFunction -> . FUNCTION ID LPAREN RPAREN LCURLY programa RCURLY
    (60) anonymousFunction -> . FUNCTION LPAREN RPAREN LCURLY cuerpo RCURLY
    (61) anonymousFunction -> . FUNCTION LPAREN arguments RPAREN LCURLY cuerpo RCURLY
    (62) arrowFunction -> . FN LPAREN VAR RPAREN FNARROW arrowBody SEMICOLON
    (65) echo -> . ECHO values SEMICOLON
    (70) fgets -> . VAR EQUAL FGETS LPAREN STDIN RPAREN SEMICOLON
    (50) stackDeclaration -> . VAR EQUAL NEW STACK SEMICOLON
    (51) stackPush -> . VAR OBJOP PUSH LPAREN value RPAREN SEMICOLON
    (52) stackPop -> . VAR OBJOP POP SEMICOLON
    (88) line -> . variableAsignation SEMICOLON
    (66) print -> . PRINT LPAREN values RPAREN SEMICOLON
    (67) print -> . PRINT value SEMICOLON
    (103) logicalCondition -> . comparingValue
    (104) logicalCondition -> . comparingValue conditionOperator comparingValue
    (105) logicalCondition -> . LPAREN logicalCondition RPAREN
    (109) stringConcatenation -> . value CONCAT value
    (110) stringConcatenation -> . stringConcatenation CONCAT stringConcatenation
    (75) callFunction -> . ID LPAREN RPAREN SEMICOLON
    (76) callFunction -> . ID LPAREN value RPAREN SEMICOLON
    (77) value -> . VAR
    (78) value -> . INTEGER
    (79) value -> . FLOAT
    (80) value -> . STRING
    (81) value -> . stringConcatenation
    (89) variableAsignation -> . VAR EQUAL value
    (90) variableAsignation -> . VAR EQUAL arithmeticExpression
    (91) variableAsignation -> . VAR INCREMENT
    (92) variableAsignation -> . VAR DECREMENT
    (93) variableAsignation -> . VAR EQUAL stringConcatenation
    (94) variableAsignation -> . VAR EQUAL anonymousFunction
    (102) comparingValue -> . value comparingSign value

    OPEN_TAG        shift and go to state 22
    CLOSE_TAG       shift and go to state 23
    STRING          shift and go to state 27
    LPAREN          shift and go to state 28
    IF              shift and go to state 29
    FOR             shift and go to state 30
    SWITCH          shift and go to state 31
    VAR             shift and go to state 32
    FUNCTION        shift and go to state 33
    FN              shift and go to state 35
    ECHO            shift and go to state 36
    PRINT           shift and go to state 38
    ID              shift and go to state 34
    INTEGER         shift and go to state 40
    FLOAT           shift and go to state 41

    programa                       shift and go to state 1
    cuerpo                         shift and go to state 2
    arithmeticExpression           shift and go to state 3
    if_elseStatement               shift and go to state 4
    forStatement                   shift and go to state 5
    switchStatement                shift and go to state 6
    arrayAsignation                shift and go to state 7
    queueDeclaration               shift and go to state 8
    queueEnqueue                   shift and go to state 9
    queueDequeue                   shift and go to state 10
    defineFunction                 shift and go to state 11
    anonymousFunction              shift and go to state 12
    arrowFunction                  shift and go to state 13
    echo                           shift and go to state 14
    fgets                          shift and go to state 15
    stackDeclaration               shift and go to state 16
    stackPush                      shift and go to state 17
    stackPop                       shift and go to state 18
    line                           shift and go to state 19
    print                          shift and go to state 20
    logicalCondition               shift and go to state 21
    stringConcatenation            shift and go to state 24
    callFunction                   shift and go to state 25
    value                          shift and go to state 26
    variableAsignation             shift and go to state 37
    comparingValue                 shift and go to state 39

state 1

    (0) S' -> programa .
    (2) programa -> programa . cuerpo
    (3) cuerpo -> . arithmeticExpression
    (4) cuerpo -> . if_elseStatement
    (5) cuerpo -> . forStatement
    (6) cuerpo -> . switchStatement
    (7) cuerpo -> . arrayAsignation
    (8) cuerpo -> . queueDeclaration
    (9) cuerpo -> . queueEnqueue
    (10) cuerpo -> . queueDequeue
    (11) cuerpo -> . defineFunction
    (12) cuerpo -> . anonymousFunction
    (13) cuerpo -> . arrowFunction
    (14) cuerpo -> . echo
    (15) cuerpo -> . fgets
    (16) cuerpo -> . stackDeclaration
    (17) cuerpo -> . stackPush
    (18) cuerpo -> . stackPop
    (19) cuerpo -> . line
    (20) cuerpo -> . print
    (21) cuerpo -> . logicalCondition
    (22) cuerpo -> . OPEN_TAG
    (23) cuerpo -> . CLOSE_TAG
    (24) cuerpo -> . stringConcatenation
    (25) cuerpo -> . callFunction
    (71) arithmeticExpression -> . value
    (72) arithmeticExpression -> . STRING
    (73) arithmeticExpression -> . LPAREN arithmeticExpression RPAREN
    (74) arithmeticExpression -> . arithmeticExpression arithmeticOperator arithmeticExpression
    (31) if_elseStatement -> . IF LPAREN logicalCondition RPAREN LCURLY ifStatementBody RCURLY ELSE LCURLY ifStatementBody RCURLY
    (32) if_elseStatement -> . IF LPAREN logicalCondition RPAREN LCURLY ifStatementBody
    (36) forStatement -> . FOR LPAREN forStatementCondition RPAREN LCURLY forStatementBody RCURLY
    (26) switchStatement -> . SWITCH LPAREN value RPAREN LCURLY switchCases switchDefault RCURLY
    (42) arrayAsignation -> . VAR EQUAL arrayDeclaration SEMICOLON
    (53) queueDeclaration -> . VAR EQUAL NEW QUEUE SEMICOLON
    (54) queueEnqueue -> . VAR OBJOP PUSH LPAREN value RPAREN SEMICOLON
    (55) queueDequeue -> . VAR OBJOP POP SEMICOLON
    (56) defineFunction -> . FUNCTION ID LPAREN arguments RPAREN LCURLY programa RCURLY
    (57) defineFunction -> . FUNCTION ID LPAREN RPAREN LCURLY programa RCURLY
    (60) anonymousFunction -> . FUNCTION LPAREN RPAREN LCURLY cuerpo RCURLY
    (61) anonymousFunction -> . FUNCTION LPAREN arguments RPAREN LCURLY cuerpo RCURLY
    (62) arrowFunction -> . FN LPAREN VAR RPAREN FNARROW arrowBody SEMICOLON
    (65) echo -> . ECHO values SEMICOLON
    (70) fgets -> . VAR EQUAL FGETS LPAREN STDIN RPAREN SEMICOLON
    (50) stackDeclaration -> . VAR EQUAL NEW STACK SEMICOLON
    (51) stackPush -> . VAR OBJOP PUSH LPAREN value RPAREN SEMICOLON
    (52) stackPop -> . VAR OBJOP POP SEMICOLON
    (88) line -> . variableAsignation SEMICOLON
    (66) print -> . PRINT LPAREN values RPAREN SEMICOLON
    (67) print -> . PRINT value SEMICOLON
    (103) logicalCondition -> . comparingValue
    (104) logicalCondition -> . comparingValue conditionOperator comparingValue
    (105) logicalCondition -> . LPAREN logicalCondition RPAREN
    (109) stringConcatenation -> . value CONCAT value
    (110) stringConcatenation -> . stringConcatenation CONCAT stringConcatenation
    (75) callFunction -> . ID LPAREN RPAREN SEMICOLON
    (76) callFunction -> . ID LPAREN value RPAREN SEMICOLON
    (77) value -> . VAR
    (78) value -> . INTEGER
    (79) value -> . FLOAT
    (80) value -> . STRING
    (81) value -> . stringConcatenation
    (89) variableAsignation -> . VAR EQUAL value
    (90) variableAsignation -> . VAR EQUAL arithmeticExpression
    (91) variableAsignation -> . VAR INCREMENT
    (92) variableAsignation -> . VAR DECREMENT
    (93) variableAsignation -> . VAR EQUAL stringConcatenation
    (94) variableAsignation -> . VAR EQUAL anonymousFunction
    (102) comparingValue -> . value comparingSign value

    OPEN_TAG        shift and go to state 22
    CLOSE_TAG       shift and go to state 23
    STRING          shift and go to state 27
    LPAREN          shift and go to state 28
    IF              shift and go to state 29
    FOR             shift and go to state 30
    SWITCH          shift and go to state 31
    VAR             shift and go to state 32
    FUNCTION        shift and go to state 33
    FN              shift and go to state 35
    ECHO            shift and go to state 36
    PRINT           shift and go to state 38
    ID              shift and go to state 34
    INTEGER         shift and go to state 40
    FLOAT           shift and go to state 41

    cuerpo                         shift and go to state 42
    arithmeticExpression           shift and go to state 3
    if_elseStatement               shift and go to state 4
    forStatement                   shift and go to state 5
    switchStatement                shift and go to state 6
    arrayAsignation                shift and go to state 7
    queueDeclaration               shift and go to state 8
    queueEnqueue                   shift and go to state 9
    queueDequeue                   shift and go to state 10
    defineFunction                 shift and go to state 11
    anonymousFunction              shift and go to state 12
    arrowFunction                  shift and go to state 13
    echo                           shift and go to state 14
    fgets                          shift and go to state 15
    stackDeclaration               shift and go to state 16
    stackPush                      shift and go to state 17
    stackPop                       shift and go to state 18
    line                           shift and go to state 19
    print                          shift and go to state 20
    logicalCondition               shift and go to state 21
    stringConcatenation            shift and go to state 24
    callFunction                   shift and go to state 25
    value                          shift and go to state 26
    variableAsignation             shift and go to state 37
    comparingValue                 shift and go to state 39

state 2

    (1) programa -> cuerpo .

    OPEN_TAG        reduce using rule 1 (programa -> cuerpo .)
    CLOSE_TAG       reduce using rule 1 (programa -> cuerpo .)
    STRING          reduce using rule 1 (programa -> cuerpo .)
    LPAREN          reduce using rule 1 (programa -> cuerpo .)
    IF              reduce using rule 1 (programa -> cuerpo .)
    FOR             reduce using rule 1 (programa -> cuerpo .)
    SWITCH          reduce using rule 1 (programa -> cuerpo .)
    VAR             reduce using rule 1 (programa -> cuerpo .)
    FUNCTION        reduce using rule 1 (programa -> cuerpo .)
    FN              reduce using rule 1 (programa -> cuerpo .)
    ECHO            reduce using rule 1 (programa -> cuerpo .)
    PRINT           reduce using rule 1 (programa -> cuerpo .)
    ID              reduce using rule 1 (programa -> cuerpo .)
    INTEGER         reduce using rule 1 (programa -> cuerpo .)
    FLOAT           reduce using rule 1 (programa -> cuerpo .)
    $end            reduce using rule 1 (programa -> cuerpo .)
    RCURLY          reduce using rule 1 (programa -> cuerpo .)
    BREAK           reduce using rule 1 (programa -> cuerpo .)


state 3

    (3) cuerpo -> arithmeticExpression .
    (74) arithmeticExpression -> arithmeticExpression . arithmeticOperator arithmeticExpression
    (82) arithmeticOperator -> . PLUS
    (83) arithmeticOperator -> . MINUS
    (84) arithmeticOperator -> . TIMES
    (85) arithmeticOperator -> . DIVIDE
    (86) arithmeticOperator -> . MOD
    (87) arithmeticOperator -> . EXP

    OPEN_TAG        reduce using rule 3 (cuerpo -> arithmeticExpression .)
    CLOSE_TAG       reduce using rule 3 (cuerpo -> arithmeticExpression .)
    STRING          reduce using rule 3 (cuerpo -> arithmeticExpression .)
    LPAREN          reduce using rule 3 (cuerpo -> arithmeticExpression .)
    IF              reduce using rule 3 (cuerpo -> arithmeticExpression .)
    FOR             reduce using rule 3 (cuerpo -> arithmeticExpression .)
    SWITCH          reduce using rule 3 (cuerpo -> arithmeticExpression .)
    VAR             reduce using rule 3 (cuerpo -> arithmeticExpression .)
    FUNCTION        reduce using rule 3 (cuerpo -> arithmeticExpression .)
    FN              reduce using rule 3 (cuerpo -> arithmeticExpression .)
    ECHO            reduce using rule 3 (cuerpo -> arithmeticExpression .)
    PRINT           reduce using rule 3 (cuerpo -> arithmeticExpression .)
    ID              reduce using rule 3 (cuerpo -> arithmeticExpression .)
    INTEGER         reduce using rule 3 (cuerpo -> arithmeticExpression .)
    FLOAT           reduce using rule 3 (cuerpo -> arithmeticExpression .)
    $end            reduce using rule 3 (cuerpo -> arithmeticExpression .)
    RCURLY          reduce using rule 3 (cuerpo -> arithmeticExpression .)
    CONTINUE        reduce using rule 3 (cuerpo -> arithmeticExpression .)
    SEMICOLON       reduce using rule 3 (cuerpo -> arithmeticExpression .)
    BREAK           reduce using rule 3 (cuerpo -> arithmeticExpression .)
    PLUS            shift and go to state 44
    MINUS           shift and go to state 45
    TIMES           shift and go to state 46
    DIVIDE          shift and go to state 47
    MOD             shift and go to state 48
    EXP             shift and go to state 49

    arithmeticOperator             shift and go to state 43

state 4

    (4) cuerpo -> if_elseStatement .

    OPEN_TAG        reduce using rule 4 (cuerpo -> if_elseStatement .)
    CLOSE_TAG       reduce using rule 4 (cuerpo -> if_elseStatement .)
    STRING          reduce using rule 4 (cuerpo -> if_elseStatement .)
    LPAREN          reduce using rule 4 (cuerpo -> if_elseStatement .)
    IF              reduce using rule 4 (cuerpo -> if_elseStatement .)
    FOR             reduce using rule 4 (cuerpo -> if_elseStatement .)
    SWITCH          reduce using rule 4 (cuerpo -> if_elseStatement .)
    VAR             reduce using rule 4 (cuerpo -> if_elseStatement .)
    FUNCTION        reduce using rule 4 (cuerpo -> if_elseStatement .)
    FN              reduce using rule 4 (cuerpo -> if_elseStatement .)
    ECHO            reduce using rule 4 (cuerpo -> if_elseStatement .)
    PRINT           reduce using rule 4 (cuerpo -> if_elseStatement .)
    ID              reduce using rule 4 (cuerpo -> if_elseStatement .)
    INTEGER         reduce using rule 4 (cuerpo -> if_elseStatement .)
    FLOAT           reduce using rule 4 (cuerpo -> if_elseStatement .)
    $end            reduce using rule 4 (cuerpo -> if_elseStatement .)
    RCURLY          reduce using rule 4 (cuerpo -> if_elseStatement .)
    CONTINUE        reduce using rule 4 (cuerpo -> if_elseStatement .)
    SEMICOLON       reduce using rule 4 (cuerpo -> if_elseStatement .)
    BREAK           reduce using rule 4 (cuerpo -> if_elseStatement .)


state 5

    (5) cuerpo -> forStatement .

    OPEN_TAG        reduce using rule 5 (cuerpo -> forStatement .)
    CLOSE_TAG       reduce using rule 5 (cuerpo -> forStatement .)
    STRING          reduce using rule 5 (cuerpo -> forStatement .)
    LPAREN          reduce using rule 5 (cuerpo -> forStatement .)
    IF              reduce using rule 5 (cuerpo -> forStatement .)
    FOR             reduce using rule 5 (cuerpo -> forStatement .)
    SWITCH          reduce using rule 5 (cuerpo -> forStatement .)
    VAR             reduce using rule 5 (cuerpo -> forStatement .)
    FUNCTION        reduce using rule 5 (cuerpo -> forStatement .)
    FN              reduce using rule 5 (cuerpo -> forStatement .)
    ECHO            reduce using rule 5 (cuerpo -> forStatement .)
    PRINT           reduce using rule 5 (cuerpo -> forStatement .)
    ID              reduce using rule 5 (cuerpo -> forStatement .)
    INTEGER         reduce using rule 5 (cuerpo -> forStatement .)
    FLOAT           reduce using rule 5 (cuerpo -> forStatement .)
    $end            reduce using rule 5 (cuerpo -> forStatement .)
    RCURLY          reduce using rule 5 (cuerpo -> forStatement .)
    CONTINUE        reduce using rule 5 (cuerpo -> forStatement .)
    SEMICOLON       reduce using rule 5 (cuerpo -> forStatement .)
    BREAK           reduce using rule 5 (cuerpo -> forStatement .)


state 6

    (6) cuerpo -> switchStatement .

    OPEN_TAG        reduce using rule 6 (cuerpo -> switchStatement .)
    CLOSE_TAG       reduce using rule 6 (cuerpo -> switchStatement .)
    STRING          reduce using rule 6 (cuerpo -> switchStatement .)
    LPAREN          reduce using rule 6 (cuerpo -> switchStatement .)
    IF              reduce using rule 6 (cuerpo -> switchStatement .)
    FOR             reduce using rule 6 (cuerpo -> switchStatement .)
    SWITCH          reduce using rule 6 (cuerpo -> switchStatement .)
    VAR             reduce using rule 6 (cuerpo -> switchStatement .)
    FUNCTION        reduce using rule 6 (cuerpo -> switchStatement .)
    FN              reduce using rule 6 (cuerpo -> switchStatement .)
    ECHO            reduce using rule 6 (cuerpo -> switchStatement .)
    PRINT           reduce using rule 6 (cuerpo -> switchStatement .)
    ID              reduce using rule 6 (cuerpo -> switchStatement .)
    INTEGER         reduce using rule 6 (cuerpo -> switchStatement .)
    FLOAT           reduce using rule 6 (cuerpo -> switchStatement .)
    $end            reduce using rule 6 (cuerpo -> switchStatement .)
    RCURLY          reduce using rule 6 (cuerpo -> switchStatement .)
    CONTINUE        reduce using rule 6 (cuerpo -> switchStatement .)
    SEMICOLON       reduce using rule 6 (cuerpo -> switchStatement .)
    BREAK           reduce using rule 6 (cuerpo -> switchStatement .)


state 7

    (7) cuerpo -> arrayAsignation .

    OPEN_TAG        reduce using rule 7 (cuerpo -> arrayAsignation .)
    CLOSE_TAG       reduce using rule 7 (cuerpo -> arrayAsignation .)
    STRING          reduce using rule 7 (cuerpo -> arrayAsignation .)
    LPAREN          reduce using rule 7 (cuerpo -> arrayAsignation .)
    IF              reduce using rule 7 (cuerpo -> arrayAsignation .)
    FOR             reduce using rule 7 (cuerpo -> arrayAsignation .)
    SWITCH          reduce using rule 7 (cuerpo -> arrayAsignation .)
    VAR             reduce using rule 7 (cuerpo -> arrayAsignation .)
    FUNCTION        reduce using rule 7 (cuerpo -> arrayAsignation .)
    FN              reduce using rule 7 (cuerpo -> arrayAsignation .)
    ECHO            reduce using rule 7 (cuerpo -> arrayAsignation .)
    PRINT           reduce using rule 7 (cuerpo -> arrayAsignation .)
    ID              reduce using rule 7 (cuerpo -> arrayAsignation .)
    INTEGER         reduce using rule 7 (cuerpo -> arrayAsignation .)
    FLOAT           reduce using rule 7 (cuerpo -> arrayAsignation .)
    $end            reduce using rule 7 (cuerpo -> arrayAsignation .)
    RCURLY          reduce using rule 7 (cuerpo -> arrayAsignation .)
    CONTINUE        reduce using rule 7 (cuerpo -> arrayAsignation .)
    SEMICOLON       reduce using rule 7 (cuerpo -> arrayAsignation .)
    BREAK           reduce using rule 7 (cuerpo -> arrayAsignation .)


state 8

    (8) cuerpo -> queueDeclaration .

    OPEN_TAG        reduce using rule 8 (cuerpo -> queueDeclaration .)
    CLOSE_TAG       reduce using rule 8 (cuerpo -> queueDeclaration .)
    STRING          reduce using rule 8 (cuerpo -> queueDeclaration .)
    LPAREN          reduce using rule 8 (cuerpo -> queueDeclaration .)
    IF              reduce using rule 8 (cuerpo -> queueDeclaration .)
    FOR             reduce using rule 8 (cuerpo -> queueDeclaration .)
    SWITCH          reduce using rule 8 (cuerpo -> queueDeclaration .)
    VAR             reduce using rule 8 (cuerpo -> queueDeclaration .)
    FUNCTION        reduce using rule 8 (cuerpo -> queueDeclaration .)
    FN              reduce using rule 8 (cuerpo -> queueDeclaration .)
    ECHO            reduce using rule 8 (cuerpo -> queueDeclaration .)
    PRINT           reduce using rule 8 (cuerpo -> queueDeclaration .)
    ID              reduce using rule 8 (cuerpo -> queueDeclaration .)
    INTEGER         reduce using rule 8 (cuerpo -> queueDeclaration .)
    FLOAT           reduce using rule 8 (cuerpo -> queueDeclaration .)
    $end            reduce using rule 8 (cuerpo -> queueDeclaration .)
    RCURLY          reduce using rule 8 (cuerpo -> queueDeclaration .)
    CONTINUE        reduce using rule 8 (cuerpo -> queueDeclaration .)
    SEMICOLON       reduce using rule 8 (cuerpo -> queueDeclaration .)
    BREAK           reduce using rule 8 (cuerpo -> queueDeclaration .)


state 9

    (9) cuerpo -> queueEnqueue .

    OPEN_TAG        reduce using rule 9 (cuerpo -> queueEnqueue .)
    CLOSE_TAG       reduce using rule 9 (cuerpo -> queueEnqueue .)
    STRING          reduce using rule 9 (cuerpo -> queueEnqueue .)
    LPAREN          reduce using rule 9 (cuerpo -> queueEnqueue .)
    IF              reduce using rule 9 (cuerpo -> queueEnqueue .)
    FOR             reduce using rule 9 (cuerpo -> queueEnqueue .)
    SWITCH          reduce using rule 9 (cuerpo -> queueEnqueue .)
    VAR             reduce using rule 9 (cuerpo -> queueEnqueue .)
    FUNCTION        reduce using rule 9 (cuerpo -> queueEnqueue .)
    FN              reduce using rule 9 (cuerpo -> queueEnqueue .)
    ECHO            reduce using rule 9 (cuerpo -> queueEnqueue .)
    PRINT           reduce using rule 9 (cuerpo -> queueEnqueue .)
    ID              reduce using rule 9 (cuerpo -> queueEnqueue .)
    INTEGER         reduce using rule 9 (cuerpo -> queueEnqueue .)
    FLOAT           reduce using rule 9 (cuerpo -> queueEnqueue .)
    $end            reduce using rule 9 (cuerpo -> queueEnqueue .)
    RCURLY          reduce using rule 9 (cuerpo -> queueEnqueue .)
    CONTINUE        reduce using rule 9 (cuerpo -> queueEnqueue .)
    SEMICOLON       reduce using rule 9 (cuerpo -> queueEnqueue .)
    BREAK           reduce using rule 9 (cuerpo -> queueEnqueue .)


state 10

    (10) cuerpo -> queueDequeue .

    OPEN_TAG        reduce using rule 10 (cuerpo -> queueDequeue .)
    CLOSE_TAG       reduce using rule 10 (cuerpo -> queueDequeue .)
    STRING          reduce using rule 10 (cuerpo -> queueDequeue .)
    LPAREN          reduce using rule 10 (cuerpo -> queueDequeue .)
    IF              reduce using rule 10 (cuerpo -> queueDequeue .)
    FOR             reduce using rule 10 (cuerpo -> queueDequeue .)
    SWITCH          reduce using rule 10 (cuerpo -> queueDequeue .)
    VAR             reduce using rule 10 (cuerpo -> queueDequeue .)
    FUNCTION        reduce using rule 10 (cuerpo -> queueDequeue .)
    FN              reduce using rule 10 (cuerpo -> queueDequeue .)
    ECHO            reduce using rule 10 (cuerpo -> queueDequeue .)
    PRINT           reduce using rule 10 (cuerpo -> queueDequeue .)
    ID              reduce using rule 10 (cuerpo -> queueDequeue .)
    INTEGER         reduce using rule 10 (cuerpo -> queueDequeue .)
    FLOAT           reduce using rule 10 (cuerpo -> queueDequeue .)
    $end            reduce using rule 10 (cuerpo -> queueDequeue .)
    RCURLY          reduce using rule 10 (cuerpo -> queueDequeue .)
    CONTINUE        reduce using rule 10 (cuerpo -> queueDequeue .)
    SEMICOLON       reduce using rule 10 (cuerpo -> queueDequeue .)
    BREAK           reduce using rule 10 (cuerpo -> queueDequeue .)


state 11

    (11) cuerpo -> defineFunction .

    OPEN_TAG        reduce using rule 11 (cuerpo -> defineFunction .)
    CLOSE_TAG       reduce using rule 11 (cuerpo -> defineFunction .)
    STRING          reduce using rule 11 (cuerpo -> defineFunction .)
    LPAREN          reduce using rule 11 (cuerpo -> defineFunction .)
    IF              reduce using rule 11 (cuerpo -> defineFunction .)
    FOR             reduce using rule 11 (cuerpo -> defineFunction .)
    SWITCH          reduce using rule 11 (cuerpo -> defineFunction .)
    VAR             reduce using rule 11 (cuerpo -> defineFunction .)
    FUNCTION        reduce using rule 11 (cuerpo -> defineFunction .)
    FN              reduce using rule 11 (cuerpo -> defineFunction .)
    ECHO            reduce using rule 11 (cuerpo -> defineFunction .)
    PRINT           reduce using rule 11 (cuerpo -> defineFunction .)
    ID              reduce using rule 11 (cuerpo -> defineFunction .)
    INTEGER         reduce using rule 11 (cuerpo -> defineFunction .)
    FLOAT           reduce using rule 11 (cuerpo -> defineFunction .)
    $end            reduce using rule 11 (cuerpo -> defineFunction .)
    RCURLY          reduce using rule 11 (cuerpo -> defineFunction .)
    CONTINUE        reduce using rule 11 (cuerpo -> defineFunction .)
    SEMICOLON       reduce using rule 11 (cuerpo -> defineFunction .)
    BREAK           reduce using rule 11 (cuerpo -> defineFunction .)


state 12

    (12) cuerpo -> anonymousFunction .

    OPEN_TAG        reduce using rule 12 (cuerpo -> anonymousFunction .)
    CLOSE_TAG       reduce using rule 12 (cuerpo -> anonymousFunction .)
    STRING          reduce using rule 12 (cuerpo -> anonymousFunction .)
    LPAREN          reduce using rule 12 (cuerpo -> anonymousFunction .)
    IF              reduce using rule 12 (cuerpo -> anonymousFunction .)
    FOR             reduce using rule 12 (cuerpo -> anonymousFunction .)
    SWITCH          reduce using rule 12 (cuerpo -> anonymousFunction .)
    VAR             reduce using rule 12 (cuerpo -> anonymousFunction .)
    FUNCTION        reduce using rule 12 (cuerpo -> anonymousFunction .)
    FN              reduce using rule 12 (cuerpo -> anonymousFunction .)
    ECHO            reduce using rule 12 (cuerpo -> anonymousFunction .)
    PRINT           reduce using rule 12 (cuerpo -> anonymousFunction .)
    ID              reduce using rule 12 (cuerpo -> anonymousFunction .)
    INTEGER         reduce using rule 12 (cuerpo -> anonymousFunction .)
    FLOAT           reduce using rule 12 (cuerpo -> anonymousFunction .)
    $end            reduce using rule 12 (cuerpo -> anonymousFunction .)
    RCURLY          reduce using rule 12 (cuerpo -> anonymousFunction .)
    CONTINUE        reduce using rule 12 (cuerpo -> anonymousFunction .)
    SEMICOLON       reduce using rule 12 (cuerpo -> anonymousFunction .)
    BREAK           reduce using rule 12 (cuerpo -> anonymousFunction .)


state 13

    (13) cuerpo -> arrowFunction .

    OPEN_TAG        reduce using rule 13 (cuerpo -> arrowFunction .)
    CLOSE_TAG       reduce using rule 13 (cuerpo -> arrowFunction .)
    STRING          reduce using rule 13 (cuerpo -> arrowFunction .)
    LPAREN          reduce using rule 13 (cuerpo -> arrowFunction .)
    IF              reduce using rule 13 (cuerpo -> arrowFunction .)
    FOR             reduce using rule 13 (cuerpo -> arrowFunction .)
    SWITCH          reduce using rule 13 (cuerpo -> arrowFunction .)
    VAR             reduce using rule 13 (cuerpo -> arrowFunction .)
    FUNCTION        reduce using rule 13 (cuerpo -> arrowFunction .)
    FN              reduce using rule 13 (cuerpo -> arrowFunction .)
    ECHO            reduce using rule 13 (cuerpo -> arrowFunction .)
    PRINT           reduce using rule 13 (cuerpo -> arrowFunction .)
    ID              reduce using rule 13 (cuerpo -> arrowFunction .)
    INTEGER         reduce using rule 13 (cuerpo -> arrowFunction .)
    FLOAT           reduce using rule 13 (cuerpo -> arrowFunction .)
    $end            reduce using rule 13 (cuerpo -> arrowFunction .)
    RCURLY          reduce using rule 13 (cuerpo -> arrowFunction .)
    CONTINUE        reduce using rule 13 (cuerpo -> arrowFunction .)
    SEMICOLON       reduce using rule 13 (cuerpo -> arrowFunction .)
    BREAK           reduce using rule 13 (cuerpo -> arrowFunction .)


state 14

    (14) cuerpo -> echo .

    OPEN_TAG        reduce using rule 14 (cuerpo -> echo .)
    CLOSE_TAG       reduce using rule 14 (cuerpo -> echo .)
    STRING          reduce using rule 14 (cuerpo -> echo .)
    LPAREN          reduce using rule 14 (cuerpo -> echo .)
    IF              reduce using rule 14 (cuerpo -> echo .)
    FOR             reduce using rule 14 (cuerpo -> echo .)
    SWITCH          reduce using rule 14 (cuerpo -> echo .)
    VAR             reduce using rule 14 (cuerpo -> echo .)
    FUNCTION        reduce using rule 14 (cuerpo -> echo .)
    FN              reduce using rule 14 (cuerpo -> echo .)
    ECHO            reduce using rule 14 (cuerpo -> echo .)
    PRINT           reduce using rule 14 (cuerpo -> echo .)
    ID              reduce using rule 14 (cuerpo -> echo .)
    INTEGER         reduce using rule 14 (cuerpo -> echo .)
    FLOAT           reduce using rule 14 (cuerpo -> echo .)
    $end            reduce using rule 14 (cuerpo -> echo .)
    RCURLY          reduce using rule 14 (cuerpo -> echo .)
    CONTINUE        reduce using rule 14 (cuerpo -> echo .)
    SEMICOLON       reduce using rule 14 (cuerpo -> echo .)
    BREAK           reduce using rule 14 (cuerpo -> echo .)


state 15

    (15) cuerpo -> fgets .

    OPEN_TAG        reduce using rule 15 (cuerpo -> fgets .)
    CLOSE_TAG       reduce using rule 15 (cuerpo -> fgets .)
    STRING          reduce using rule 15 (cuerpo -> fgets .)
    LPAREN          reduce using rule 15 (cuerpo -> fgets .)
    IF              reduce using rule 15 (cuerpo -> fgets .)
    FOR             reduce using rule 15 (cuerpo -> fgets .)
    SWITCH          reduce using rule 15 (cuerpo -> fgets .)
    VAR             reduce using rule 15 (cuerpo -> fgets .)
    FUNCTION        reduce using rule 15 (cuerpo -> fgets .)
    FN              reduce using rule 15 (cuerpo -> fgets .)
    ECHO            reduce using rule 15 (cuerpo -> fgets .)
    PRINT           reduce using rule 15 (cuerpo -> fgets .)
    ID              reduce using rule 15 (cuerpo -> fgets .)
    INTEGER         reduce using rule 15 (cuerpo -> fgets .)
    FLOAT           reduce using rule 15 (cuerpo -> fgets .)
    $end            reduce using rule 15 (cuerpo -> fgets .)
    RCURLY          reduce using rule 15 (cuerpo -> fgets .)
    CONTINUE        reduce using rule 15 (cuerpo -> fgets .)
    SEMICOLON       reduce using rule 15 (cuerpo -> fgets .)
    BREAK           reduce using rule 15 (cuerpo -> fgets .)


state 16

    (16) cuerpo -> stackDeclaration .

    OPEN_TAG        reduce using rule 16 (cuerpo -> stackDeclaration .)
    CLOSE_TAG       reduce using rule 16 (cuerpo -> stackDeclaration .)
    STRING          reduce using rule 16 (cuerpo -> stackDeclaration .)
    LPAREN          reduce using rule 16 (cuerpo -> stackDeclaration .)
    IF              reduce using rule 16 (cuerpo -> stackDeclaration .)
    FOR             reduce using rule 16 (cuerpo -> stackDeclaration .)
    SWITCH          reduce using rule 16 (cuerpo -> stackDeclaration .)
    VAR             reduce using rule 16 (cuerpo -> stackDeclaration .)
    FUNCTION        reduce using rule 16 (cuerpo -> stackDeclaration .)
    FN              reduce using rule 16 (cuerpo -> stackDeclaration .)
    ECHO            reduce using rule 16 (cuerpo -> stackDeclaration .)
    PRINT           reduce using rule 16 (cuerpo -> stackDeclaration .)
    ID              reduce using rule 16 (cuerpo -> stackDeclaration .)
    INTEGER         reduce using rule 16 (cuerpo -> stackDeclaration .)
    FLOAT           reduce using rule 16 (cuerpo -> stackDeclaration .)
    $end            reduce using rule 16 (cuerpo -> stackDeclaration .)
    RCURLY          reduce using rule 16 (cuerpo -> stackDeclaration .)
    CONTINUE        reduce using rule 16 (cuerpo -> stackDeclaration .)
    SEMICOLON       reduce using rule 16 (cuerpo -> stackDeclaration .)
    BREAK           reduce using rule 16 (cuerpo -> stackDeclaration .)


state 17

    (17) cuerpo -> stackPush .

    OPEN_TAG        reduce using rule 17 (cuerpo -> stackPush .)
    CLOSE_TAG       reduce using rule 17 (cuerpo -> stackPush .)
    STRING          reduce using rule 17 (cuerpo -> stackPush .)
    LPAREN          reduce using rule 17 (cuerpo -> stackPush .)
    IF              reduce using rule 17 (cuerpo -> stackPush .)
    FOR             reduce using rule 17 (cuerpo -> stackPush .)
    SWITCH          reduce using rule 17 (cuerpo -> stackPush .)
    VAR             reduce using rule 17 (cuerpo -> stackPush .)
    FUNCTION        reduce using rule 17 (cuerpo -> stackPush .)
    FN              reduce using rule 17 (cuerpo -> stackPush .)
    ECHO            reduce using rule 17 (cuerpo -> stackPush .)
    PRINT           reduce using rule 17 (cuerpo -> stackPush .)
    ID              reduce using rule 17 (cuerpo -> stackPush .)
    INTEGER         reduce using rule 17 (cuerpo -> stackPush .)
    FLOAT           reduce using rule 17 (cuerpo -> stackPush .)
    $end            reduce using rule 17 (cuerpo -> stackPush .)
    RCURLY          reduce using rule 17 (cuerpo -> stackPush .)
    CONTINUE        reduce using rule 17 (cuerpo -> stackPush .)
    SEMICOLON       reduce using rule 17 (cuerpo -> stackPush .)
    BREAK           reduce using rule 17 (cuerpo -> stackPush .)


state 18

    (18) cuerpo -> stackPop .

    OPEN_TAG        reduce using rule 18 (cuerpo -> stackPop .)
    CLOSE_TAG       reduce using rule 18 (cuerpo -> stackPop .)
    STRING          reduce using rule 18 (cuerpo -> stackPop .)
    LPAREN          reduce using rule 18 (cuerpo -> stackPop .)
    IF              reduce using rule 18 (cuerpo -> stackPop .)
    FOR             reduce using rule 18 (cuerpo -> stackPop .)
    SWITCH          reduce using rule 18 (cuerpo -> stackPop .)
    VAR             reduce using rule 18 (cuerpo -> stackPop .)
    FUNCTION        reduce using rule 18 (cuerpo -> stackPop .)
    FN              reduce using rule 18 (cuerpo -> stackPop .)
    ECHO            reduce using rule 18 (cuerpo -> stackPop .)
    PRINT           reduce using rule 18 (cuerpo -> stackPop .)
    ID              reduce using rule 18 (cuerpo -> stackPop .)
    INTEGER         reduce using rule 18 (cuerpo -> stackPop .)
    FLOAT           reduce using rule 18 (cuerpo -> stackPop .)
    $end            reduce using rule 18 (cuerpo -> stackPop .)
    RCURLY          reduce using rule 18 (cuerpo -> stackPop .)
    CONTINUE        reduce using rule 18 (cuerpo -> stackPop .)
    SEMICOLON       reduce using rule 18 (cuerpo -> stackPop .)
    BREAK           reduce using rule 18 (cuerpo -> stackPop .)


state 19

    (19) cuerpo -> line .

    OPEN_TAG        reduce using rule 19 (cuerpo -> line .)
    CLOSE_TAG       reduce using rule 19 (cuerpo -> line .)
    STRING          reduce using rule 19 (cuerpo -> line .)
    LPAREN          reduce using rule 19 (cuerpo -> line .)
    IF              reduce using rule 19 (cuerpo -> line .)
    FOR             reduce using rule 19 (cuerpo -> line .)
    SWITCH          reduce using rule 19 (cuerpo -> line .)
    VAR             reduce using rule 19 (cuerpo -> line .)
    FUNCTION        reduce using rule 19 (cuerpo -> line .)
    FN              reduce using rule 19 (cuerpo -> line .)
    ECHO            reduce using rule 19 (cuerpo -> line .)
    PRINT           reduce using rule 19 (cuerpo -> line .)
    ID              reduce using rule 19 (cuerpo -> line .)
    INTEGER         reduce using rule 19 (cuerpo -> line .)
    FLOAT           reduce using rule 19 (cuerpo -> line .)
    $end            reduce using rule 19 (cuerpo -> line .)
    RCURLY          reduce using rule 19 (cuerpo -> line .)
    CONTINUE        reduce using rule 19 (cuerpo -> line .)
    SEMICOLON       reduce using rule 19 (cuerpo -> line .)
    BREAK           reduce using rule 19 (cuerpo -> line .)


state 20

    (20) cuerpo -> print .

    OPEN_TAG        reduce using rule 20 (cuerpo -> print .)
    CLOSE_TAG       reduce using rule 20 (cuerpo -> print .)
    STRING          reduce using rule 20 (cuerpo -> print .)
    LPAREN          reduce using rule 20 (cuerpo -> print .)
    IF              reduce using rule 20 (cuerpo -> print .)
    FOR             reduce using rule 20 (cuerpo -> print .)
    SWITCH          reduce using rule 20 (cuerpo -> print .)
    VAR             reduce using rule 20 (cuerpo -> print .)
    FUNCTION        reduce using rule 20 (cuerpo -> print .)
    FN              reduce using rule 20 (cuerpo -> print .)
    ECHO            reduce using rule 20 (cuerpo -> print .)
    PRINT           reduce using rule 20 (cuerpo -> print .)
    ID              reduce using rule 20 (cuerpo -> print .)
    INTEGER         reduce using rule 20 (cuerpo -> print .)
    FLOAT           reduce using rule 20 (cuerpo -> print .)
    $end            reduce using rule 20 (cuerpo -> print .)
    RCURLY          reduce using rule 20 (cuerpo -> print .)
    CONTINUE        reduce using rule 20 (cuerpo -> print .)
    SEMICOLON       reduce using rule 20 (cuerpo -> print .)
    BREAK           reduce using rule 20 (cuerpo -> print .)


state 21

    (21) cuerpo -> logicalCondition .

    OPEN_TAG        reduce using rule 21 (cuerpo -> logicalCondition .)
    CLOSE_TAG       reduce using rule 21 (cuerpo -> logicalCondition .)
    STRING          reduce using rule 21 (cuerpo -> logicalCondition .)
    LPAREN          reduce using rule 21 (cuerpo -> logicalCondition .)
    IF              reduce using rule 21 (cuerpo -> logicalCondition .)
    FOR             reduce using rule 21 (cuerpo -> logicalCondition .)
    SWITCH          reduce using rule 21 (cuerpo -> logicalCondition .)
    VAR             reduce using rule 21 (cuerpo -> logicalCondition .)
    FUNCTION        reduce using rule 21 (cuerpo -> logicalCondition .)
    FN              reduce using rule 21 (cuerpo -> logicalCondition .)
    ECHO            reduce using rule 21 (cuerpo -> logicalCondition .)
    PRINT           reduce using rule 21 (cuerpo -> logicalCondition .)
    ID              reduce using rule 21 (cuerpo -> logicalCondition .)
    INTEGER         reduce using rule 21 (cuerpo -> logicalCondition .)
    FLOAT           reduce using rule 21 (cuerpo -> logicalCondition .)
    $end            reduce using rule 21 (cuerpo -> logicalCondition .)
    RCURLY          reduce using rule 21 (cuerpo -> logicalCondition .)
    CONTINUE        reduce using rule 21 (cuerpo -> logicalCondition .)
    SEMICOLON       reduce using rule 21 (cuerpo -> logicalCondition .)
    BREAK           reduce using rule 21 (cuerpo -> logicalCondition .)


state 22

    (22) cuerpo -> OPEN_TAG .

    OPEN_TAG        reduce using rule 22 (cuerpo -> OPEN_TAG .)
    CLOSE_TAG       reduce using rule 22 (cuerpo -> OPEN_TAG .)
    STRING          reduce using rule 22 (cuerpo -> OPEN_TAG .)
    LPAREN          reduce using rule 22 (cuerpo -> OPEN_TAG .)
    IF              reduce using rule 22 (cuerpo -> OPEN_TAG .)
    FOR             reduce using rule 22 (cuerpo -> OPEN_TAG .)
    SWITCH          reduce using rule 22 (cuerpo -> OPEN_TAG .)
    VAR             reduce using rule 22 (cuerpo -> OPEN_TAG .)
    FUNCTION        reduce using rule 22 (cuerpo -> OPEN_TAG .)
    FN              reduce using rule 22 (cuerpo -> OPEN_TAG .)
    ECHO            reduce using rule 22 (cuerpo -> OPEN_TAG .)
    PRINT           reduce using rule 22 (cuerpo -> OPEN_TAG .)
    ID              reduce using rule 22 (cuerpo -> OPEN_TAG .)
    INTEGER         reduce using rule 22 (cuerpo -> OPEN_TAG .)
    FLOAT           reduce using rule 22 (cuerpo -> OPEN_TAG .)
    $end            reduce using rule 22 (cuerpo -> OPEN_TAG .)
    RCURLY          reduce using rule 22 (cuerpo -> OPEN_TAG .)
    CONTINUE        reduce using rule 22 (cuerpo -> OPEN_TAG .)
    SEMICOLON       reduce using rule 22 (cuerpo -> OPEN_TAG .)
    BREAK           reduce using rule 22 (cuerpo -> OPEN_TAG .)


state 23

    (23) cuerpo -> CLOSE_TAG .

    OPEN_TAG        reduce using rule 23 (cuerpo -> CLOSE_TAG .)
    CLOSE_TAG       reduce using rule 23 (cuerpo -> CLOSE_TAG .)
    STRING          reduce using rule 23 (cuerpo -> CLOSE_TAG .)
    LPAREN          reduce using rule 23 (cuerpo -> CLOSE_TAG .)
    IF              reduce using rule 23 (cuerpo -> CLOSE_TAG .)
    FOR             reduce using rule 23 (cuerpo -> CLOSE_TAG .)
    SWITCH          reduce using rule 23 (cuerpo -> CLOSE_TAG .)
    VAR             reduce using rule 23 (cuerpo -> CLOSE_TAG .)
    FUNCTION        reduce using rule 23 (cuerpo -> CLOSE_TAG .)
    FN              reduce using rule 23 (cuerpo -> CLOSE_TAG .)
    ECHO            reduce using rule 23 (cuerpo -> CLOSE_TAG .)
    PRINT           reduce using rule 23 (cuerpo -> CLOSE_TAG .)
    ID              reduce using rule 23 (cuerpo -> CLOSE_TAG .)
    INTEGER         reduce using rule 23 (cuerpo -> CLOSE_TAG .)
    FLOAT           reduce using rule 23 (cuerpo -> CLOSE_TAG .)
    $end            reduce using rule 23 (cuerpo -> CLOSE_TAG .)
    RCURLY          reduce using rule 23 (cuerpo -> CLOSE_TAG .)
    CONTINUE        reduce using rule 23 (cuerpo -> CLOSE_TAG .)
    SEMICOLON       reduce using rule 23 (cuerpo -> CLOSE_TAG .)
    BREAK           reduce using rule 23 (cuerpo -> CLOSE_TAG .)


state 24

    (24) cuerpo -> stringConcatenation .
    (110) stringConcatenation -> stringConcatenation . CONCAT stringConcatenation
    (81) value -> stringConcatenation .

  ! shift/reduce conflict for CONCAT resolved as shift
  ! reduce/reduce conflict for OPEN_TAG resolved using rule 24 (cuerpo -> stringConcatenation .)
  ! reduce/reduce conflict for CLOSE_TAG resolved using rule 24 (cuerpo -> stringConcatenation .)
  ! reduce/reduce conflict for STRING resolved using rule 24 (cuerpo -> stringConcatenation .)
  ! reduce/reduce conflict for LPAREN resolved using rule 24 (cuerpo -> stringConcatenation .)
  ! reduce/reduce conflict for IF resolved using rule 24 (cuerpo -> stringConcatenation .)
  ! reduce/reduce conflict for FOR resolved using rule 24 (cuerpo -> stringConcatenation .)
  ! reduce/reduce conflict for SWITCH resolved using rule 24 (cuerpo -> stringConcatenation .)
  ! reduce/reduce conflict for VAR resolved using rule 24 (cuerpo -> stringConcatenation .)
  ! reduce/reduce conflict for FUNCTION resolved using rule 24 (cuerpo -> stringConcatenation .)
  ! reduce/reduce conflict for FN resolved using rule 24 (cuerpo -> stringConcatenation .)
  ! reduce/reduce conflict for ECHO resolved using rule 24 (cuerpo -> stringConcatenation .)
  ! reduce/reduce conflict for PRINT resolved using rule 24 (cuerpo -> stringConcatenation .)
  ! reduce/reduce conflict for ID resolved using rule 24 (cuerpo -> stringConcatenation .)
  ! reduce/reduce conflict for INTEGER resolved using rule 24 (cuerpo -> stringConcatenation .)
  ! reduce/reduce conflict for FLOAT resolved using rule 24 (cuerpo -> stringConcatenation .)
  ! reduce/reduce conflict for $end resolved using rule 24 (cuerpo -> stringConcatenation .)
  ! reduce/reduce conflict for RCURLY resolved using rule 24 (cuerpo -> stringConcatenation .)
  ! reduce/reduce conflict for CONTINUE resolved using rule 24 (cuerpo -> stringConcatenation .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 24 (cuerpo -> stringConcatenation .)
  ! reduce/reduce conflict for BREAK resolved using rule 24 (cuerpo -> stringConcatenation .)
    OPEN_TAG        reduce using rule 24 (cuerpo -> stringConcatenation .)
    CLOSE_TAG       reduce using rule 24 (cuerpo -> stringConcatenation .)
    STRING          reduce using rule 24 (cuerpo -> stringConcatenation .)
    LPAREN          reduce using rule 24 (cuerpo -> stringConcatenation .)
    IF              reduce using rule 24 (cuerpo -> stringConcatenation .)
    FOR             reduce using rule 24 (cuerpo -> stringConcatenation .)
    SWITCH          reduce using rule 24 (cuerpo -> stringConcatenation .)
    VAR             reduce using rule 24 (cuerpo -> stringConcatenation .)
    FUNCTION        reduce using rule 24 (cuerpo -> stringConcatenation .)
    FN              reduce using rule 24 (cuerpo -> stringConcatenation .)
    ECHO            reduce using rule 24 (cuerpo -> stringConcatenation .)
    PRINT           reduce using rule 24 (cuerpo -> stringConcatenation .)
    ID              reduce using rule 24 (cuerpo -> stringConcatenation .)
    INTEGER         reduce using rule 24 (cuerpo -> stringConcatenation .)
    FLOAT           reduce using rule 24 (cuerpo -> stringConcatenation .)
    $end            reduce using rule 24 (cuerpo -> stringConcatenation .)
    RCURLY          reduce using rule 24 (cuerpo -> stringConcatenation .)
    CONTINUE        reduce using rule 24 (cuerpo -> stringConcatenation .)
    SEMICOLON       reduce using rule 24 (cuerpo -> stringConcatenation .)
    BREAK           reduce using rule 24 (cuerpo -> stringConcatenation .)
    CONCAT          shift and go to state 50
    IS_EQUAL        reduce using rule 81 (value -> stringConcatenation .)
    IDENTICAL       reduce using rule 81 (value -> stringConcatenation .)
    NOTEQUAL        reduce using rule 81 (value -> stringConcatenation .)
    LESSTHAN        reduce using rule 81 (value -> stringConcatenation .)
    GREATERTHAN     reduce using rule 81 (value -> stringConcatenation .)
    LESSEQUALTHAN   reduce using rule 81 (value -> stringConcatenation .)
    GREATEREQUALTHAN reduce using rule 81 (value -> stringConcatenation .)
    PLUS            reduce using rule 81 (value -> stringConcatenation .)
    MINUS           reduce using rule 81 (value -> stringConcatenation .)
    TIMES           reduce using rule 81 (value -> stringConcatenation .)
    DIVIDE          reduce using rule 81 (value -> stringConcatenation .)
    MOD             reduce using rule 81 (value -> stringConcatenation .)
    EXP             reduce using rule 81 (value -> stringConcatenation .)

  ! CONCAT          [ reduce using rule 81 (value -> stringConcatenation .) ]
  ! OPEN_TAG        [ reduce using rule 81 (value -> stringConcatenation .) ]
  ! CLOSE_TAG       [ reduce using rule 81 (value -> stringConcatenation .) ]
  ! STRING          [ reduce using rule 81 (value -> stringConcatenation .) ]
  ! LPAREN          [ reduce using rule 81 (value -> stringConcatenation .) ]
  ! IF              [ reduce using rule 81 (value -> stringConcatenation .) ]
  ! FOR             [ reduce using rule 81 (value -> stringConcatenation .) ]
  ! SWITCH          [ reduce using rule 81 (value -> stringConcatenation .) ]
  ! VAR             [ reduce using rule 81 (value -> stringConcatenation .) ]
  ! FUNCTION        [ reduce using rule 81 (value -> stringConcatenation .) ]
  ! FN              [ reduce using rule 81 (value -> stringConcatenation .) ]
  ! ECHO            [ reduce using rule 81 (value -> stringConcatenation .) ]
  ! PRINT           [ reduce using rule 81 (value -> stringConcatenation .) ]
  ! ID              [ reduce using rule 81 (value -> stringConcatenation .) ]
  ! INTEGER         [ reduce using rule 81 (value -> stringConcatenation .) ]
  ! FLOAT           [ reduce using rule 81 (value -> stringConcatenation .) ]
  ! $end            [ reduce using rule 81 (value -> stringConcatenation .) ]
  ! RCURLY          [ reduce using rule 81 (value -> stringConcatenation .) ]
  ! CONTINUE        [ reduce using rule 81 (value -> stringConcatenation .) ]
  ! SEMICOLON       [ reduce using rule 81 (value -> stringConcatenation .) ]
  ! BREAK           [ reduce using rule 81 (value -> stringConcatenation .) ]


state 25

    (25) cuerpo -> callFunction .

    OPEN_TAG        reduce using rule 25 (cuerpo -> callFunction .)
    CLOSE_TAG       reduce using rule 25 (cuerpo -> callFunction .)
    STRING          reduce using rule 25 (cuerpo -> callFunction .)
    LPAREN          reduce using rule 25 (cuerpo -> callFunction .)
    IF              reduce using rule 25 (cuerpo -> callFunction .)
    FOR             reduce using rule 25 (cuerpo -> callFunction .)
    SWITCH          reduce using rule 25 (cuerpo -> callFunction .)
    VAR             reduce using rule 25 (cuerpo -> callFunction .)
    FUNCTION        reduce using rule 25 (cuerpo -> callFunction .)
    FN              reduce using rule 25 (cuerpo -> callFunction .)
    ECHO            reduce using rule 25 (cuerpo -> callFunction .)
    PRINT           reduce using rule 25 (cuerpo -> callFunction .)
    ID              reduce using rule 25 (cuerpo -> callFunction .)
    INTEGER         reduce using rule 25 (cuerpo -> callFunction .)
    FLOAT           reduce using rule 25 (cuerpo -> callFunction .)
    $end            reduce using rule 25 (cuerpo -> callFunction .)
    RCURLY          reduce using rule 25 (cuerpo -> callFunction .)
    CONTINUE        reduce using rule 25 (cuerpo -> callFunction .)
    SEMICOLON       reduce using rule 25 (cuerpo -> callFunction .)
    BREAK           reduce using rule 25 (cuerpo -> callFunction .)


state 26

    (71) arithmeticExpression -> value .
    (109) stringConcatenation -> value . CONCAT value
    (102) comparingValue -> value . comparingSign value
    (95) comparingSign -> . IS_EQUAL
    (96) comparingSign -> . IDENTICAL
    (97) comparingSign -> . NOTEQUAL
    (98) comparingSign -> . LESSTHAN
    (99) comparingSign -> . GREATERTHAN
    (100) comparingSign -> . LESSEQUALTHAN
    (101) comparingSign -> . GREATEREQUALTHAN

    PLUS            reduce using rule 71 (arithmeticExpression -> value .)
    MINUS           reduce using rule 71 (arithmeticExpression -> value .)
    TIMES           reduce using rule 71 (arithmeticExpression -> value .)
    DIVIDE          reduce using rule 71 (arithmeticExpression -> value .)
    MOD             reduce using rule 71 (arithmeticExpression -> value .)
    EXP             reduce using rule 71 (arithmeticExpression -> value .)
    OPEN_TAG        reduce using rule 71 (arithmeticExpression -> value .)
    CLOSE_TAG       reduce using rule 71 (arithmeticExpression -> value .)
    STRING          reduce using rule 71 (arithmeticExpression -> value .)
    LPAREN          reduce using rule 71 (arithmeticExpression -> value .)
    IF              reduce using rule 71 (arithmeticExpression -> value .)
    FOR             reduce using rule 71 (arithmeticExpression -> value .)
    SWITCH          reduce using rule 71 (arithmeticExpression -> value .)
    VAR             reduce using rule 71 (arithmeticExpression -> value .)
    FUNCTION        reduce using rule 71 (arithmeticExpression -> value .)
    FN              reduce using rule 71 (arithmeticExpression -> value .)
    ECHO            reduce using rule 71 (arithmeticExpression -> value .)
    PRINT           reduce using rule 71 (arithmeticExpression -> value .)
    ID              reduce using rule 71 (arithmeticExpression -> value .)
    INTEGER         reduce using rule 71 (arithmeticExpression -> value .)
    FLOAT           reduce using rule 71 (arithmeticExpression -> value .)
    $end            reduce using rule 71 (arithmeticExpression -> value .)
    RCURLY          reduce using rule 71 (arithmeticExpression -> value .)
    CONTINUE        reduce using rule 71 (arithmeticExpression -> value .)
    SEMICOLON       reduce using rule 71 (arithmeticExpression -> value .)
    BREAK           reduce using rule 71 (arithmeticExpression -> value .)
    CONCAT          shift and go to state 51
    IS_EQUAL        shift and go to state 53
    IDENTICAL       shift and go to state 54
    NOTEQUAL        shift and go to state 55
    LESSTHAN        shift and go to state 56
    GREATERTHAN     shift and go to state 57
    LESSEQUALTHAN   shift and go to state 58
    GREATEREQUALTHAN shift and go to state 59

    comparingSign                  shift and go to state 52

state 27

    (72) arithmeticExpression -> STRING .
    (80) value -> STRING .

  ! reduce/reduce conflict for PLUS resolved using rule 72 (arithmeticExpression -> STRING .)
  ! reduce/reduce conflict for MINUS resolved using rule 72 (arithmeticExpression -> STRING .)
  ! reduce/reduce conflict for TIMES resolved using rule 72 (arithmeticExpression -> STRING .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 72 (arithmeticExpression -> STRING .)
  ! reduce/reduce conflict for MOD resolved using rule 72 (arithmeticExpression -> STRING .)
  ! reduce/reduce conflict for EXP resolved using rule 72 (arithmeticExpression -> STRING .)
  ! reduce/reduce conflict for OPEN_TAG resolved using rule 72 (arithmeticExpression -> STRING .)
  ! reduce/reduce conflict for CLOSE_TAG resolved using rule 72 (arithmeticExpression -> STRING .)
  ! reduce/reduce conflict for STRING resolved using rule 72 (arithmeticExpression -> STRING .)
  ! reduce/reduce conflict for LPAREN resolved using rule 72 (arithmeticExpression -> STRING .)
  ! reduce/reduce conflict for IF resolved using rule 72 (arithmeticExpression -> STRING .)
  ! reduce/reduce conflict for FOR resolved using rule 72 (arithmeticExpression -> STRING .)
  ! reduce/reduce conflict for SWITCH resolved using rule 72 (arithmeticExpression -> STRING .)
  ! reduce/reduce conflict for VAR resolved using rule 72 (arithmeticExpression -> STRING .)
  ! reduce/reduce conflict for FUNCTION resolved using rule 72 (arithmeticExpression -> STRING .)
  ! reduce/reduce conflict for FN resolved using rule 72 (arithmeticExpression -> STRING .)
  ! reduce/reduce conflict for ECHO resolved using rule 72 (arithmeticExpression -> STRING .)
  ! reduce/reduce conflict for PRINT resolved using rule 72 (arithmeticExpression -> STRING .)
  ! reduce/reduce conflict for ID resolved using rule 72 (arithmeticExpression -> STRING .)
  ! reduce/reduce conflict for INTEGER resolved using rule 72 (arithmeticExpression -> STRING .)
  ! reduce/reduce conflict for FLOAT resolved using rule 72 (arithmeticExpression -> STRING .)
  ! reduce/reduce conflict for $end resolved using rule 72 (arithmeticExpression -> STRING .)
  ! reduce/reduce conflict for RPAREN resolved using rule 72 (arithmeticExpression -> STRING .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 72 (arithmeticExpression -> STRING .)
  ! reduce/reduce conflict for RCURLY resolved using rule 72 (arithmeticExpression -> STRING .)
  ! reduce/reduce conflict for CONTINUE resolved using rule 72 (arithmeticExpression -> STRING .)
  ! reduce/reduce conflict for BREAK resolved using rule 72 (arithmeticExpression -> STRING .)
    PLUS            reduce using rule 72 (arithmeticExpression -> STRING .)
    MINUS           reduce using rule 72 (arithmeticExpression -> STRING .)
    TIMES           reduce using rule 72 (arithmeticExpression -> STRING .)
    DIVIDE          reduce using rule 72 (arithmeticExpression -> STRING .)
    MOD             reduce using rule 72 (arithmeticExpression -> STRING .)
    EXP             reduce using rule 72 (arithmeticExpression -> STRING .)
    OPEN_TAG        reduce using rule 72 (arithmeticExpression -> STRING .)
    CLOSE_TAG       reduce using rule 72 (arithmeticExpression -> STRING .)
    STRING          reduce using rule 72 (arithmeticExpression -> STRING .)
    LPAREN          reduce using rule 72 (arithmeticExpression -> STRING .)
    IF              reduce using rule 72 (arithmeticExpression -> STRING .)
    FOR             reduce using rule 72 (arithmeticExpression -> STRING .)
    SWITCH          reduce using rule 72 (arithmeticExpression -> STRING .)
    VAR             reduce using rule 72 (arithmeticExpression -> STRING .)
    FUNCTION        reduce using rule 72 (arithmeticExpression -> STRING .)
    FN              reduce using rule 72 (arithmeticExpression -> STRING .)
    ECHO            reduce using rule 72 (arithmeticExpression -> STRING .)
    PRINT           reduce using rule 72 (arithmeticExpression -> STRING .)
    ID              reduce using rule 72 (arithmeticExpression -> STRING .)
    INTEGER         reduce using rule 72 (arithmeticExpression -> STRING .)
    FLOAT           reduce using rule 72 (arithmeticExpression -> STRING .)
    $end            reduce using rule 72 (arithmeticExpression -> STRING .)
    RPAREN          reduce using rule 72 (arithmeticExpression -> STRING .)
    SEMICOLON       reduce using rule 72 (arithmeticExpression -> STRING .)
    RCURLY          reduce using rule 72 (arithmeticExpression -> STRING .)
    CONTINUE        reduce using rule 72 (arithmeticExpression -> STRING .)
    BREAK           reduce using rule 72 (arithmeticExpression -> STRING .)
    CONCAT          reduce using rule 80 (value -> STRING .)
    IS_EQUAL        reduce using rule 80 (value -> STRING .)
    IDENTICAL       reduce using rule 80 (value -> STRING .)
    NOTEQUAL        reduce using rule 80 (value -> STRING .)
    LESSTHAN        reduce using rule 80 (value -> STRING .)
    GREATERTHAN     reduce using rule 80 (value -> STRING .)
    LESSEQUALTHAN   reduce using rule 80 (value -> STRING .)
    GREATEREQUALTHAN reduce using rule 80 (value -> STRING .)

  ! PLUS            [ reduce using rule 80 (value -> STRING .) ]
  ! MINUS           [ reduce using rule 80 (value -> STRING .) ]
  ! TIMES           [ reduce using rule 80 (value -> STRING .) ]
  ! DIVIDE          [ reduce using rule 80 (value -> STRING .) ]
  ! MOD             [ reduce using rule 80 (value -> STRING .) ]
  ! EXP             [ reduce using rule 80 (value -> STRING .) ]
  ! OPEN_TAG        [ reduce using rule 80 (value -> STRING .) ]
  ! CLOSE_TAG       [ reduce using rule 80 (value -> STRING .) ]
  ! STRING          [ reduce using rule 80 (value -> STRING .) ]
  ! LPAREN          [ reduce using rule 80 (value -> STRING .) ]
  ! IF              [ reduce using rule 80 (value -> STRING .) ]
  ! FOR             [ reduce using rule 80 (value -> STRING .) ]
  ! SWITCH          [ reduce using rule 80 (value -> STRING .) ]
  ! VAR             [ reduce using rule 80 (value -> STRING .) ]
  ! FUNCTION        [ reduce using rule 80 (value -> STRING .) ]
  ! FN              [ reduce using rule 80 (value -> STRING .) ]
  ! ECHO            [ reduce using rule 80 (value -> STRING .) ]
  ! PRINT           [ reduce using rule 80 (value -> STRING .) ]
  ! ID              [ reduce using rule 80 (value -> STRING .) ]
  ! INTEGER         [ reduce using rule 80 (value -> STRING .) ]
  ! FLOAT           [ reduce using rule 80 (value -> STRING .) ]
  ! $end            [ reduce using rule 80 (value -> STRING .) ]
  ! RPAREN          [ reduce using rule 80 (value -> STRING .) ]
  ! SEMICOLON       [ reduce using rule 80 (value -> STRING .) ]
  ! RCURLY          [ reduce using rule 80 (value -> STRING .) ]
  ! CONTINUE        [ reduce using rule 80 (value -> STRING .) ]
  ! BREAK           [ reduce using rule 80 (value -> STRING .) ]


state 28

    (73) arithmeticExpression -> LPAREN . arithmeticExpression RPAREN
    (105) logicalCondition -> LPAREN . logicalCondition RPAREN
    (71) arithmeticExpression -> . value
    (72) arithmeticExpression -> . STRING
    (73) arithmeticExpression -> . LPAREN arithmeticExpression RPAREN
    (74) arithmeticExpression -> . arithmeticExpression arithmeticOperator arithmeticExpression
    (103) logicalCondition -> . comparingValue
    (104) logicalCondition -> . comparingValue conditionOperator comparingValue
    (105) logicalCondition -> . LPAREN logicalCondition RPAREN
    (77) value -> . VAR
    (78) value -> . INTEGER
    (79) value -> . FLOAT
    (80) value -> . STRING
    (81) value -> . stringConcatenation
    (102) comparingValue -> . value comparingSign value
    (109) stringConcatenation -> . value CONCAT value
    (110) stringConcatenation -> . stringConcatenation CONCAT stringConcatenation

    STRING          shift and go to state 27
    LPAREN          shift and go to state 28
    VAR             shift and go to state 63
    INTEGER         shift and go to state 40
    FLOAT           shift and go to state 41

    arithmeticExpression           shift and go to state 60
    logicalCondition               shift and go to state 61
    value                          shift and go to state 62
    comparingValue                 shift and go to state 39
    stringConcatenation            shift and go to state 64

state 29

    (31) if_elseStatement -> IF . LPAREN logicalCondition RPAREN LCURLY ifStatementBody RCURLY ELSE LCURLY ifStatementBody RCURLY
    (32) if_elseStatement -> IF . LPAREN logicalCondition RPAREN LCURLY ifStatementBody

    LPAREN          shift and go to state 65


state 30

    (36) forStatement -> FOR . LPAREN forStatementCondition RPAREN LCURLY forStatementBody RCURLY

    LPAREN          shift and go to state 66


state 31

    (26) switchStatement -> SWITCH . LPAREN value RPAREN LCURLY switchCases switchDefault RCURLY

    LPAREN          shift and go to state 67


state 32

    (42) arrayAsignation -> VAR . EQUAL arrayDeclaration SEMICOLON
    (53) queueDeclaration -> VAR . EQUAL NEW QUEUE SEMICOLON
    (54) queueEnqueue -> VAR . OBJOP PUSH LPAREN value RPAREN SEMICOLON
    (55) queueDequeue -> VAR . OBJOP POP SEMICOLON
    (70) fgets -> VAR . EQUAL FGETS LPAREN STDIN RPAREN SEMICOLON
    (50) stackDeclaration -> VAR . EQUAL NEW STACK SEMICOLON
    (51) stackPush -> VAR . OBJOP PUSH LPAREN value RPAREN SEMICOLON
    (52) stackPop -> VAR . OBJOP POP SEMICOLON
    (77) value -> VAR .
    (89) variableAsignation -> VAR . EQUAL value
    (90) variableAsignation -> VAR . EQUAL arithmeticExpression
    (91) variableAsignation -> VAR . INCREMENT
    (92) variableAsignation -> VAR . DECREMENT
    (93) variableAsignation -> VAR . EQUAL stringConcatenation
    (94) variableAsignation -> VAR . EQUAL anonymousFunction

    EQUAL           shift and go to state 68
    OBJOP           shift and go to state 69
    CONCAT          reduce using rule 77 (value -> VAR .)
    IS_EQUAL        reduce using rule 77 (value -> VAR .)
    IDENTICAL       reduce using rule 77 (value -> VAR .)
    NOTEQUAL        reduce using rule 77 (value -> VAR .)
    LESSTHAN        reduce using rule 77 (value -> VAR .)
    GREATERTHAN     reduce using rule 77 (value -> VAR .)
    LESSEQUALTHAN   reduce using rule 77 (value -> VAR .)
    GREATEREQUALTHAN reduce using rule 77 (value -> VAR .)
    PLUS            reduce using rule 77 (value -> VAR .)
    MINUS           reduce using rule 77 (value -> VAR .)
    TIMES           reduce using rule 77 (value -> VAR .)
    DIVIDE          reduce using rule 77 (value -> VAR .)
    MOD             reduce using rule 77 (value -> VAR .)
    EXP             reduce using rule 77 (value -> VAR .)
    OPEN_TAG        reduce using rule 77 (value -> VAR .)
    CLOSE_TAG       reduce using rule 77 (value -> VAR .)
    STRING          reduce using rule 77 (value -> VAR .)
    LPAREN          reduce using rule 77 (value -> VAR .)
    IF              reduce using rule 77 (value -> VAR .)
    FOR             reduce using rule 77 (value -> VAR .)
    SWITCH          reduce using rule 77 (value -> VAR .)
    VAR             reduce using rule 77 (value -> VAR .)
    FUNCTION        reduce using rule 77 (value -> VAR .)
    FN              reduce using rule 77 (value -> VAR .)
    ECHO            reduce using rule 77 (value -> VAR .)
    PRINT           reduce using rule 77 (value -> VAR .)
    ID              reduce using rule 77 (value -> VAR .)
    INTEGER         reduce using rule 77 (value -> VAR .)
    FLOAT           reduce using rule 77 (value -> VAR .)
    $end            reduce using rule 77 (value -> VAR .)
    RCURLY          reduce using rule 77 (value -> VAR .)
    CONTINUE        reduce using rule 77 (value -> VAR .)
    SEMICOLON       reduce using rule 77 (value -> VAR .)
    BREAK           reduce using rule 77 (value -> VAR .)
    INCREMENT       shift and go to state 70
    DECREMENT       shift and go to state 71


state 33

    (56) defineFunction -> FUNCTION . ID LPAREN arguments RPAREN LCURLY programa RCURLY
    (57) defineFunction -> FUNCTION . ID LPAREN RPAREN LCURLY programa RCURLY
    (60) anonymousFunction -> FUNCTION . LPAREN RPAREN LCURLY cuerpo RCURLY
    (61) anonymousFunction -> FUNCTION . LPAREN arguments RPAREN LCURLY cuerpo RCURLY

    ID              shift and go to state 72
    LPAREN          shift and go to state 73


state 34

    (75) callFunction -> ID . LPAREN RPAREN SEMICOLON
    (76) callFunction -> ID . LPAREN value RPAREN SEMICOLON

    LPAREN          shift and go to state 74


state 35

    (62) arrowFunction -> FN . LPAREN VAR RPAREN FNARROW arrowBody SEMICOLON

    LPAREN          shift and go to state 75


state 36

    (65) echo -> ECHO . values SEMICOLON
    (68) values -> . value
    (69) values -> . values COMMA value
    (77) value -> . VAR
    (78) value -> . INTEGER
    (79) value -> . FLOAT
    (80) value -> . STRING
    (81) value -> . stringConcatenation
    (109) stringConcatenation -> . value CONCAT value
    (110) stringConcatenation -> . stringConcatenation CONCAT stringConcatenation

    VAR             shift and go to state 63
    INTEGER         shift and go to state 40
    FLOAT           shift and go to state 41
    STRING          shift and go to state 78

    values                         shift and go to state 76
    value                          shift and go to state 77
    stringConcatenation            shift and go to state 64

state 37

    (88) line -> variableAsignation . SEMICOLON

    SEMICOLON       shift and go to state 79


state 38

    (66) print -> PRINT . LPAREN values RPAREN SEMICOLON
    (67) print -> PRINT . value SEMICOLON
    (77) value -> . VAR
    (78) value -> . INTEGER
    (79) value -> . FLOAT
    (80) value -> . STRING
    (81) value -> . stringConcatenation
    (109) stringConcatenation -> . value CONCAT value
    (110) stringConcatenation -> . stringConcatenation CONCAT stringConcatenation

    LPAREN          shift and go to state 80
    VAR             shift and go to state 63
    INTEGER         shift and go to state 40
    FLOAT           shift and go to state 41
    STRING          shift and go to state 78

    value                          shift and go to state 81
    stringConcatenation            shift and go to state 64

state 39

    (103) logicalCondition -> comparingValue .
    (104) logicalCondition -> comparingValue . conditionOperator comparingValue
    (106) conditionOperator -> . AND
    (107) conditionOperator -> . OR
    (108) conditionOperator -> . XOR

    OPEN_TAG        reduce using rule 103 (logicalCondition -> comparingValue .)
    CLOSE_TAG       reduce using rule 103 (logicalCondition -> comparingValue .)
    STRING          reduce using rule 103 (logicalCondition -> comparingValue .)
    LPAREN          reduce using rule 103 (logicalCondition -> comparingValue .)
    IF              reduce using rule 103 (logicalCondition -> comparingValue .)
    FOR             reduce using rule 103 (logicalCondition -> comparingValue .)
    SWITCH          reduce using rule 103 (logicalCondition -> comparingValue .)
    VAR             reduce using rule 103 (logicalCondition -> comparingValue .)
    FUNCTION        reduce using rule 103 (logicalCondition -> comparingValue .)
    FN              reduce using rule 103 (logicalCondition -> comparingValue .)
    ECHO            reduce using rule 103 (logicalCondition -> comparingValue .)
    PRINT           reduce using rule 103 (logicalCondition -> comparingValue .)
    ID              reduce using rule 103 (logicalCondition -> comparingValue .)
    INTEGER         reduce using rule 103 (logicalCondition -> comparingValue .)
    FLOAT           reduce using rule 103 (logicalCondition -> comparingValue .)
    $end            reduce using rule 103 (logicalCondition -> comparingValue .)
    RPAREN          reduce using rule 103 (logicalCondition -> comparingValue .)
    RCURLY          reduce using rule 103 (logicalCondition -> comparingValue .)
    CONTINUE        reduce using rule 103 (logicalCondition -> comparingValue .)
    SEMICOLON       reduce using rule 103 (logicalCondition -> comparingValue .)
    BREAK           reduce using rule 103 (logicalCondition -> comparingValue .)
    AND             shift and go to state 83
    OR              shift and go to state 84
    XOR             shift and go to state 85

    conditionOperator              shift and go to state 82

state 40

    (78) value -> INTEGER .

    CONCAT          reduce using rule 78 (value -> INTEGER .)
    IS_EQUAL        reduce using rule 78 (value -> INTEGER .)
    IDENTICAL       reduce using rule 78 (value -> INTEGER .)
    NOTEQUAL        reduce using rule 78 (value -> INTEGER .)
    LESSTHAN        reduce using rule 78 (value -> INTEGER .)
    GREATERTHAN     reduce using rule 78 (value -> INTEGER .)
    LESSEQUALTHAN   reduce using rule 78 (value -> INTEGER .)
    GREATEREQUALTHAN reduce using rule 78 (value -> INTEGER .)
    PLUS            reduce using rule 78 (value -> INTEGER .)
    MINUS           reduce using rule 78 (value -> INTEGER .)
    TIMES           reduce using rule 78 (value -> INTEGER .)
    DIVIDE          reduce using rule 78 (value -> INTEGER .)
    MOD             reduce using rule 78 (value -> INTEGER .)
    EXP             reduce using rule 78 (value -> INTEGER .)
    OPEN_TAG        reduce using rule 78 (value -> INTEGER .)
    CLOSE_TAG       reduce using rule 78 (value -> INTEGER .)
    STRING          reduce using rule 78 (value -> INTEGER .)
    LPAREN          reduce using rule 78 (value -> INTEGER .)
    IF              reduce using rule 78 (value -> INTEGER .)
    FOR             reduce using rule 78 (value -> INTEGER .)
    SWITCH          reduce using rule 78 (value -> INTEGER .)
    VAR             reduce using rule 78 (value -> INTEGER .)
    FUNCTION        reduce using rule 78 (value -> INTEGER .)
    FN              reduce using rule 78 (value -> INTEGER .)
    ECHO            reduce using rule 78 (value -> INTEGER .)
    PRINT           reduce using rule 78 (value -> INTEGER .)
    ID              reduce using rule 78 (value -> INTEGER .)
    INTEGER         reduce using rule 78 (value -> INTEGER .)
    FLOAT           reduce using rule 78 (value -> INTEGER .)
    $end            reduce using rule 78 (value -> INTEGER .)
    RPAREN          reduce using rule 78 (value -> INTEGER .)
    SEMICOLON       reduce using rule 78 (value -> INTEGER .)
    COMMA           reduce using rule 78 (value -> INTEGER .)
    RCURLY          reduce using rule 78 (value -> INTEGER .)
    CONTINUE        reduce using rule 78 (value -> INTEGER .)
    BREAK           reduce using rule 78 (value -> INTEGER .)
    AND             reduce using rule 78 (value -> INTEGER .)
    OR              reduce using rule 78 (value -> INTEGER .)
    XOR             reduce using rule 78 (value -> INTEGER .)
    RSQUARE         reduce using rule 78 (value -> INTEGER .)
    COLON           reduce using rule 78 (value -> INTEGER .)


state 41

    (79) value -> FLOAT .

    CONCAT          reduce using rule 79 (value -> FLOAT .)
    IS_EQUAL        reduce using rule 79 (value -> FLOAT .)
    IDENTICAL       reduce using rule 79 (value -> FLOAT .)
    NOTEQUAL        reduce using rule 79 (value -> FLOAT .)
    LESSTHAN        reduce using rule 79 (value -> FLOAT .)
    GREATERTHAN     reduce using rule 79 (value -> FLOAT .)
    LESSEQUALTHAN   reduce using rule 79 (value -> FLOAT .)
    GREATEREQUALTHAN reduce using rule 79 (value -> FLOAT .)
    PLUS            reduce using rule 79 (value -> FLOAT .)
    MINUS           reduce using rule 79 (value -> FLOAT .)
    TIMES           reduce using rule 79 (value -> FLOAT .)
    DIVIDE          reduce using rule 79 (value -> FLOAT .)
    MOD             reduce using rule 79 (value -> FLOAT .)
    EXP             reduce using rule 79 (value -> FLOAT .)
    OPEN_TAG        reduce using rule 79 (value -> FLOAT .)
    CLOSE_TAG       reduce using rule 79 (value -> FLOAT .)
    STRING          reduce using rule 79 (value -> FLOAT .)
    LPAREN          reduce using rule 79 (value -> FLOAT .)
    IF              reduce using rule 79 (value -> FLOAT .)
    FOR             reduce using rule 79 (value -> FLOAT .)
    SWITCH          reduce using rule 79 (value -> FLOAT .)
    VAR             reduce using rule 79 (value -> FLOAT .)
    FUNCTION        reduce using rule 79 (value -> FLOAT .)
    FN              reduce using rule 79 (value -> FLOAT .)
    ECHO            reduce using rule 79 (value -> FLOAT .)
    PRINT           reduce using rule 79 (value -> FLOAT .)
    ID              reduce using rule 79 (value -> FLOAT .)
    INTEGER         reduce using rule 79 (value -> FLOAT .)
    FLOAT           reduce using rule 79 (value -> FLOAT .)
    $end            reduce using rule 79 (value -> FLOAT .)
    RPAREN          reduce using rule 79 (value -> FLOAT .)
    SEMICOLON       reduce using rule 79 (value -> FLOAT .)
    COMMA           reduce using rule 79 (value -> FLOAT .)
    RCURLY          reduce using rule 79 (value -> FLOAT .)
    CONTINUE        reduce using rule 79 (value -> FLOAT .)
    BREAK           reduce using rule 79 (value -> FLOAT .)
    AND             reduce using rule 79 (value -> FLOAT .)
    OR              reduce using rule 79 (value -> FLOAT .)
    XOR             reduce using rule 79 (value -> FLOAT .)
    RSQUARE         reduce using rule 79 (value -> FLOAT .)
    COLON           reduce using rule 79 (value -> FLOAT .)


state 42

    (2) programa -> programa cuerpo .

    OPEN_TAG        reduce using rule 2 (programa -> programa cuerpo .)
    CLOSE_TAG       reduce using rule 2 (programa -> programa cuerpo .)
    STRING          reduce using rule 2 (programa -> programa cuerpo .)
    LPAREN          reduce using rule 2 (programa -> programa cuerpo .)
    IF              reduce using rule 2 (programa -> programa cuerpo .)
    FOR             reduce using rule 2 (programa -> programa cuerpo .)
    SWITCH          reduce using rule 2 (programa -> programa cuerpo .)
    VAR             reduce using rule 2 (programa -> programa cuerpo .)
    FUNCTION        reduce using rule 2 (programa -> programa cuerpo .)
    FN              reduce using rule 2 (programa -> programa cuerpo .)
    ECHO            reduce using rule 2 (programa -> programa cuerpo .)
    PRINT           reduce using rule 2 (programa -> programa cuerpo .)
    ID              reduce using rule 2 (programa -> programa cuerpo .)
    INTEGER         reduce using rule 2 (programa -> programa cuerpo .)
    FLOAT           reduce using rule 2 (programa -> programa cuerpo .)
    $end            reduce using rule 2 (programa -> programa cuerpo .)
    RCURLY          reduce using rule 2 (programa -> programa cuerpo .)
    BREAK           reduce using rule 2 (programa -> programa cuerpo .)


state 43

    (74) arithmeticExpression -> arithmeticExpression arithmeticOperator . arithmeticExpression
    (71) arithmeticExpression -> . value
    (72) arithmeticExpression -> . STRING
    (73) arithmeticExpression -> . LPAREN arithmeticExpression RPAREN
    (74) arithmeticExpression -> . arithmeticExpression arithmeticOperator arithmeticExpression
    (77) value -> . VAR
    (78) value -> . INTEGER
    (79) value -> . FLOAT
    (80) value -> . STRING
    (81) value -> . stringConcatenation
    (109) stringConcatenation -> . value CONCAT value
    (110) stringConcatenation -> . stringConcatenation CONCAT stringConcatenation

    STRING          shift and go to state 27
    LPAREN          shift and go to state 88
    VAR             shift and go to state 63
    INTEGER         shift and go to state 40
    FLOAT           shift and go to state 41

    arithmeticExpression           shift and go to state 86
    value                          shift and go to state 87
    stringConcatenation            shift and go to state 64

state 44

    (82) arithmeticOperator -> PLUS .

    STRING          reduce using rule 82 (arithmeticOperator -> PLUS .)
    LPAREN          reduce using rule 82 (arithmeticOperator -> PLUS .)
    VAR             reduce using rule 82 (arithmeticOperator -> PLUS .)
    INTEGER         reduce using rule 82 (arithmeticOperator -> PLUS .)
    FLOAT           reduce using rule 82 (arithmeticOperator -> PLUS .)


state 45

    (83) arithmeticOperator -> MINUS .

    STRING          reduce using rule 83 (arithmeticOperator -> MINUS .)
    LPAREN          reduce using rule 83 (arithmeticOperator -> MINUS .)
    VAR             reduce using rule 83 (arithmeticOperator -> MINUS .)
    INTEGER         reduce using rule 83 (arithmeticOperator -> MINUS .)
    FLOAT           reduce using rule 83 (arithmeticOperator -> MINUS .)


state 46

    (84) arithmeticOperator -> TIMES .

    STRING          reduce using rule 84 (arithmeticOperator -> TIMES .)
    LPAREN          reduce using rule 84 (arithmeticOperator -> TIMES .)
    VAR             reduce using rule 84 (arithmeticOperator -> TIMES .)
    INTEGER         reduce using rule 84 (arithmeticOperator -> TIMES .)
    FLOAT           reduce using rule 84 (arithmeticOperator -> TIMES .)


state 47

    (85) arithmeticOperator -> DIVIDE .

    STRING          reduce using rule 85 (arithmeticOperator -> DIVIDE .)
    LPAREN          reduce using rule 85 (arithmeticOperator -> DIVIDE .)
    VAR             reduce using rule 85 (arithmeticOperator -> DIVIDE .)
    INTEGER         reduce using rule 85 (arithmeticOperator -> DIVIDE .)
    FLOAT           reduce using rule 85 (arithmeticOperator -> DIVIDE .)


state 48

    (86) arithmeticOperator -> MOD .

    STRING          reduce using rule 86 (arithmeticOperator -> MOD .)
    LPAREN          reduce using rule 86 (arithmeticOperator -> MOD .)
    VAR             reduce using rule 86 (arithmeticOperator -> MOD .)
    INTEGER         reduce using rule 86 (arithmeticOperator -> MOD .)
    FLOAT           reduce using rule 86 (arithmeticOperator -> MOD .)


state 49

    (87) arithmeticOperator -> EXP .

    STRING          reduce using rule 87 (arithmeticOperator -> EXP .)
    LPAREN          reduce using rule 87 (arithmeticOperator -> EXP .)
    VAR             reduce using rule 87 (arithmeticOperator -> EXP .)
    INTEGER         reduce using rule 87 (arithmeticOperator -> EXP .)
    FLOAT           reduce using rule 87 (arithmeticOperator -> EXP .)


state 50

    (110) stringConcatenation -> stringConcatenation CONCAT . stringConcatenation
    (109) stringConcatenation -> . value CONCAT value
    (110) stringConcatenation -> . stringConcatenation CONCAT stringConcatenation
    (77) value -> . VAR
    (78) value -> . INTEGER
    (79) value -> . FLOAT
    (80) value -> . STRING
    (81) value -> . stringConcatenation

    VAR             shift and go to state 63
    INTEGER         shift and go to state 40
    FLOAT           shift and go to state 41
    STRING          shift and go to state 78

    stringConcatenation            shift and go to state 89
    value                          shift and go to state 90

state 51

    (109) stringConcatenation -> value CONCAT . value
    (77) value -> . VAR
    (78) value -> . INTEGER
    (79) value -> . FLOAT
    (80) value -> . STRING
    (81) value -> . stringConcatenation
    (109) stringConcatenation -> . value CONCAT value
    (110) stringConcatenation -> . stringConcatenation CONCAT stringConcatenation

    VAR             shift and go to state 63
    INTEGER         shift and go to state 40
    FLOAT           shift and go to state 41
    STRING          shift and go to state 78

    value                          shift and go to state 91
    stringConcatenation            shift and go to state 64

state 52

    (102) comparingValue -> value comparingSign . value
    (77) value -> . VAR
    (78) value -> . INTEGER
    (79) value -> . FLOAT
    (80) value -> . STRING
    (81) value -> . stringConcatenation
    (109) stringConcatenation -> . value CONCAT value
    (110) stringConcatenation -> . stringConcatenation CONCAT stringConcatenation

    VAR             shift and go to state 63
    INTEGER         shift and go to state 40
    FLOAT           shift and go to state 41
    STRING          shift and go to state 78

    value                          shift and go to state 92
    stringConcatenation            shift and go to state 64

state 53

    (95) comparingSign -> IS_EQUAL .

    VAR             reduce using rule 95 (comparingSign -> IS_EQUAL .)
    INTEGER         reduce using rule 95 (comparingSign -> IS_EQUAL .)
    FLOAT           reduce using rule 95 (comparingSign -> IS_EQUAL .)
    STRING          reduce using rule 95 (comparingSign -> IS_EQUAL .)


state 54

    (96) comparingSign -> IDENTICAL .

    VAR             reduce using rule 96 (comparingSign -> IDENTICAL .)
    INTEGER         reduce using rule 96 (comparingSign -> IDENTICAL .)
    FLOAT           reduce using rule 96 (comparingSign -> IDENTICAL .)
    STRING          reduce using rule 96 (comparingSign -> IDENTICAL .)


state 55

    (97) comparingSign -> NOTEQUAL .

    VAR             reduce using rule 97 (comparingSign -> NOTEQUAL .)
    INTEGER         reduce using rule 97 (comparingSign -> NOTEQUAL .)
    FLOAT           reduce using rule 97 (comparingSign -> NOTEQUAL .)
    STRING          reduce using rule 97 (comparingSign -> NOTEQUAL .)


state 56

    (98) comparingSign -> LESSTHAN .

    VAR             reduce using rule 98 (comparingSign -> LESSTHAN .)
    INTEGER         reduce using rule 98 (comparingSign -> LESSTHAN .)
    FLOAT           reduce using rule 98 (comparingSign -> LESSTHAN .)
    STRING          reduce using rule 98 (comparingSign -> LESSTHAN .)


state 57

    (99) comparingSign -> GREATERTHAN .

    VAR             reduce using rule 99 (comparingSign -> GREATERTHAN .)
    INTEGER         reduce using rule 99 (comparingSign -> GREATERTHAN .)
    FLOAT           reduce using rule 99 (comparingSign -> GREATERTHAN .)
    STRING          reduce using rule 99 (comparingSign -> GREATERTHAN .)


state 58

    (100) comparingSign -> LESSEQUALTHAN .

    VAR             reduce using rule 100 (comparingSign -> LESSEQUALTHAN .)
    INTEGER         reduce using rule 100 (comparingSign -> LESSEQUALTHAN .)
    FLOAT           reduce using rule 100 (comparingSign -> LESSEQUALTHAN .)
    STRING          reduce using rule 100 (comparingSign -> LESSEQUALTHAN .)


state 59

    (101) comparingSign -> GREATEREQUALTHAN .

    VAR             reduce using rule 101 (comparingSign -> GREATEREQUALTHAN .)
    INTEGER         reduce using rule 101 (comparingSign -> GREATEREQUALTHAN .)
    FLOAT           reduce using rule 101 (comparingSign -> GREATEREQUALTHAN .)
    STRING          reduce using rule 101 (comparingSign -> GREATEREQUALTHAN .)


state 60

    (73) arithmeticExpression -> LPAREN arithmeticExpression . RPAREN
    (74) arithmeticExpression -> arithmeticExpression . arithmeticOperator arithmeticExpression
    (82) arithmeticOperator -> . PLUS
    (83) arithmeticOperator -> . MINUS
    (84) arithmeticOperator -> . TIMES
    (85) arithmeticOperator -> . DIVIDE
    (86) arithmeticOperator -> . MOD
    (87) arithmeticOperator -> . EXP

    RPAREN          shift and go to state 93
    PLUS            shift and go to state 44
    MINUS           shift and go to state 45
    TIMES           shift and go to state 46
    DIVIDE          shift and go to state 47
    MOD             shift and go to state 48
    EXP             shift and go to state 49

    arithmeticOperator             shift and go to state 43

state 61

    (105) logicalCondition -> LPAREN logicalCondition . RPAREN

    RPAREN          shift and go to state 94


state 62

    (71) arithmeticExpression -> value .
    (102) comparingValue -> value . comparingSign value
    (109) stringConcatenation -> value . CONCAT value
    (95) comparingSign -> . IS_EQUAL
    (96) comparingSign -> . IDENTICAL
    (97) comparingSign -> . NOTEQUAL
    (98) comparingSign -> . LESSTHAN
    (99) comparingSign -> . GREATERTHAN
    (100) comparingSign -> . LESSEQUALTHAN
    (101) comparingSign -> . GREATEREQUALTHAN

    RPAREN          reduce using rule 71 (arithmeticExpression -> value .)
    PLUS            reduce using rule 71 (arithmeticExpression -> value .)
    MINUS           reduce using rule 71 (arithmeticExpression -> value .)
    TIMES           reduce using rule 71 (arithmeticExpression -> value .)
    DIVIDE          reduce using rule 71 (arithmeticExpression -> value .)
    MOD             reduce using rule 71 (arithmeticExpression -> value .)
    EXP             reduce using rule 71 (arithmeticExpression -> value .)
    CONCAT          shift and go to state 51
    IS_EQUAL        shift and go to state 53
    IDENTICAL       shift and go to state 54
    NOTEQUAL        shift and go to state 55
    LESSTHAN        shift and go to state 56
    GREATERTHAN     shift and go to state 57
    LESSEQUALTHAN   shift and go to state 58
    GREATEREQUALTHAN shift and go to state 59

    comparingSign                  shift and go to state 52

state 63

    (77) value -> VAR .

    CONCAT          reduce using rule 77 (value -> VAR .)
    IS_EQUAL        reduce using rule 77 (value -> VAR .)
    IDENTICAL       reduce using rule 77 (value -> VAR .)
    NOTEQUAL        reduce using rule 77 (value -> VAR .)
    LESSTHAN        reduce using rule 77 (value -> VAR .)
    GREATERTHAN     reduce using rule 77 (value -> VAR .)
    LESSEQUALTHAN   reduce using rule 77 (value -> VAR .)
    GREATEREQUALTHAN reduce using rule 77 (value -> VAR .)
    RPAREN          reduce using rule 77 (value -> VAR .)
    PLUS            reduce using rule 77 (value -> VAR .)
    MINUS           reduce using rule 77 (value -> VAR .)
    TIMES           reduce using rule 77 (value -> VAR .)
    DIVIDE          reduce using rule 77 (value -> VAR .)
    MOD             reduce using rule 77 (value -> VAR .)
    EXP             reduce using rule 77 (value -> VAR .)
    SEMICOLON       reduce using rule 77 (value -> VAR .)
    COMMA           reduce using rule 77 (value -> VAR .)
    OPEN_TAG        reduce using rule 77 (value -> VAR .)
    CLOSE_TAG       reduce using rule 77 (value -> VAR .)
    STRING          reduce using rule 77 (value -> VAR .)
    LPAREN          reduce using rule 77 (value -> VAR .)
    IF              reduce using rule 77 (value -> VAR .)
    FOR             reduce using rule 77 (value -> VAR .)
    SWITCH          reduce using rule 77 (value -> VAR .)
    VAR             reduce using rule 77 (value -> VAR .)
    FUNCTION        reduce using rule 77 (value -> VAR .)
    FN              reduce using rule 77 (value -> VAR .)
    ECHO            reduce using rule 77 (value -> VAR .)
    PRINT           reduce using rule 77 (value -> VAR .)
    ID              reduce using rule 77 (value -> VAR .)
    INTEGER         reduce using rule 77 (value -> VAR .)
    FLOAT           reduce using rule 77 (value -> VAR .)
    $end            reduce using rule 77 (value -> VAR .)
    RCURLY          reduce using rule 77 (value -> VAR .)
    CONTINUE        reduce using rule 77 (value -> VAR .)
    BREAK           reduce using rule 77 (value -> VAR .)
    AND             reduce using rule 77 (value -> VAR .)
    OR              reduce using rule 77 (value -> VAR .)
    XOR             reduce using rule 77 (value -> VAR .)
    RSQUARE         reduce using rule 77 (value -> VAR .)
    COLON           reduce using rule 77 (value -> VAR .)


state 64

    (81) value -> stringConcatenation .
    (110) stringConcatenation -> stringConcatenation . CONCAT stringConcatenation

  ! shift/reduce conflict for CONCAT resolved as shift
    IS_EQUAL        reduce using rule 81 (value -> stringConcatenation .)
    IDENTICAL       reduce using rule 81 (value -> stringConcatenation .)
    NOTEQUAL        reduce using rule 81 (value -> stringConcatenation .)
    LESSTHAN        reduce using rule 81 (value -> stringConcatenation .)
    GREATERTHAN     reduce using rule 81 (value -> stringConcatenation .)
    LESSEQUALTHAN   reduce using rule 81 (value -> stringConcatenation .)
    GREATEREQUALTHAN reduce using rule 81 (value -> stringConcatenation .)
    RPAREN          reduce using rule 81 (value -> stringConcatenation .)
    PLUS            reduce using rule 81 (value -> stringConcatenation .)
    MINUS           reduce using rule 81 (value -> stringConcatenation .)
    TIMES           reduce using rule 81 (value -> stringConcatenation .)
    DIVIDE          reduce using rule 81 (value -> stringConcatenation .)
    MOD             reduce using rule 81 (value -> stringConcatenation .)
    EXP             reduce using rule 81 (value -> stringConcatenation .)
    SEMICOLON       reduce using rule 81 (value -> stringConcatenation .)
    COMMA           reduce using rule 81 (value -> stringConcatenation .)
    OPEN_TAG        reduce using rule 81 (value -> stringConcatenation .)
    CLOSE_TAG       reduce using rule 81 (value -> stringConcatenation .)
    STRING          reduce using rule 81 (value -> stringConcatenation .)
    LPAREN          reduce using rule 81 (value -> stringConcatenation .)
    IF              reduce using rule 81 (value -> stringConcatenation .)
    FOR             reduce using rule 81 (value -> stringConcatenation .)
    SWITCH          reduce using rule 81 (value -> stringConcatenation .)
    VAR             reduce using rule 81 (value -> stringConcatenation .)
    FUNCTION        reduce using rule 81 (value -> stringConcatenation .)
    FN              reduce using rule 81 (value -> stringConcatenation .)
    ECHO            reduce using rule 81 (value -> stringConcatenation .)
    PRINT           reduce using rule 81 (value -> stringConcatenation .)
    ID              reduce using rule 81 (value -> stringConcatenation .)
    INTEGER         reduce using rule 81 (value -> stringConcatenation .)
    FLOAT           reduce using rule 81 (value -> stringConcatenation .)
    $end            reduce using rule 81 (value -> stringConcatenation .)
    RCURLY          reduce using rule 81 (value -> stringConcatenation .)
    CONTINUE        reduce using rule 81 (value -> stringConcatenation .)
    BREAK           reduce using rule 81 (value -> stringConcatenation .)
    AND             reduce using rule 81 (value -> stringConcatenation .)
    OR              reduce using rule 81 (value -> stringConcatenation .)
    XOR             reduce using rule 81 (value -> stringConcatenation .)
    RSQUARE         reduce using rule 81 (value -> stringConcatenation .)
    COLON           reduce using rule 81 (value -> stringConcatenation .)
    CONCAT          shift and go to state 50

  ! CONCAT          [ reduce using rule 81 (value -> stringConcatenation .) ]


state 65

    (31) if_elseStatement -> IF LPAREN . logicalCondition RPAREN LCURLY ifStatementBody RCURLY ELSE LCURLY ifStatementBody RCURLY
    (32) if_elseStatement -> IF LPAREN . logicalCondition RPAREN LCURLY ifStatementBody
    (103) logicalCondition -> . comparingValue
    (104) logicalCondition -> . comparingValue conditionOperator comparingValue
    (105) logicalCondition -> . LPAREN logicalCondition RPAREN
    (102) comparingValue -> . value comparingSign value
    (77) value -> . VAR
    (78) value -> . INTEGER
    (79) value -> . FLOAT
    (80) value -> . STRING
    (81) value -> . stringConcatenation
    (109) stringConcatenation -> . value CONCAT value
    (110) stringConcatenation -> . stringConcatenation CONCAT stringConcatenation

    LPAREN          shift and go to state 95
    VAR             shift and go to state 63
    INTEGER         shift and go to state 40
    FLOAT           shift and go to state 41
    STRING          shift and go to state 78

    logicalCondition               shift and go to state 96
    comparingValue                 shift and go to state 39
    value                          shift and go to state 97
    stringConcatenation            shift and go to state 64

state 66

    (36) forStatement -> FOR LPAREN . forStatementCondition RPAREN LCURLY forStatementBody RCURLY
    (37) forStatementCondition -> . SEMICOLON SEMICOLON
    (38) forStatementCondition -> . variableAsignation SEMICOLON SEMICOLON variableAsignation
    (39) forStatementCondition -> . variableAsignation SEMICOLON comparingValue SEMICOLON variableAsignation
    (89) variableAsignation -> . VAR EQUAL value
    (90) variableAsignation -> . VAR EQUAL arithmeticExpression
    (91) variableAsignation -> . VAR INCREMENT
    (92) variableAsignation -> . VAR DECREMENT
    (93) variableAsignation -> . VAR EQUAL stringConcatenation
    (94) variableAsignation -> . VAR EQUAL anonymousFunction

    SEMICOLON       shift and go to state 99
    VAR             shift and go to state 101

    forStatementCondition          shift and go to state 98
    variableAsignation             shift and go to state 100

state 67

    (26) switchStatement -> SWITCH LPAREN . value RPAREN LCURLY switchCases switchDefault RCURLY
    (77) value -> . VAR
    (78) value -> . INTEGER
    (79) value -> . FLOAT
    (80) value -> . STRING
    (81) value -> . stringConcatenation
    (109) stringConcatenation -> . value CONCAT value
    (110) stringConcatenation -> . stringConcatenation CONCAT stringConcatenation

    VAR             shift and go to state 63
    INTEGER         shift and go to state 40
    FLOAT           shift and go to state 41
    STRING          shift and go to state 78

    value                          shift and go to state 102
    stringConcatenation            shift and go to state 64

state 68

    (42) arrayAsignation -> VAR EQUAL . arrayDeclaration SEMICOLON
    (53) queueDeclaration -> VAR EQUAL . NEW QUEUE SEMICOLON
    (70) fgets -> VAR EQUAL . FGETS LPAREN STDIN RPAREN SEMICOLON
    (50) stackDeclaration -> VAR EQUAL . NEW STACK SEMICOLON
    (89) variableAsignation -> VAR EQUAL . value
    (90) variableAsignation -> VAR EQUAL . arithmeticExpression
    (93) variableAsignation -> VAR EQUAL . stringConcatenation
    (94) variableAsignation -> VAR EQUAL . anonymousFunction
    (43) arrayDeclaration -> . ARRAY arraysValues RPAREN
    (44) arrayDeclaration -> . LSQUARE arraysValues RSQUARE
    (45) arrayDeclaration -> . arrayValue
    (77) value -> . VAR
    (78) value -> . INTEGER
    (79) value -> . FLOAT
    (80) value -> . STRING
    (81) value -> . stringConcatenation
    (71) arithmeticExpression -> . value
    (72) arithmeticExpression -> . STRING
    (73) arithmeticExpression -> . LPAREN arithmeticExpression RPAREN
    (74) arithmeticExpression -> . arithmeticExpression arithmeticOperator arithmeticExpression
    (109) stringConcatenation -> . value CONCAT value
    (110) stringConcatenation -> . stringConcatenation CONCAT stringConcatenation
    (60) anonymousFunction -> . FUNCTION LPAREN RPAREN LCURLY cuerpo RCURLY
    (61) anonymousFunction -> . FUNCTION LPAREN arguments RPAREN LCURLY cuerpo RCURLY
    (48) arrayValue -> . ARRAY values RPAREN
    (49) arrayValue -> . LSQUARE values RSQUARE

    NEW             shift and go to state 104
    FGETS           shift and go to state 105
    ARRAY           shift and go to state 110
    LSQUARE         shift and go to state 111
    VAR             shift and go to state 63
    INTEGER         shift and go to state 40
    FLOAT           shift and go to state 41
    STRING          shift and go to state 113
    LPAREN          shift and go to state 88
    FUNCTION        shift and go to state 114

    arrayDeclaration               shift and go to state 103
    value                          shift and go to state 106
    arithmeticExpression           shift and go to state 107
    stringConcatenation            shift and go to state 108
    anonymousFunction              shift and go to state 109
    arrayValue                     shift and go to state 112

state 69

    (54) queueEnqueue -> VAR OBJOP . PUSH LPAREN value RPAREN SEMICOLON
    (55) queueDequeue -> VAR OBJOP . POP SEMICOLON
    (51) stackPush -> VAR OBJOP . PUSH LPAREN value RPAREN SEMICOLON
    (52) stackPop -> VAR OBJOP . POP SEMICOLON

    PUSH            shift and go to state 115
    POP             shift and go to state 116


state 70

    (91) variableAsignation -> VAR INCREMENT .

    SEMICOLON       reduce using rule 91 (variableAsignation -> VAR INCREMENT .)
    RPAREN          reduce using rule 91 (variableAsignation -> VAR INCREMENT .)


state 71

    (92) variableAsignation -> VAR DECREMENT .

    SEMICOLON       reduce using rule 92 (variableAsignation -> VAR DECREMENT .)
    RPAREN          reduce using rule 92 (variableAsignation -> VAR DECREMENT .)


state 72

    (56) defineFunction -> FUNCTION ID . LPAREN arguments RPAREN LCURLY programa RCURLY
    (57) defineFunction -> FUNCTION ID . LPAREN RPAREN LCURLY programa RCURLY

    LPAREN          shift and go to state 117


state 73

    (60) anonymousFunction -> FUNCTION LPAREN . RPAREN LCURLY cuerpo RCURLY
    (61) anonymousFunction -> FUNCTION LPAREN . arguments RPAREN LCURLY cuerpo RCURLY
    (58) arguments -> . VAR
    (59) arguments -> . VAR COMMA arguments

    RPAREN          shift and go to state 118
    VAR             shift and go to state 120

    arguments                      shift and go to state 119

state 74

    (75) callFunction -> ID LPAREN . RPAREN SEMICOLON
    (76) callFunction -> ID LPAREN . value RPAREN SEMICOLON
    (77) value -> . VAR
    (78) value -> . INTEGER
    (79) value -> . FLOAT
    (80) value -> . STRING
    (81) value -> . stringConcatenation
    (109) stringConcatenation -> . value CONCAT value
    (110) stringConcatenation -> . stringConcatenation CONCAT stringConcatenation

    RPAREN          shift and go to state 121
    VAR             shift and go to state 63
    INTEGER         shift and go to state 40
    FLOAT           shift and go to state 41
    STRING          shift and go to state 78

    value                          shift and go to state 122
    stringConcatenation            shift and go to state 64

state 75

    (62) arrowFunction -> FN LPAREN . VAR RPAREN FNARROW arrowBody SEMICOLON

    VAR             shift and go to state 123


state 76

    (65) echo -> ECHO values . SEMICOLON
    (69) values -> values . COMMA value

    SEMICOLON       shift and go to state 124
    COMMA           shift and go to state 125


state 77

    (68) values -> value .
    (109) stringConcatenation -> value . CONCAT value

    SEMICOLON       reduce using rule 68 (values -> value .)
    COMMA           reduce using rule 68 (values -> value .)
    RPAREN          reduce using rule 68 (values -> value .)
    RSQUARE         reduce using rule 68 (values -> value .)
    CONCAT          shift and go to state 51


state 78

    (80) value -> STRING .

    CONCAT          reduce using rule 80 (value -> STRING .)
    SEMICOLON       reduce using rule 80 (value -> STRING .)
    COMMA           reduce using rule 80 (value -> STRING .)
    OPEN_TAG        reduce using rule 80 (value -> STRING .)
    CLOSE_TAG       reduce using rule 80 (value -> STRING .)
    STRING          reduce using rule 80 (value -> STRING .)
    LPAREN          reduce using rule 80 (value -> STRING .)
    IF              reduce using rule 80 (value -> STRING .)
    FOR             reduce using rule 80 (value -> STRING .)
    SWITCH          reduce using rule 80 (value -> STRING .)
    VAR             reduce using rule 80 (value -> STRING .)
    FUNCTION        reduce using rule 80 (value -> STRING .)
    FN              reduce using rule 80 (value -> STRING .)
    ECHO            reduce using rule 80 (value -> STRING .)
    PRINT           reduce using rule 80 (value -> STRING .)
    ID              reduce using rule 80 (value -> STRING .)
    INTEGER         reduce using rule 80 (value -> STRING .)
    FLOAT           reduce using rule 80 (value -> STRING .)
    $end            reduce using rule 80 (value -> STRING .)
    IS_EQUAL        reduce using rule 80 (value -> STRING .)
    IDENTICAL       reduce using rule 80 (value -> STRING .)
    NOTEQUAL        reduce using rule 80 (value -> STRING .)
    LESSTHAN        reduce using rule 80 (value -> STRING .)
    GREATERTHAN     reduce using rule 80 (value -> STRING .)
    LESSEQUALTHAN   reduce using rule 80 (value -> STRING .)
    GREATEREQUALTHAN reduce using rule 80 (value -> STRING .)
    PLUS            reduce using rule 80 (value -> STRING .)
    MINUS           reduce using rule 80 (value -> STRING .)
    TIMES           reduce using rule 80 (value -> STRING .)
    DIVIDE          reduce using rule 80 (value -> STRING .)
    MOD             reduce using rule 80 (value -> STRING .)
    EXP             reduce using rule 80 (value -> STRING .)
    RPAREN          reduce using rule 80 (value -> STRING .)
    RCURLY          reduce using rule 80 (value -> STRING .)
    CONTINUE        reduce using rule 80 (value -> STRING .)
    BREAK           reduce using rule 80 (value -> STRING .)
    AND             reduce using rule 80 (value -> STRING .)
    OR              reduce using rule 80 (value -> STRING .)
    XOR             reduce using rule 80 (value -> STRING .)
    RSQUARE         reduce using rule 80 (value -> STRING .)
    COLON           reduce using rule 80 (value -> STRING .)


state 79

    (88) line -> variableAsignation SEMICOLON .

    OPEN_TAG        reduce using rule 88 (line -> variableAsignation SEMICOLON .)
    CLOSE_TAG       reduce using rule 88 (line -> variableAsignation SEMICOLON .)
    STRING          reduce using rule 88 (line -> variableAsignation SEMICOLON .)
    LPAREN          reduce using rule 88 (line -> variableAsignation SEMICOLON .)
    IF              reduce using rule 88 (line -> variableAsignation SEMICOLON .)
    FOR             reduce using rule 88 (line -> variableAsignation SEMICOLON .)
    SWITCH          reduce using rule 88 (line -> variableAsignation SEMICOLON .)
    VAR             reduce using rule 88 (line -> variableAsignation SEMICOLON .)
    FUNCTION        reduce using rule 88 (line -> variableAsignation SEMICOLON .)
    FN              reduce using rule 88 (line -> variableAsignation SEMICOLON .)
    ECHO            reduce using rule 88 (line -> variableAsignation SEMICOLON .)
    PRINT           reduce using rule 88 (line -> variableAsignation SEMICOLON .)
    ID              reduce using rule 88 (line -> variableAsignation SEMICOLON .)
    INTEGER         reduce using rule 88 (line -> variableAsignation SEMICOLON .)
    FLOAT           reduce using rule 88 (line -> variableAsignation SEMICOLON .)
    $end            reduce using rule 88 (line -> variableAsignation SEMICOLON .)
    RCURLY          reduce using rule 88 (line -> variableAsignation SEMICOLON .)
    CONTINUE        reduce using rule 88 (line -> variableAsignation SEMICOLON .)
    SEMICOLON       reduce using rule 88 (line -> variableAsignation SEMICOLON .)
    BREAK           reduce using rule 88 (line -> variableAsignation SEMICOLON .)


state 80

    (66) print -> PRINT LPAREN . values RPAREN SEMICOLON
    (68) values -> . value
    (69) values -> . values COMMA value
    (77) value -> . VAR
    (78) value -> . INTEGER
    (79) value -> . FLOAT
    (80) value -> . STRING
    (81) value -> . stringConcatenation
    (109) stringConcatenation -> . value CONCAT value
    (110) stringConcatenation -> . stringConcatenation CONCAT stringConcatenation

    VAR             shift and go to state 63
    INTEGER         shift and go to state 40
    FLOAT           shift and go to state 41
    STRING          shift and go to state 78

    values                         shift and go to state 126
    value                          shift and go to state 77
    stringConcatenation            shift and go to state 64

state 81

    (67) print -> PRINT value . SEMICOLON
    (109) stringConcatenation -> value . CONCAT value

    SEMICOLON       shift and go to state 127
    CONCAT          shift and go to state 51


state 82

    (104) logicalCondition -> comparingValue conditionOperator . comparingValue
    (102) comparingValue -> . value comparingSign value
    (77) value -> . VAR
    (78) value -> . INTEGER
    (79) value -> . FLOAT
    (80) value -> . STRING
    (81) value -> . stringConcatenation
    (109) stringConcatenation -> . value CONCAT value
    (110) stringConcatenation -> . stringConcatenation CONCAT stringConcatenation

    VAR             shift and go to state 63
    INTEGER         shift and go to state 40
    FLOAT           shift and go to state 41
    STRING          shift and go to state 78

    comparingValue                 shift and go to state 128
    value                          shift and go to state 97
    stringConcatenation            shift and go to state 64

state 83

    (106) conditionOperator -> AND .

    VAR             reduce using rule 106 (conditionOperator -> AND .)
    INTEGER         reduce using rule 106 (conditionOperator -> AND .)
    FLOAT           reduce using rule 106 (conditionOperator -> AND .)
    STRING          reduce using rule 106 (conditionOperator -> AND .)


state 84

    (107) conditionOperator -> OR .

    VAR             reduce using rule 107 (conditionOperator -> OR .)
    INTEGER         reduce using rule 107 (conditionOperator -> OR .)
    FLOAT           reduce using rule 107 (conditionOperator -> OR .)
    STRING          reduce using rule 107 (conditionOperator -> OR .)


state 85

    (108) conditionOperator -> XOR .

    VAR             reduce using rule 108 (conditionOperator -> XOR .)
    INTEGER         reduce using rule 108 (conditionOperator -> XOR .)
    FLOAT           reduce using rule 108 (conditionOperator -> XOR .)
    STRING          reduce using rule 108 (conditionOperator -> XOR .)


state 86

    (74) arithmeticExpression -> arithmeticExpression arithmeticOperator arithmeticExpression .
    (74) arithmeticExpression -> arithmeticExpression . arithmeticOperator arithmeticExpression
    (82) arithmeticOperator -> . PLUS
    (83) arithmeticOperator -> . MINUS
    (84) arithmeticOperator -> . TIMES
    (85) arithmeticOperator -> . DIVIDE
    (86) arithmeticOperator -> . MOD
    (87) arithmeticOperator -> . EXP

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for EXP resolved as shift
    OPEN_TAG        reduce using rule 74 (arithmeticExpression -> arithmeticExpression arithmeticOperator arithmeticExpression .)
    CLOSE_TAG       reduce using rule 74 (arithmeticExpression -> arithmeticExpression arithmeticOperator arithmeticExpression .)
    STRING          reduce using rule 74 (arithmeticExpression -> arithmeticExpression arithmeticOperator arithmeticExpression .)
    LPAREN          reduce using rule 74 (arithmeticExpression -> arithmeticExpression arithmeticOperator arithmeticExpression .)
    IF              reduce using rule 74 (arithmeticExpression -> arithmeticExpression arithmeticOperator arithmeticExpression .)
    FOR             reduce using rule 74 (arithmeticExpression -> arithmeticExpression arithmeticOperator arithmeticExpression .)
    SWITCH          reduce using rule 74 (arithmeticExpression -> arithmeticExpression arithmeticOperator arithmeticExpression .)
    VAR             reduce using rule 74 (arithmeticExpression -> arithmeticExpression arithmeticOperator arithmeticExpression .)
    FUNCTION        reduce using rule 74 (arithmeticExpression -> arithmeticExpression arithmeticOperator arithmeticExpression .)
    FN              reduce using rule 74 (arithmeticExpression -> arithmeticExpression arithmeticOperator arithmeticExpression .)
    ECHO            reduce using rule 74 (arithmeticExpression -> arithmeticExpression arithmeticOperator arithmeticExpression .)
    PRINT           reduce using rule 74 (arithmeticExpression -> arithmeticExpression arithmeticOperator arithmeticExpression .)
    ID              reduce using rule 74 (arithmeticExpression -> arithmeticExpression arithmeticOperator arithmeticExpression .)
    INTEGER         reduce using rule 74 (arithmeticExpression -> arithmeticExpression arithmeticOperator arithmeticExpression .)
    FLOAT           reduce using rule 74 (arithmeticExpression -> arithmeticExpression arithmeticOperator arithmeticExpression .)
    $end            reduce using rule 74 (arithmeticExpression -> arithmeticExpression arithmeticOperator arithmeticExpression .)
    RPAREN          reduce using rule 74 (arithmeticExpression -> arithmeticExpression arithmeticOperator arithmeticExpression .)
    SEMICOLON       reduce using rule 74 (arithmeticExpression -> arithmeticExpression arithmeticOperator arithmeticExpression .)
    RCURLY          reduce using rule 74 (arithmeticExpression -> arithmeticExpression arithmeticOperator arithmeticExpression .)
    CONTINUE        reduce using rule 74 (arithmeticExpression -> arithmeticExpression arithmeticOperator arithmeticExpression .)
    BREAK           reduce using rule 74 (arithmeticExpression -> arithmeticExpression arithmeticOperator arithmeticExpression .)
    PLUS            shift and go to state 44
    MINUS           shift and go to state 45
    TIMES           shift and go to state 46
    DIVIDE          shift and go to state 47
    MOD             shift and go to state 48
    EXP             shift and go to state 49

  ! PLUS            [ reduce using rule 74 (arithmeticExpression -> arithmeticExpression arithmeticOperator arithmeticExpression .) ]
  ! MINUS           [ reduce using rule 74 (arithmeticExpression -> arithmeticExpression arithmeticOperator arithmeticExpression .) ]
  ! TIMES           [ reduce using rule 74 (arithmeticExpression -> arithmeticExpression arithmeticOperator arithmeticExpression .) ]
  ! DIVIDE          [ reduce using rule 74 (arithmeticExpression -> arithmeticExpression arithmeticOperator arithmeticExpression .) ]
  ! MOD             [ reduce using rule 74 (arithmeticExpression -> arithmeticExpression arithmeticOperator arithmeticExpression .) ]
  ! EXP             [ reduce using rule 74 (arithmeticExpression -> arithmeticExpression arithmeticOperator arithmeticExpression .) ]

    arithmeticOperator             shift and go to state 43

state 87

    (71) arithmeticExpression -> value .
    (109) stringConcatenation -> value . CONCAT value

    PLUS            reduce using rule 71 (arithmeticExpression -> value .)
    MINUS           reduce using rule 71 (arithmeticExpression -> value .)
    TIMES           reduce using rule 71 (arithmeticExpression -> value .)
    DIVIDE          reduce using rule 71 (arithmeticExpression -> value .)
    MOD             reduce using rule 71 (arithmeticExpression -> value .)
    EXP             reduce using rule 71 (arithmeticExpression -> value .)
    OPEN_TAG        reduce using rule 71 (arithmeticExpression -> value .)
    CLOSE_TAG       reduce using rule 71 (arithmeticExpression -> value .)
    STRING          reduce using rule 71 (arithmeticExpression -> value .)
    LPAREN          reduce using rule 71 (arithmeticExpression -> value .)
    IF              reduce using rule 71 (arithmeticExpression -> value .)
    FOR             reduce using rule 71 (arithmeticExpression -> value .)
    SWITCH          reduce using rule 71 (arithmeticExpression -> value .)
    VAR             reduce using rule 71 (arithmeticExpression -> value .)
    FUNCTION        reduce using rule 71 (arithmeticExpression -> value .)
    FN              reduce using rule 71 (arithmeticExpression -> value .)
    ECHO            reduce using rule 71 (arithmeticExpression -> value .)
    PRINT           reduce using rule 71 (arithmeticExpression -> value .)
    ID              reduce using rule 71 (arithmeticExpression -> value .)
    INTEGER         reduce using rule 71 (arithmeticExpression -> value .)
    FLOAT           reduce using rule 71 (arithmeticExpression -> value .)
    $end            reduce using rule 71 (arithmeticExpression -> value .)
    RPAREN          reduce using rule 71 (arithmeticExpression -> value .)
    SEMICOLON       reduce using rule 71 (arithmeticExpression -> value .)
    RCURLY          reduce using rule 71 (arithmeticExpression -> value .)
    CONTINUE        reduce using rule 71 (arithmeticExpression -> value .)
    BREAK           reduce using rule 71 (arithmeticExpression -> value .)
    CONCAT          shift and go to state 51


state 88

    (73) arithmeticExpression -> LPAREN . arithmeticExpression RPAREN
    (71) arithmeticExpression -> . value
    (72) arithmeticExpression -> . STRING
    (73) arithmeticExpression -> . LPAREN arithmeticExpression RPAREN
    (74) arithmeticExpression -> . arithmeticExpression arithmeticOperator arithmeticExpression
    (77) value -> . VAR
    (78) value -> . INTEGER
    (79) value -> . FLOAT
    (80) value -> . STRING
    (81) value -> . stringConcatenation
    (109) stringConcatenation -> . value CONCAT value
    (110) stringConcatenation -> . stringConcatenation CONCAT stringConcatenation

    STRING          shift and go to state 27
    LPAREN          shift and go to state 88
    VAR             shift and go to state 63
    INTEGER         shift and go to state 40
    FLOAT           shift and go to state 41

    arithmeticExpression           shift and go to state 60
    value                          shift and go to state 87
    stringConcatenation            shift and go to state 64

state 89

    (110) stringConcatenation -> stringConcatenation CONCAT stringConcatenation .
    (110) stringConcatenation -> stringConcatenation . CONCAT stringConcatenation
    (81) value -> stringConcatenation .

  ! shift/reduce conflict for CONCAT resolved as shift
  ! shift/reduce conflict for CONCAT resolved as shift
    OPEN_TAG        reduce using rule 110 (stringConcatenation -> stringConcatenation CONCAT stringConcatenation .)
    CLOSE_TAG       reduce using rule 110 (stringConcatenation -> stringConcatenation CONCAT stringConcatenation .)
    STRING          reduce using rule 110 (stringConcatenation -> stringConcatenation CONCAT stringConcatenation .)
    LPAREN          reduce using rule 110 (stringConcatenation -> stringConcatenation CONCAT stringConcatenation .)
    IF              reduce using rule 110 (stringConcatenation -> stringConcatenation CONCAT stringConcatenation .)
    FOR             reduce using rule 110 (stringConcatenation -> stringConcatenation CONCAT stringConcatenation .)
    SWITCH          reduce using rule 110 (stringConcatenation -> stringConcatenation CONCAT stringConcatenation .)
    VAR             reduce using rule 110 (stringConcatenation -> stringConcatenation CONCAT stringConcatenation .)
    FUNCTION        reduce using rule 110 (stringConcatenation -> stringConcatenation CONCAT stringConcatenation .)
    FN              reduce using rule 110 (stringConcatenation -> stringConcatenation CONCAT stringConcatenation .)
    ECHO            reduce using rule 110 (stringConcatenation -> stringConcatenation CONCAT stringConcatenation .)
    PRINT           reduce using rule 110 (stringConcatenation -> stringConcatenation CONCAT stringConcatenation .)
    ID              reduce using rule 110 (stringConcatenation -> stringConcatenation CONCAT stringConcatenation .)
    INTEGER         reduce using rule 110 (stringConcatenation -> stringConcatenation CONCAT stringConcatenation .)
    FLOAT           reduce using rule 110 (stringConcatenation -> stringConcatenation CONCAT stringConcatenation .)
    $end            reduce using rule 110 (stringConcatenation -> stringConcatenation CONCAT stringConcatenation .)
    IS_EQUAL        reduce using rule 110 (stringConcatenation -> stringConcatenation CONCAT stringConcatenation .)
    IDENTICAL       reduce using rule 110 (stringConcatenation -> stringConcatenation CONCAT stringConcatenation .)
    NOTEQUAL        reduce using rule 110 (stringConcatenation -> stringConcatenation CONCAT stringConcatenation .)
    LESSTHAN        reduce using rule 110 (stringConcatenation -> stringConcatenation CONCAT stringConcatenation .)
    GREATERTHAN     reduce using rule 110 (stringConcatenation -> stringConcatenation CONCAT stringConcatenation .)
    LESSEQUALTHAN   reduce using rule 110 (stringConcatenation -> stringConcatenation CONCAT stringConcatenation .)
    GREATEREQUALTHAN reduce using rule 110 (stringConcatenation -> stringConcatenation CONCAT stringConcatenation .)
    PLUS            reduce using rule 110 (stringConcatenation -> stringConcatenation CONCAT stringConcatenation .)
    MINUS           reduce using rule 110 (stringConcatenation -> stringConcatenation CONCAT stringConcatenation .)
    TIMES           reduce using rule 110 (stringConcatenation -> stringConcatenation CONCAT stringConcatenation .)
    DIVIDE          reduce using rule 110 (stringConcatenation -> stringConcatenation CONCAT stringConcatenation .)
    MOD             reduce using rule 110 (stringConcatenation -> stringConcatenation CONCAT stringConcatenation .)
    EXP             reduce using rule 110 (stringConcatenation -> stringConcatenation CONCAT stringConcatenation .)
    RPAREN          reduce using rule 110 (stringConcatenation -> stringConcatenation CONCAT stringConcatenation .)
    SEMICOLON       reduce using rule 110 (stringConcatenation -> stringConcatenation CONCAT stringConcatenation .)
    COMMA           reduce using rule 110 (stringConcatenation -> stringConcatenation CONCAT stringConcatenation .)
    RCURLY          reduce using rule 110 (stringConcatenation -> stringConcatenation CONCAT stringConcatenation .)
    CONTINUE        reduce using rule 110 (stringConcatenation -> stringConcatenation CONCAT stringConcatenation .)
    BREAK           reduce using rule 110 (stringConcatenation -> stringConcatenation CONCAT stringConcatenation .)
    AND             reduce using rule 110 (stringConcatenation -> stringConcatenation CONCAT stringConcatenation .)
    OR              reduce using rule 110 (stringConcatenation -> stringConcatenation CONCAT stringConcatenation .)
    XOR             reduce using rule 110 (stringConcatenation -> stringConcatenation CONCAT stringConcatenation .)
    RSQUARE         reduce using rule 110 (stringConcatenation -> stringConcatenation CONCAT stringConcatenation .)
    COLON           reduce using rule 110 (stringConcatenation -> stringConcatenation CONCAT stringConcatenation .)
    CONCAT          shift and go to state 50

  ! CONCAT          [ reduce using rule 110 (stringConcatenation -> stringConcatenation CONCAT stringConcatenation .) ]
  ! CONCAT          [ reduce using rule 81 (value -> stringConcatenation .) ]


state 90

    (109) stringConcatenation -> value . CONCAT value

    CONCAT          shift and go to state 51


state 91

    (109) stringConcatenation -> value CONCAT value .
    (109) stringConcatenation -> value . CONCAT value

  ! shift/reduce conflict for CONCAT resolved as shift
    OPEN_TAG        reduce using rule 109 (stringConcatenation -> value CONCAT value .)
    CLOSE_TAG       reduce using rule 109 (stringConcatenation -> value CONCAT value .)
    STRING          reduce using rule 109 (stringConcatenation -> value CONCAT value .)
    LPAREN          reduce using rule 109 (stringConcatenation -> value CONCAT value .)
    IF              reduce using rule 109 (stringConcatenation -> value CONCAT value .)
    FOR             reduce using rule 109 (stringConcatenation -> value CONCAT value .)
    SWITCH          reduce using rule 109 (stringConcatenation -> value CONCAT value .)
    VAR             reduce using rule 109 (stringConcatenation -> value CONCAT value .)
    FUNCTION        reduce using rule 109 (stringConcatenation -> value CONCAT value .)
    FN              reduce using rule 109 (stringConcatenation -> value CONCAT value .)
    ECHO            reduce using rule 109 (stringConcatenation -> value CONCAT value .)
    PRINT           reduce using rule 109 (stringConcatenation -> value CONCAT value .)
    ID              reduce using rule 109 (stringConcatenation -> value CONCAT value .)
    INTEGER         reduce using rule 109 (stringConcatenation -> value CONCAT value .)
    FLOAT           reduce using rule 109 (stringConcatenation -> value CONCAT value .)
    $end            reduce using rule 109 (stringConcatenation -> value CONCAT value .)
    IS_EQUAL        reduce using rule 109 (stringConcatenation -> value CONCAT value .)
    IDENTICAL       reduce using rule 109 (stringConcatenation -> value CONCAT value .)
    NOTEQUAL        reduce using rule 109 (stringConcatenation -> value CONCAT value .)
    LESSTHAN        reduce using rule 109 (stringConcatenation -> value CONCAT value .)
    GREATERTHAN     reduce using rule 109 (stringConcatenation -> value CONCAT value .)
    LESSEQUALTHAN   reduce using rule 109 (stringConcatenation -> value CONCAT value .)
    GREATEREQUALTHAN reduce using rule 109 (stringConcatenation -> value CONCAT value .)
    PLUS            reduce using rule 109 (stringConcatenation -> value CONCAT value .)
    MINUS           reduce using rule 109 (stringConcatenation -> value CONCAT value .)
    TIMES           reduce using rule 109 (stringConcatenation -> value CONCAT value .)
    DIVIDE          reduce using rule 109 (stringConcatenation -> value CONCAT value .)
    MOD             reduce using rule 109 (stringConcatenation -> value CONCAT value .)
    EXP             reduce using rule 109 (stringConcatenation -> value CONCAT value .)
    RPAREN          reduce using rule 109 (stringConcatenation -> value CONCAT value .)
    SEMICOLON       reduce using rule 109 (stringConcatenation -> value CONCAT value .)
    COMMA           reduce using rule 109 (stringConcatenation -> value CONCAT value .)
    RCURLY          reduce using rule 109 (stringConcatenation -> value CONCAT value .)
    CONTINUE        reduce using rule 109 (stringConcatenation -> value CONCAT value .)
    BREAK           reduce using rule 109 (stringConcatenation -> value CONCAT value .)
    AND             reduce using rule 109 (stringConcatenation -> value CONCAT value .)
    OR              reduce using rule 109 (stringConcatenation -> value CONCAT value .)
    XOR             reduce using rule 109 (stringConcatenation -> value CONCAT value .)
    RSQUARE         reduce using rule 109 (stringConcatenation -> value CONCAT value .)
    COLON           reduce using rule 109 (stringConcatenation -> value CONCAT value .)
    CONCAT          shift and go to state 51

  ! CONCAT          [ reduce using rule 109 (stringConcatenation -> value CONCAT value .) ]


state 92

    (102) comparingValue -> value comparingSign value .
    (109) stringConcatenation -> value . CONCAT value

    AND             reduce using rule 102 (comparingValue -> value comparingSign value .)
    OR              reduce using rule 102 (comparingValue -> value comparingSign value .)
    XOR             reduce using rule 102 (comparingValue -> value comparingSign value .)
    OPEN_TAG        reduce using rule 102 (comparingValue -> value comparingSign value .)
    CLOSE_TAG       reduce using rule 102 (comparingValue -> value comparingSign value .)
    STRING          reduce using rule 102 (comparingValue -> value comparingSign value .)
    LPAREN          reduce using rule 102 (comparingValue -> value comparingSign value .)
    IF              reduce using rule 102 (comparingValue -> value comparingSign value .)
    FOR             reduce using rule 102 (comparingValue -> value comparingSign value .)
    SWITCH          reduce using rule 102 (comparingValue -> value comparingSign value .)
    VAR             reduce using rule 102 (comparingValue -> value comparingSign value .)
    FUNCTION        reduce using rule 102 (comparingValue -> value comparingSign value .)
    FN              reduce using rule 102 (comparingValue -> value comparingSign value .)
    ECHO            reduce using rule 102 (comparingValue -> value comparingSign value .)
    PRINT           reduce using rule 102 (comparingValue -> value comparingSign value .)
    ID              reduce using rule 102 (comparingValue -> value comparingSign value .)
    INTEGER         reduce using rule 102 (comparingValue -> value comparingSign value .)
    FLOAT           reduce using rule 102 (comparingValue -> value comparingSign value .)
    $end            reduce using rule 102 (comparingValue -> value comparingSign value .)
    RPAREN          reduce using rule 102 (comparingValue -> value comparingSign value .)
    RCURLY          reduce using rule 102 (comparingValue -> value comparingSign value .)
    CONTINUE        reduce using rule 102 (comparingValue -> value comparingSign value .)
    SEMICOLON       reduce using rule 102 (comparingValue -> value comparingSign value .)
    BREAK           reduce using rule 102 (comparingValue -> value comparingSign value .)
    CONCAT          shift and go to state 51


state 93

    (73) arithmeticExpression -> LPAREN arithmeticExpression RPAREN .

    PLUS            reduce using rule 73 (arithmeticExpression -> LPAREN arithmeticExpression RPAREN .)
    MINUS           reduce using rule 73 (arithmeticExpression -> LPAREN arithmeticExpression RPAREN .)
    TIMES           reduce using rule 73 (arithmeticExpression -> LPAREN arithmeticExpression RPAREN .)
    DIVIDE          reduce using rule 73 (arithmeticExpression -> LPAREN arithmeticExpression RPAREN .)
    MOD             reduce using rule 73 (arithmeticExpression -> LPAREN arithmeticExpression RPAREN .)
    EXP             reduce using rule 73 (arithmeticExpression -> LPAREN arithmeticExpression RPAREN .)
    OPEN_TAG        reduce using rule 73 (arithmeticExpression -> LPAREN arithmeticExpression RPAREN .)
    CLOSE_TAG       reduce using rule 73 (arithmeticExpression -> LPAREN arithmeticExpression RPAREN .)
    STRING          reduce using rule 73 (arithmeticExpression -> LPAREN arithmeticExpression RPAREN .)
    LPAREN          reduce using rule 73 (arithmeticExpression -> LPAREN arithmeticExpression RPAREN .)
    IF              reduce using rule 73 (arithmeticExpression -> LPAREN arithmeticExpression RPAREN .)
    FOR             reduce using rule 73 (arithmeticExpression -> LPAREN arithmeticExpression RPAREN .)
    SWITCH          reduce using rule 73 (arithmeticExpression -> LPAREN arithmeticExpression RPAREN .)
    VAR             reduce using rule 73 (arithmeticExpression -> LPAREN arithmeticExpression RPAREN .)
    FUNCTION        reduce using rule 73 (arithmeticExpression -> LPAREN arithmeticExpression RPAREN .)
    FN              reduce using rule 73 (arithmeticExpression -> LPAREN arithmeticExpression RPAREN .)
    ECHO            reduce using rule 73 (arithmeticExpression -> LPAREN arithmeticExpression RPAREN .)
    PRINT           reduce using rule 73 (arithmeticExpression -> LPAREN arithmeticExpression RPAREN .)
    ID              reduce using rule 73 (arithmeticExpression -> LPAREN arithmeticExpression RPAREN .)
    INTEGER         reduce using rule 73 (arithmeticExpression -> LPAREN arithmeticExpression RPAREN .)
    FLOAT           reduce using rule 73 (arithmeticExpression -> LPAREN arithmeticExpression RPAREN .)
    $end            reduce using rule 73 (arithmeticExpression -> LPAREN arithmeticExpression RPAREN .)
    RPAREN          reduce using rule 73 (arithmeticExpression -> LPAREN arithmeticExpression RPAREN .)
    SEMICOLON       reduce using rule 73 (arithmeticExpression -> LPAREN arithmeticExpression RPAREN .)
    RCURLY          reduce using rule 73 (arithmeticExpression -> LPAREN arithmeticExpression RPAREN .)
    CONTINUE        reduce using rule 73 (arithmeticExpression -> LPAREN arithmeticExpression RPAREN .)
    BREAK           reduce using rule 73 (arithmeticExpression -> LPAREN arithmeticExpression RPAREN .)


state 94

    (105) logicalCondition -> LPAREN logicalCondition RPAREN .

    OPEN_TAG        reduce using rule 105 (logicalCondition -> LPAREN logicalCondition RPAREN .)
    CLOSE_TAG       reduce using rule 105 (logicalCondition -> LPAREN logicalCondition RPAREN .)
    STRING          reduce using rule 105 (logicalCondition -> LPAREN logicalCondition RPAREN .)
    LPAREN          reduce using rule 105 (logicalCondition -> LPAREN logicalCondition RPAREN .)
    IF              reduce using rule 105 (logicalCondition -> LPAREN logicalCondition RPAREN .)
    FOR             reduce using rule 105 (logicalCondition -> LPAREN logicalCondition RPAREN .)
    SWITCH          reduce using rule 105 (logicalCondition -> LPAREN logicalCondition RPAREN .)
    VAR             reduce using rule 105 (logicalCondition -> LPAREN logicalCondition RPAREN .)
    FUNCTION        reduce using rule 105 (logicalCondition -> LPAREN logicalCondition RPAREN .)
    FN              reduce using rule 105 (logicalCondition -> LPAREN logicalCondition RPAREN .)
    ECHO            reduce using rule 105 (logicalCondition -> LPAREN logicalCondition RPAREN .)
    PRINT           reduce using rule 105 (logicalCondition -> LPAREN logicalCondition RPAREN .)
    ID              reduce using rule 105 (logicalCondition -> LPAREN logicalCondition RPAREN .)
    INTEGER         reduce using rule 105 (logicalCondition -> LPAREN logicalCondition RPAREN .)
    FLOAT           reduce using rule 105 (logicalCondition -> LPAREN logicalCondition RPAREN .)
    $end            reduce using rule 105 (logicalCondition -> LPAREN logicalCondition RPAREN .)
    RPAREN          reduce using rule 105 (logicalCondition -> LPAREN logicalCondition RPAREN .)
    RCURLY          reduce using rule 105 (logicalCondition -> LPAREN logicalCondition RPAREN .)
    CONTINUE        reduce using rule 105 (logicalCondition -> LPAREN logicalCondition RPAREN .)
    SEMICOLON       reduce using rule 105 (logicalCondition -> LPAREN logicalCondition RPAREN .)
    BREAK           reduce using rule 105 (logicalCondition -> LPAREN logicalCondition RPAREN .)


state 95

    (105) logicalCondition -> LPAREN . logicalCondition RPAREN
    (103) logicalCondition -> . comparingValue
    (104) logicalCondition -> . comparingValue conditionOperator comparingValue
    (105) logicalCondition -> . LPAREN logicalCondition RPAREN
    (102) comparingValue -> . value comparingSign value
    (77) value -> . VAR
    (78) value -> . INTEGER
    (79) value -> . FLOAT
    (80) value -> . STRING
    (81) value -> . stringConcatenation
    (109) stringConcatenation -> . value CONCAT value
    (110) stringConcatenation -> . stringConcatenation CONCAT stringConcatenation

    LPAREN          shift and go to state 95
    VAR             shift and go to state 63
    INTEGER         shift and go to state 40
    FLOAT           shift and go to state 41
    STRING          shift and go to state 78

    logicalCondition               shift and go to state 61
    comparingValue                 shift and go to state 39
    value                          shift and go to state 97
    stringConcatenation            shift and go to state 64

state 96

    (31) if_elseStatement -> IF LPAREN logicalCondition . RPAREN LCURLY ifStatementBody RCURLY ELSE LCURLY ifStatementBody RCURLY
    (32) if_elseStatement -> IF LPAREN logicalCondition . RPAREN LCURLY ifStatementBody

    RPAREN          shift and go to state 129


state 97

    (102) comparingValue -> value . comparingSign value
    (109) stringConcatenation -> value . CONCAT value
    (95) comparingSign -> . IS_EQUAL
    (96) comparingSign -> . IDENTICAL
    (97) comparingSign -> . NOTEQUAL
    (98) comparingSign -> . LESSTHAN
    (99) comparingSign -> . GREATERTHAN
    (100) comparingSign -> . LESSEQUALTHAN
    (101) comparingSign -> . GREATEREQUALTHAN

    CONCAT          shift and go to state 51
    IS_EQUAL        shift and go to state 53
    IDENTICAL       shift and go to state 54
    NOTEQUAL        shift and go to state 55
    LESSTHAN        shift and go to state 56
    GREATERTHAN     shift and go to state 57
    LESSEQUALTHAN   shift and go to state 58
    GREATEREQUALTHAN shift and go to state 59

    comparingSign                  shift and go to state 52

state 98

    (36) forStatement -> FOR LPAREN forStatementCondition . RPAREN LCURLY forStatementBody RCURLY

    RPAREN          shift and go to state 130


state 99

    (37) forStatementCondition -> SEMICOLON . SEMICOLON

    SEMICOLON       shift and go to state 131


state 100

    (38) forStatementCondition -> variableAsignation . SEMICOLON SEMICOLON variableAsignation
    (39) forStatementCondition -> variableAsignation . SEMICOLON comparingValue SEMICOLON variableAsignation

    SEMICOLON       shift and go to state 132


state 101

    (89) variableAsignation -> VAR . EQUAL value
    (90) variableAsignation -> VAR . EQUAL arithmeticExpression
    (91) variableAsignation -> VAR . INCREMENT
    (92) variableAsignation -> VAR . DECREMENT
    (93) variableAsignation -> VAR . EQUAL stringConcatenation
    (94) variableAsignation -> VAR . EQUAL anonymousFunction

    EQUAL           shift and go to state 133
    INCREMENT       shift and go to state 70
    DECREMENT       shift and go to state 71


state 102

    (26) switchStatement -> SWITCH LPAREN value . RPAREN LCURLY switchCases switchDefault RCURLY
    (109) stringConcatenation -> value . CONCAT value

    RPAREN          shift and go to state 134
    CONCAT          shift and go to state 51


state 103

    (42) arrayAsignation -> VAR EQUAL arrayDeclaration . SEMICOLON

    SEMICOLON       shift and go to state 135


state 104

    (53) queueDeclaration -> VAR EQUAL NEW . QUEUE SEMICOLON
    (50) stackDeclaration -> VAR EQUAL NEW . STACK SEMICOLON

    QUEUE           shift and go to state 136
    STACK           shift and go to state 137


state 105

    (70) fgets -> VAR EQUAL FGETS . LPAREN STDIN RPAREN SEMICOLON

    LPAREN          shift and go to state 138


state 106

    (89) variableAsignation -> VAR EQUAL value .
    (71) arithmeticExpression -> value .
    (109) stringConcatenation -> value . CONCAT value

  ! reduce/reduce conflict for SEMICOLON resolved using rule 71 (arithmeticExpression -> value .)
  ! reduce/reduce conflict for RPAREN resolved using rule 71 (arithmeticExpression -> value .)
    PLUS            reduce using rule 71 (arithmeticExpression -> value .)
    MINUS           reduce using rule 71 (arithmeticExpression -> value .)
    TIMES           reduce using rule 71 (arithmeticExpression -> value .)
    DIVIDE          reduce using rule 71 (arithmeticExpression -> value .)
    MOD             reduce using rule 71 (arithmeticExpression -> value .)
    EXP             reduce using rule 71 (arithmeticExpression -> value .)
    SEMICOLON       reduce using rule 71 (arithmeticExpression -> value .)
    RPAREN          reduce using rule 71 (arithmeticExpression -> value .)
    CONCAT          shift and go to state 51

  ! SEMICOLON       [ reduce using rule 89 (variableAsignation -> VAR EQUAL value .) ]
  ! RPAREN          [ reduce using rule 89 (variableAsignation -> VAR EQUAL value .) ]


state 107

    (90) variableAsignation -> VAR EQUAL arithmeticExpression .
    (74) arithmeticExpression -> arithmeticExpression . arithmeticOperator arithmeticExpression
    (82) arithmeticOperator -> . PLUS
    (83) arithmeticOperator -> . MINUS
    (84) arithmeticOperator -> . TIMES
    (85) arithmeticOperator -> . DIVIDE
    (86) arithmeticOperator -> . MOD
    (87) arithmeticOperator -> . EXP

    SEMICOLON       reduce using rule 90 (variableAsignation -> VAR EQUAL arithmeticExpression .)
    RPAREN          reduce using rule 90 (variableAsignation -> VAR EQUAL arithmeticExpression .)
    PLUS            shift and go to state 44
    MINUS           shift and go to state 45
    TIMES           shift and go to state 46
    DIVIDE          shift and go to state 47
    MOD             shift and go to state 48
    EXP             shift and go to state 49

    arithmeticOperator             shift and go to state 43

state 108

    (93) variableAsignation -> VAR EQUAL stringConcatenation .
    (81) value -> stringConcatenation .
    (110) stringConcatenation -> stringConcatenation . CONCAT stringConcatenation

  ! reduce/reduce conflict for SEMICOLON resolved using rule 81 (value -> stringConcatenation .)
  ! reduce/reduce conflict for RPAREN resolved using rule 81 (value -> stringConcatenation .)
  ! shift/reduce conflict for CONCAT resolved as shift
    SEMICOLON       reduce using rule 81 (value -> stringConcatenation .)
    PLUS            reduce using rule 81 (value -> stringConcatenation .)
    MINUS           reduce using rule 81 (value -> stringConcatenation .)
    TIMES           reduce using rule 81 (value -> stringConcatenation .)
    DIVIDE          reduce using rule 81 (value -> stringConcatenation .)
    MOD             reduce using rule 81 (value -> stringConcatenation .)
    EXP             reduce using rule 81 (value -> stringConcatenation .)
    RPAREN          reduce using rule 81 (value -> stringConcatenation .)
    CONCAT          shift and go to state 50

  ! SEMICOLON       [ reduce using rule 93 (variableAsignation -> VAR EQUAL stringConcatenation .) ]
  ! RPAREN          [ reduce using rule 93 (variableAsignation -> VAR EQUAL stringConcatenation .) ]
  ! CONCAT          [ reduce using rule 81 (value -> stringConcatenation .) ]


state 109

    (94) variableAsignation -> VAR EQUAL anonymousFunction .

    SEMICOLON       reduce using rule 94 (variableAsignation -> VAR EQUAL anonymousFunction .)
    RPAREN          reduce using rule 94 (variableAsignation -> VAR EQUAL anonymousFunction .)


state 110

    (43) arrayDeclaration -> ARRAY . arraysValues RPAREN
    (48) arrayValue -> ARRAY . values RPAREN
    (46) arraysValues -> . arrayValue
    (47) arraysValues -> . arraysValues COMMA arrayValue
    (68) values -> . value
    (69) values -> . values COMMA value
    (48) arrayValue -> . ARRAY values RPAREN
    (49) arrayValue -> . LSQUARE values RSQUARE
    (77) value -> . VAR
    (78) value -> . INTEGER
    (79) value -> . FLOAT
    (80) value -> . STRING
    (81) value -> . stringConcatenation
    (109) stringConcatenation -> . value CONCAT value
    (110) stringConcatenation -> . stringConcatenation CONCAT stringConcatenation

    ARRAY           shift and go to state 139
    LSQUARE         shift and go to state 143
    VAR             shift and go to state 63
    INTEGER         shift and go to state 40
    FLOAT           shift and go to state 41
    STRING          shift and go to state 78

    arraysValues                   shift and go to state 140
    values                         shift and go to state 141
    arrayValue                     shift and go to state 142
    value                          shift and go to state 77
    stringConcatenation            shift and go to state 64

state 111

    (44) arrayDeclaration -> LSQUARE . arraysValues RSQUARE
    (49) arrayValue -> LSQUARE . values RSQUARE
    (46) arraysValues -> . arrayValue
    (47) arraysValues -> . arraysValues COMMA arrayValue
    (68) values -> . value
    (69) values -> . values COMMA value
    (48) arrayValue -> . ARRAY values RPAREN
    (49) arrayValue -> . LSQUARE values RSQUARE
    (77) value -> . VAR
    (78) value -> . INTEGER
    (79) value -> . FLOAT
    (80) value -> . STRING
    (81) value -> . stringConcatenation
    (109) stringConcatenation -> . value CONCAT value
    (110) stringConcatenation -> . stringConcatenation CONCAT stringConcatenation

    ARRAY           shift and go to state 139
    LSQUARE         shift and go to state 143
    VAR             shift and go to state 63
    INTEGER         shift and go to state 40
    FLOAT           shift and go to state 41
    STRING          shift and go to state 78

    arraysValues                   shift and go to state 144
    values                         shift and go to state 145
    arrayValue                     shift and go to state 142
    value                          shift and go to state 77
    stringConcatenation            shift and go to state 64

state 112

    (45) arrayDeclaration -> arrayValue .

    SEMICOLON       reduce using rule 45 (arrayDeclaration -> arrayValue .)


state 113

    (80) value -> STRING .
    (72) arithmeticExpression -> STRING .

  ! reduce/reduce conflict for PLUS resolved using rule 72 (arithmeticExpression -> STRING .)
  ! reduce/reduce conflict for MINUS resolved using rule 72 (arithmeticExpression -> STRING .)
  ! reduce/reduce conflict for TIMES resolved using rule 72 (arithmeticExpression -> STRING .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 72 (arithmeticExpression -> STRING .)
  ! reduce/reduce conflict for MOD resolved using rule 72 (arithmeticExpression -> STRING .)
  ! reduce/reduce conflict for EXP resolved using rule 72 (arithmeticExpression -> STRING .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 72 (arithmeticExpression -> STRING .)
  ! reduce/reduce conflict for RPAREN resolved using rule 72 (arithmeticExpression -> STRING .)
    CONCAT          reduce using rule 80 (value -> STRING .)
    PLUS            reduce using rule 72 (arithmeticExpression -> STRING .)
    MINUS           reduce using rule 72 (arithmeticExpression -> STRING .)
    TIMES           reduce using rule 72 (arithmeticExpression -> STRING .)
    DIVIDE          reduce using rule 72 (arithmeticExpression -> STRING .)
    MOD             reduce using rule 72 (arithmeticExpression -> STRING .)
    EXP             reduce using rule 72 (arithmeticExpression -> STRING .)
    SEMICOLON       reduce using rule 72 (arithmeticExpression -> STRING .)
    RPAREN          reduce using rule 72 (arithmeticExpression -> STRING .)

  ! SEMICOLON       [ reduce using rule 80 (value -> STRING .) ]
  ! PLUS            [ reduce using rule 80 (value -> STRING .) ]
  ! MINUS           [ reduce using rule 80 (value -> STRING .) ]
  ! TIMES           [ reduce using rule 80 (value -> STRING .) ]
  ! DIVIDE          [ reduce using rule 80 (value -> STRING .) ]
  ! MOD             [ reduce using rule 80 (value -> STRING .) ]
  ! EXP             [ reduce using rule 80 (value -> STRING .) ]
  ! RPAREN          [ reduce using rule 80 (value -> STRING .) ]


state 114

    (60) anonymousFunction -> FUNCTION . LPAREN RPAREN LCURLY cuerpo RCURLY
    (61) anonymousFunction -> FUNCTION . LPAREN arguments RPAREN LCURLY cuerpo RCURLY

    LPAREN          shift and go to state 73


state 115

    (54) queueEnqueue -> VAR OBJOP PUSH . LPAREN value RPAREN SEMICOLON
    (51) stackPush -> VAR OBJOP PUSH . LPAREN value RPAREN SEMICOLON

    LPAREN          shift and go to state 146


state 116

    (55) queueDequeue -> VAR OBJOP POP . SEMICOLON
    (52) stackPop -> VAR OBJOP POP . SEMICOLON

    SEMICOLON       shift and go to state 147


state 117

    (56) defineFunction -> FUNCTION ID LPAREN . arguments RPAREN LCURLY programa RCURLY
    (57) defineFunction -> FUNCTION ID LPAREN . RPAREN LCURLY programa RCURLY
    (58) arguments -> . VAR
    (59) arguments -> . VAR COMMA arguments

    RPAREN          shift and go to state 149
    VAR             shift and go to state 120

    arguments                      shift and go to state 148

state 118

    (60) anonymousFunction -> FUNCTION LPAREN RPAREN . LCURLY cuerpo RCURLY

    LCURLY          shift and go to state 150


state 119

    (61) anonymousFunction -> FUNCTION LPAREN arguments . RPAREN LCURLY cuerpo RCURLY

    RPAREN          shift and go to state 151


state 120

    (58) arguments -> VAR .
    (59) arguments -> VAR . COMMA arguments

    RPAREN          reduce using rule 58 (arguments -> VAR .)
    COMMA           shift and go to state 152


state 121

    (75) callFunction -> ID LPAREN RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 153


state 122

    (76) callFunction -> ID LPAREN value . RPAREN SEMICOLON
    (109) stringConcatenation -> value . CONCAT value

    RPAREN          shift and go to state 154
    CONCAT          shift and go to state 51


state 123

    (62) arrowFunction -> FN LPAREN VAR . RPAREN FNARROW arrowBody SEMICOLON

    RPAREN          shift and go to state 155


state 124

    (65) echo -> ECHO values SEMICOLON .

    OPEN_TAG        reduce using rule 65 (echo -> ECHO values SEMICOLON .)
    CLOSE_TAG       reduce using rule 65 (echo -> ECHO values SEMICOLON .)
    STRING          reduce using rule 65 (echo -> ECHO values SEMICOLON .)
    LPAREN          reduce using rule 65 (echo -> ECHO values SEMICOLON .)
    IF              reduce using rule 65 (echo -> ECHO values SEMICOLON .)
    FOR             reduce using rule 65 (echo -> ECHO values SEMICOLON .)
    SWITCH          reduce using rule 65 (echo -> ECHO values SEMICOLON .)
    VAR             reduce using rule 65 (echo -> ECHO values SEMICOLON .)
    FUNCTION        reduce using rule 65 (echo -> ECHO values SEMICOLON .)
    FN              reduce using rule 65 (echo -> ECHO values SEMICOLON .)
    ECHO            reduce using rule 65 (echo -> ECHO values SEMICOLON .)
    PRINT           reduce using rule 65 (echo -> ECHO values SEMICOLON .)
    ID              reduce using rule 65 (echo -> ECHO values SEMICOLON .)
    INTEGER         reduce using rule 65 (echo -> ECHO values SEMICOLON .)
    FLOAT           reduce using rule 65 (echo -> ECHO values SEMICOLON .)
    $end            reduce using rule 65 (echo -> ECHO values SEMICOLON .)
    RCURLY          reduce using rule 65 (echo -> ECHO values SEMICOLON .)
    CONTINUE        reduce using rule 65 (echo -> ECHO values SEMICOLON .)
    SEMICOLON       reduce using rule 65 (echo -> ECHO values SEMICOLON .)
    BREAK           reduce using rule 65 (echo -> ECHO values SEMICOLON .)


state 125

    (69) values -> values COMMA . value
    (77) value -> . VAR
    (78) value -> . INTEGER
    (79) value -> . FLOAT
    (80) value -> . STRING
    (81) value -> . stringConcatenation
    (109) stringConcatenation -> . value CONCAT value
    (110) stringConcatenation -> . stringConcatenation CONCAT stringConcatenation

    VAR             shift and go to state 63
    INTEGER         shift and go to state 40
    FLOAT           shift and go to state 41
    STRING          shift and go to state 78

    value                          shift and go to state 156
    stringConcatenation            shift and go to state 64

state 126

    (66) print -> PRINT LPAREN values . RPAREN SEMICOLON
    (69) values -> values . COMMA value

    RPAREN          shift and go to state 157
    COMMA           shift and go to state 125


state 127

    (67) print -> PRINT value SEMICOLON .

    OPEN_TAG        reduce using rule 67 (print -> PRINT value SEMICOLON .)
    CLOSE_TAG       reduce using rule 67 (print -> PRINT value SEMICOLON .)
    STRING          reduce using rule 67 (print -> PRINT value SEMICOLON .)
    LPAREN          reduce using rule 67 (print -> PRINT value SEMICOLON .)
    IF              reduce using rule 67 (print -> PRINT value SEMICOLON .)
    FOR             reduce using rule 67 (print -> PRINT value SEMICOLON .)
    SWITCH          reduce using rule 67 (print -> PRINT value SEMICOLON .)
    VAR             reduce using rule 67 (print -> PRINT value SEMICOLON .)
    FUNCTION        reduce using rule 67 (print -> PRINT value SEMICOLON .)
    FN              reduce using rule 67 (print -> PRINT value SEMICOLON .)
    ECHO            reduce using rule 67 (print -> PRINT value SEMICOLON .)
    PRINT           reduce using rule 67 (print -> PRINT value SEMICOLON .)
    ID              reduce using rule 67 (print -> PRINT value SEMICOLON .)
    INTEGER         reduce using rule 67 (print -> PRINT value SEMICOLON .)
    FLOAT           reduce using rule 67 (print -> PRINT value SEMICOLON .)
    $end            reduce using rule 67 (print -> PRINT value SEMICOLON .)
    RCURLY          reduce using rule 67 (print -> PRINT value SEMICOLON .)
    CONTINUE        reduce using rule 67 (print -> PRINT value SEMICOLON .)
    SEMICOLON       reduce using rule 67 (print -> PRINT value SEMICOLON .)
    BREAK           reduce using rule 67 (print -> PRINT value SEMICOLON .)


state 128

    (104) logicalCondition -> comparingValue conditionOperator comparingValue .

    OPEN_TAG        reduce using rule 104 (logicalCondition -> comparingValue conditionOperator comparingValue .)
    CLOSE_TAG       reduce using rule 104 (logicalCondition -> comparingValue conditionOperator comparingValue .)
    STRING          reduce using rule 104 (logicalCondition -> comparingValue conditionOperator comparingValue .)
    LPAREN          reduce using rule 104 (logicalCondition -> comparingValue conditionOperator comparingValue .)
    IF              reduce using rule 104 (logicalCondition -> comparingValue conditionOperator comparingValue .)
    FOR             reduce using rule 104 (logicalCondition -> comparingValue conditionOperator comparingValue .)
    SWITCH          reduce using rule 104 (logicalCondition -> comparingValue conditionOperator comparingValue .)
    VAR             reduce using rule 104 (logicalCondition -> comparingValue conditionOperator comparingValue .)
    FUNCTION        reduce using rule 104 (logicalCondition -> comparingValue conditionOperator comparingValue .)
    FN              reduce using rule 104 (logicalCondition -> comparingValue conditionOperator comparingValue .)
    ECHO            reduce using rule 104 (logicalCondition -> comparingValue conditionOperator comparingValue .)
    PRINT           reduce using rule 104 (logicalCondition -> comparingValue conditionOperator comparingValue .)
    ID              reduce using rule 104 (logicalCondition -> comparingValue conditionOperator comparingValue .)
    INTEGER         reduce using rule 104 (logicalCondition -> comparingValue conditionOperator comparingValue .)
    FLOAT           reduce using rule 104 (logicalCondition -> comparingValue conditionOperator comparingValue .)
    $end            reduce using rule 104 (logicalCondition -> comparingValue conditionOperator comparingValue .)
    RPAREN          reduce using rule 104 (logicalCondition -> comparingValue conditionOperator comparingValue .)
    RCURLY          reduce using rule 104 (logicalCondition -> comparingValue conditionOperator comparingValue .)
    CONTINUE        reduce using rule 104 (logicalCondition -> comparingValue conditionOperator comparingValue .)
    SEMICOLON       reduce using rule 104 (logicalCondition -> comparingValue conditionOperator comparingValue .)
    BREAK           reduce using rule 104 (logicalCondition -> comparingValue conditionOperator comparingValue .)


state 129

    (31) if_elseStatement -> IF LPAREN logicalCondition RPAREN . LCURLY ifStatementBody RCURLY ELSE LCURLY ifStatementBody RCURLY
    (32) if_elseStatement -> IF LPAREN logicalCondition RPAREN . LCURLY ifStatementBody

    LCURLY          shift and go to state 158


state 130

    (36) forStatement -> FOR LPAREN forStatementCondition RPAREN . LCURLY forStatementBody RCURLY

    LCURLY          shift and go to state 159


state 131

    (37) forStatementCondition -> SEMICOLON SEMICOLON .

    RPAREN          reduce using rule 37 (forStatementCondition -> SEMICOLON SEMICOLON .)


state 132

    (38) forStatementCondition -> variableAsignation SEMICOLON . SEMICOLON variableAsignation
    (39) forStatementCondition -> variableAsignation SEMICOLON . comparingValue SEMICOLON variableAsignation
    (102) comparingValue -> . value comparingSign value
    (77) value -> . VAR
    (78) value -> . INTEGER
    (79) value -> . FLOAT
    (80) value -> . STRING
    (81) value -> . stringConcatenation
    (109) stringConcatenation -> . value CONCAT value
    (110) stringConcatenation -> . stringConcatenation CONCAT stringConcatenation

    SEMICOLON       shift and go to state 160
    VAR             shift and go to state 63
    INTEGER         shift and go to state 40
    FLOAT           shift and go to state 41
    STRING          shift and go to state 78

    comparingValue                 shift and go to state 161
    value                          shift and go to state 97
    stringConcatenation            shift and go to state 64

state 133

    (89) variableAsignation -> VAR EQUAL . value
    (90) variableAsignation -> VAR EQUAL . arithmeticExpression
    (93) variableAsignation -> VAR EQUAL . stringConcatenation
    (94) variableAsignation -> VAR EQUAL . anonymousFunction
    (77) value -> . VAR
    (78) value -> . INTEGER
    (79) value -> . FLOAT
    (80) value -> . STRING
    (81) value -> . stringConcatenation
    (71) arithmeticExpression -> . value
    (72) arithmeticExpression -> . STRING
    (73) arithmeticExpression -> . LPAREN arithmeticExpression RPAREN
    (74) arithmeticExpression -> . arithmeticExpression arithmeticOperator arithmeticExpression
    (109) stringConcatenation -> . value CONCAT value
    (110) stringConcatenation -> . stringConcatenation CONCAT stringConcatenation
    (60) anonymousFunction -> . FUNCTION LPAREN RPAREN LCURLY cuerpo RCURLY
    (61) anonymousFunction -> . FUNCTION LPAREN arguments RPAREN LCURLY cuerpo RCURLY

    VAR             shift and go to state 63
    INTEGER         shift and go to state 40
    FLOAT           shift and go to state 41
    STRING          shift and go to state 113
    LPAREN          shift and go to state 88
    FUNCTION        shift and go to state 114

    value                          shift and go to state 106
    arithmeticExpression           shift and go to state 107
    stringConcatenation            shift and go to state 108
    anonymousFunction              shift and go to state 109

state 134

    (26) switchStatement -> SWITCH LPAREN value RPAREN . LCURLY switchCases switchDefault RCURLY

    LCURLY          shift and go to state 162


state 135

    (42) arrayAsignation -> VAR EQUAL arrayDeclaration SEMICOLON .

    OPEN_TAG        reduce using rule 42 (arrayAsignation -> VAR EQUAL arrayDeclaration SEMICOLON .)
    CLOSE_TAG       reduce using rule 42 (arrayAsignation -> VAR EQUAL arrayDeclaration SEMICOLON .)
    STRING          reduce using rule 42 (arrayAsignation -> VAR EQUAL arrayDeclaration SEMICOLON .)
    LPAREN          reduce using rule 42 (arrayAsignation -> VAR EQUAL arrayDeclaration SEMICOLON .)
    IF              reduce using rule 42 (arrayAsignation -> VAR EQUAL arrayDeclaration SEMICOLON .)
    FOR             reduce using rule 42 (arrayAsignation -> VAR EQUAL arrayDeclaration SEMICOLON .)
    SWITCH          reduce using rule 42 (arrayAsignation -> VAR EQUAL arrayDeclaration SEMICOLON .)
    VAR             reduce using rule 42 (arrayAsignation -> VAR EQUAL arrayDeclaration SEMICOLON .)
    FUNCTION        reduce using rule 42 (arrayAsignation -> VAR EQUAL arrayDeclaration SEMICOLON .)
    FN              reduce using rule 42 (arrayAsignation -> VAR EQUAL arrayDeclaration SEMICOLON .)
    ECHO            reduce using rule 42 (arrayAsignation -> VAR EQUAL arrayDeclaration SEMICOLON .)
    PRINT           reduce using rule 42 (arrayAsignation -> VAR EQUAL arrayDeclaration SEMICOLON .)
    ID              reduce using rule 42 (arrayAsignation -> VAR EQUAL arrayDeclaration SEMICOLON .)
    INTEGER         reduce using rule 42 (arrayAsignation -> VAR EQUAL arrayDeclaration SEMICOLON .)
    FLOAT           reduce using rule 42 (arrayAsignation -> VAR EQUAL arrayDeclaration SEMICOLON .)
    $end            reduce using rule 42 (arrayAsignation -> VAR EQUAL arrayDeclaration SEMICOLON .)
    RCURLY          reduce using rule 42 (arrayAsignation -> VAR EQUAL arrayDeclaration SEMICOLON .)
    CONTINUE        reduce using rule 42 (arrayAsignation -> VAR EQUAL arrayDeclaration SEMICOLON .)
    SEMICOLON       reduce using rule 42 (arrayAsignation -> VAR EQUAL arrayDeclaration SEMICOLON .)
    BREAK           reduce using rule 42 (arrayAsignation -> VAR EQUAL arrayDeclaration SEMICOLON .)


state 136

    (53) queueDeclaration -> VAR EQUAL NEW QUEUE . SEMICOLON

    SEMICOLON       shift and go to state 163


state 137

    (50) stackDeclaration -> VAR EQUAL NEW STACK . SEMICOLON

    SEMICOLON       shift and go to state 164


state 138

    (70) fgets -> VAR EQUAL FGETS LPAREN . STDIN RPAREN SEMICOLON

    STDIN           shift and go to state 165


state 139

    (48) arrayValue -> ARRAY . values RPAREN
    (68) values -> . value
    (69) values -> . values COMMA value
    (77) value -> . VAR
    (78) value -> . INTEGER
    (79) value -> . FLOAT
    (80) value -> . STRING
    (81) value -> . stringConcatenation
    (109) stringConcatenation -> . value CONCAT value
    (110) stringConcatenation -> . stringConcatenation CONCAT stringConcatenation

    VAR             shift and go to state 63
    INTEGER         shift and go to state 40
    FLOAT           shift and go to state 41
    STRING          shift and go to state 78

    values                         shift and go to state 141
    value                          shift and go to state 77
    stringConcatenation            shift and go to state 64

state 140

    (43) arrayDeclaration -> ARRAY arraysValues . RPAREN
    (47) arraysValues -> arraysValues . COMMA arrayValue

    RPAREN          shift and go to state 166
    COMMA           shift and go to state 167


state 141

    (48) arrayValue -> ARRAY values . RPAREN
    (69) values -> values . COMMA value

    RPAREN          shift and go to state 168
    COMMA           shift and go to state 125


state 142

    (46) arraysValues -> arrayValue .

    RPAREN          reduce using rule 46 (arraysValues -> arrayValue .)
    COMMA           reduce using rule 46 (arraysValues -> arrayValue .)
    RSQUARE         reduce using rule 46 (arraysValues -> arrayValue .)


state 143

    (49) arrayValue -> LSQUARE . values RSQUARE
    (68) values -> . value
    (69) values -> . values COMMA value
    (77) value -> . VAR
    (78) value -> . INTEGER
    (79) value -> . FLOAT
    (80) value -> . STRING
    (81) value -> . stringConcatenation
    (109) stringConcatenation -> . value CONCAT value
    (110) stringConcatenation -> . stringConcatenation CONCAT stringConcatenation

    VAR             shift and go to state 63
    INTEGER         shift and go to state 40
    FLOAT           shift and go to state 41
    STRING          shift and go to state 78

    values                         shift and go to state 145
    value                          shift and go to state 77
    stringConcatenation            shift and go to state 64

state 144

    (44) arrayDeclaration -> LSQUARE arraysValues . RSQUARE
    (47) arraysValues -> arraysValues . COMMA arrayValue

    RSQUARE         shift and go to state 169
    COMMA           shift and go to state 167


state 145

    (49) arrayValue -> LSQUARE values . RSQUARE
    (69) values -> values . COMMA value

    RSQUARE         shift and go to state 170
    COMMA           shift and go to state 125


state 146

    (54) queueEnqueue -> VAR OBJOP PUSH LPAREN . value RPAREN SEMICOLON
    (51) stackPush -> VAR OBJOP PUSH LPAREN . value RPAREN SEMICOLON
    (77) value -> . VAR
    (78) value -> . INTEGER
    (79) value -> . FLOAT
    (80) value -> . STRING
    (81) value -> . stringConcatenation
    (109) stringConcatenation -> . value CONCAT value
    (110) stringConcatenation -> . stringConcatenation CONCAT stringConcatenation

    VAR             shift and go to state 63
    INTEGER         shift and go to state 40
    FLOAT           shift and go to state 41
    STRING          shift and go to state 78

    value                          shift and go to state 171
    stringConcatenation            shift and go to state 64

state 147

    (55) queueDequeue -> VAR OBJOP POP SEMICOLON .
    (52) stackPop -> VAR OBJOP POP SEMICOLON .

  ! reduce/reduce conflict for OPEN_TAG resolved using rule 52 (stackPop -> VAR OBJOP POP SEMICOLON .)
  ! reduce/reduce conflict for CLOSE_TAG resolved using rule 52 (stackPop -> VAR OBJOP POP SEMICOLON .)
  ! reduce/reduce conflict for STRING resolved using rule 52 (stackPop -> VAR OBJOP POP SEMICOLON .)
  ! reduce/reduce conflict for LPAREN resolved using rule 52 (stackPop -> VAR OBJOP POP SEMICOLON .)
  ! reduce/reduce conflict for IF resolved using rule 52 (stackPop -> VAR OBJOP POP SEMICOLON .)
  ! reduce/reduce conflict for FOR resolved using rule 52 (stackPop -> VAR OBJOP POP SEMICOLON .)
  ! reduce/reduce conflict for SWITCH resolved using rule 52 (stackPop -> VAR OBJOP POP SEMICOLON .)
  ! reduce/reduce conflict for VAR resolved using rule 52 (stackPop -> VAR OBJOP POP SEMICOLON .)
  ! reduce/reduce conflict for FUNCTION resolved using rule 52 (stackPop -> VAR OBJOP POP SEMICOLON .)
  ! reduce/reduce conflict for FN resolved using rule 52 (stackPop -> VAR OBJOP POP SEMICOLON .)
  ! reduce/reduce conflict for ECHO resolved using rule 52 (stackPop -> VAR OBJOP POP SEMICOLON .)
  ! reduce/reduce conflict for PRINT resolved using rule 52 (stackPop -> VAR OBJOP POP SEMICOLON .)
  ! reduce/reduce conflict for ID resolved using rule 52 (stackPop -> VAR OBJOP POP SEMICOLON .)
  ! reduce/reduce conflict for INTEGER resolved using rule 52 (stackPop -> VAR OBJOP POP SEMICOLON .)
  ! reduce/reduce conflict for FLOAT resolved using rule 52 (stackPop -> VAR OBJOP POP SEMICOLON .)
  ! reduce/reduce conflict for $end resolved using rule 52 (stackPop -> VAR OBJOP POP SEMICOLON .)
  ! reduce/reduce conflict for RCURLY resolved using rule 52 (stackPop -> VAR OBJOP POP SEMICOLON .)
  ! reduce/reduce conflict for CONTINUE resolved using rule 52 (stackPop -> VAR OBJOP POP SEMICOLON .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 52 (stackPop -> VAR OBJOP POP SEMICOLON .)
  ! reduce/reduce conflict for BREAK resolved using rule 52 (stackPop -> VAR OBJOP POP SEMICOLON .)
    OPEN_TAG        reduce using rule 52 (stackPop -> VAR OBJOP POP SEMICOLON .)
    CLOSE_TAG       reduce using rule 52 (stackPop -> VAR OBJOP POP SEMICOLON .)
    STRING          reduce using rule 52 (stackPop -> VAR OBJOP POP SEMICOLON .)
    LPAREN          reduce using rule 52 (stackPop -> VAR OBJOP POP SEMICOLON .)
    IF              reduce using rule 52 (stackPop -> VAR OBJOP POP SEMICOLON .)
    FOR             reduce using rule 52 (stackPop -> VAR OBJOP POP SEMICOLON .)
    SWITCH          reduce using rule 52 (stackPop -> VAR OBJOP POP SEMICOLON .)
    VAR             reduce using rule 52 (stackPop -> VAR OBJOP POP SEMICOLON .)
    FUNCTION        reduce using rule 52 (stackPop -> VAR OBJOP POP SEMICOLON .)
    FN              reduce using rule 52 (stackPop -> VAR OBJOP POP SEMICOLON .)
    ECHO            reduce using rule 52 (stackPop -> VAR OBJOP POP SEMICOLON .)
    PRINT           reduce using rule 52 (stackPop -> VAR OBJOP POP SEMICOLON .)
    ID              reduce using rule 52 (stackPop -> VAR OBJOP POP SEMICOLON .)
    INTEGER         reduce using rule 52 (stackPop -> VAR OBJOP POP SEMICOLON .)
    FLOAT           reduce using rule 52 (stackPop -> VAR OBJOP POP SEMICOLON .)
    $end            reduce using rule 52 (stackPop -> VAR OBJOP POP SEMICOLON .)
    RCURLY          reduce using rule 52 (stackPop -> VAR OBJOP POP SEMICOLON .)
    CONTINUE        reduce using rule 52 (stackPop -> VAR OBJOP POP SEMICOLON .)
    SEMICOLON       reduce using rule 52 (stackPop -> VAR OBJOP POP SEMICOLON .)
    BREAK           reduce using rule 52 (stackPop -> VAR OBJOP POP SEMICOLON .)

  ! OPEN_TAG        [ reduce using rule 55 (queueDequeue -> VAR OBJOP POP SEMICOLON .) ]
  ! CLOSE_TAG       [ reduce using rule 55 (queueDequeue -> VAR OBJOP POP SEMICOLON .) ]
  ! STRING          [ reduce using rule 55 (queueDequeue -> VAR OBJOP POP SEMICOLON .) ]
  ! LPAREN          [ reduce using rule 55 (queueDequeue -> VAR OBJOP POP SEMICOLON .) ]
  ! IF              [ reduce using rule 55 (queueDequeue -> VAR OBJOP POP SEMICOLON .) ]
  ! FOR             [ reduce using rule 55 (queueDequeue -> VAR OBJOP POP SEMICOLON .) ]
  ! SWITCH          [ reduce using rule 55 (queueDequeue -> VAR OBJOP POP SEMICOLON .) ]
  ! VAR             [ reduce using rule 55 (queueDequeue -> VAR OBJOP POP SEMICOLON .) ]
  ! FUNCTION        [ reduce using rule 55 (queueDequeue -> VAR OBJOP POP SEMICOLON .) ]
  ! FN              [ reduce using rule 55 (queueDequeue -> VAR OBJOP POP SEMICOLON .) ]
  ! ECHO            [ reduce using rule 55 (queueDequeue -> VAR OBJOP POP SEMICOLON .) ]
  ! PRINT           [ reduce using rule 55 (queueDequeue -> VAR OBJOP POP SEMICOLON .) ]
  ! ID              [ reduce using rule 55 (queueDequeue -> VAR OBJOP POP SEMICOLON .) ]
  ! INTEGER         [ reduce using rule 55 (queueDequeue -> VAR OBJOP POP SEMICOLON .) ]
  ! FLOAT           [ reduce using rule 55 (queueDequeue -> VAR OBJOP POP SEMICOLON .) ]
  ! $end            [ reduce using rule 55 (queueDequeue -> VAR OBJOP POP SEMICOLON .) ]
  ! RCURLY          [ reduce using rule 55 (queueDequeue -> VAR OBJOP POP SEMICOLON .) ]
  ! CONTINUE        [ reduce using rule 55 (queueDequeue -> VAR OBJOP POP SEMICOLON .) ]
  ! SEMICOLON       [ reduce using rule 55 (queueDequeue -> VAR OBJOP POP SEMICOLON .) ]
  ! BREAK           [ reduce using rule 55 (queueDequeue -> VAR OBJOP POP SEMICOLON .) ]


state 148

    (56) defineFunction -> FUNCTION ID LPAREN arguments . RPAREN LCURLY programa RCURLY

    RPAREN          shift and go to state 172


state 149

    (57) defineFunction -> FUNCTION ID LPAREN RPAREN . LCURLY programa RCURLY

    LCURLY          shift and go to state 173


state 150

    (60) anonymousFunction -> FUNCTION LPAREN RPAREN LCURLY . cuerpo RCURLY
    (3) cuerpo -> . arithmeticExpression
    (4) cuerpo -> . if_elseStatement
    (5) cuerpo -> . forStatement
    (6) cuerpo -> . switchStatement
    (7) cuerpo -> . arrayAsignation
    (8) cuerpo -> . queueDeclaration
    (9) cuerpo -> . queueEnqueue
    (10) cuerpo -> . queueDequeue
    (11) cuerpo -> . defineFunction
    (12) cuerpo -> . anonymousFunction
    (13) cuerpo -> . arrowFunction
    (14) cuerpo -> . echo
    (15) cuerpo -> . fgets
    (16) cuerpo -> . stackDeclaration
    (17) cuerpo -> . stackPush
    (18) cuerpo -> . stackPop
    (19) cuerpo -> . line
    (20) cuerpo -> . print
    (21) cuerpo -> . logicalCondition
    (22) cuerpo -> . OPEN_TAG
    (23) cuerpo -> . CLOSE_TAG
    (24) cuerpo -> . stringConcatenation
    (25) cuerpo -> . callFunction
    (71) arithmeticExpression -> . value
    (72) arithmeticExpression -> . STRING
    (73) arithmeticExpression -> . LPAREN arithmeticExpression RPAREN
    (74) arithmeticExpression -> . arithmeticExpression arithmeticOperator arithmeticExpression
    (31) if_elseStatement -> . IF LPAREN logicalCondition RPAREN LCURLY ifStatementBody RCURLY ELSE LCURLY ifStatementBody RCURLY
    (32) if_elseStatement -> . IF LPAREN logicalCondition RPAREN LCURLY ifStatementBody
    (36) forStatement -> . FOR LPAREN forStatementCondition RPAREN LCURLY forStatementBody RCURLY
    (26) switchStatement -> . SWITCH LPAREN value RPAREN LCURLY switchCases switchDefault RCURLY
    (42) arrayAsignation -> . VAR EQUAL arrayDeclaration SEMICOLON
    (53) queueDeclaration -> . VAR EQUAL NEW QUEUE SEMICOLON
    (54) queueEnqueue -> . VAR OBJOP PUSH LPAREN value RPAREN SEMICOLON
    (55) queueDequeue -> . VAR OBJOP POP SEMICOLON
    (56) defineFunction -> . FUNCTION ID LPAREN arguments RPAREN LCURLY programa RCURLY
    (57) defineFunction -> . FUNCTION ID LPAREN RPAREN LCURLY programa RCURLY
    (60) anonymousFunction -> . FUNCTION LPAREN RPAREN LCURLY cuerpo RCURLY
    (61) anonymousFunction -> . FUNCTION LPAREN arguments RPAREN LCURLY cuerpo RCURLY
    (62) arrowFunction -> . FN LPAREN VAR RPAREN FNARROW arrowBody SEMICOLON
    (65) echo -> . ECHO values SEMICOLON
    (70) fgets -> . VAR EQUAL FGETS LPAREN STDIN RPAREN SEMICOLON
    (50) stackDeclaration -> . VAR EQUAL NEW STACK SEMICOLON
    (51) stackPush -> . VAR OBJOP PUSH LPAREN value RPAREN SEMICOLON
    (52) stackPop -> . VAR OBJOP POP SEMICOLON
    (88) line -> . variableAsignation SEMICOLON
    (66) print -> . PRINT LPAREN values RPAREN SEMICOLON
    (67) print -> . PRINT value SEMICOLON
    (103) logicalCondition -> . comparingValue
    (104) logicalCondition -> . comparingValue conditionOperator comparingValue
    (105) logicalCondition -> . LPAREN logicalCondition RPAREN
    (109) stringConcatenation -> . value CONCAT value
    (110) stringConcatenation -> . stringConcatenation CONCAT stringConcatenation
    (75) callFunction -> . ID LPAREN RPAREN SEMICOLON
    (76) callFunction -> . ID LPAREN value RPAREN SEMICOLON
    (77) value -> . VAR
    (78) value -> . INTEGER
    (79) value -> . FLOAT
    (80) value -> . STRING
    (81) value -> . stringConcatenation
    (89) variableAsignation -> . VAR EQUAL value
    (90) variableAsignation -> . VAR EQUAL arithmeticExpression
    (91) variableAsignation -> . VAR INCREMENT
    (92) variableAsignation -> . VAR DECREMENT
    (93) variableAsignation -> . VAR EQUAL stringConcatenation
    (94) variableAsignation -> . VAR EQUAL anonymousFunction
    (102) comparingValue -> . value comparingSign value

    OPEN_TAG        shift and go to state 22
    CLOSE_TAG       shift and go to state 23
    STRING          shift and go to state 27
    LPAREN          shift and go to state 28
    IF              shift and go to state 29
    FOR             shift and go to state 30
    SWITCH          shift and go to state 31
    VAR             shift and go to state 32
    FUNCTION        shift and go to state 33
    FN              shift and go to state 35
    ECHO            shift and go to state 36
    PRINT           shift and go to state 38
    ID              shift and go to state 34
    INTEGER         shift and go to state 40
    FLOAT           shift and go to state 41

    cuerpo                         shift and go to state 174
    arithmeticExpression           shift and go to state 3
    if_elseStatement               shift and go to state 4
    forStatement                   shift and go to state 5
    switchStatement                shift and go to state 6
    arrayAsignation                shift and go to state 7
    queueDeclaration               shift and go to state 8
    queueEnqueue                   shift and go to state 9
    queueDequeue                   shift and go to state 10
    defineFunction                 shift and go to state 11
    anonymousFunction              shift and go to state 12
    arrowFunction                  shift and go to state 13
    echo                           shift and go to state 14
    fgets                          shift and go to state 15
    stackDeclaration               shift and go to state 16
    stackPush                      shift and go to state 17
    stackPop                       shift and go to state 18
    line                           shift and go to state 19
    print                          shift and go to state 20
    logicalCondition               shift and go to state 21
    stringConcatenation            shift and go to state 24
    callFunction                   shift and go to state 25
    value                          shift and go to state 26
    variableAsignation             shift and go to state 37
    comparingValue                 shift and go to state 39

state 151

    (61) anonymousFunction -> FUNCTION LPAREN arguments RPAREN . LCURLY cuerpo RCURLY

    LCURLY          shift and go to state 175


state 152

    (59) arguments -> VAR COMMA . arguments
    (58) arguments -> . VAR
    (59) arguments -> . VAR COMMA arguments

    VAR             shift and go to state 120

    arguments                      shift and go to state 176

state 153

    (75) callFunction -> ID LPAREN RPAREN SEMICOLON .

    OPEN_TAG        reduce using rule 75 (callFunction -> ID LPAREN RPAREN SEMICOLON .)
    CLOSE_TAG       reduce using rule 75 (callFunction -> ID LPAREN RPAREN SEMICOLON .)
    STRING          reduce using rule 75 (callFunction -> ID LPAREN RPAREN SEMICOLON .)
    LPAREN          reduce using rule 75 (callFunction -> ID LPAREN RPAREN SEMICOLON .)
    IF              reduce using rule 75 (callFunction -> ID LPAREN RPAREN SEMICOLON .)
    FOR             reduce using rule 75 (callFunction -> ID LPAREN RPAREN SEMICOLON .)
    SWITCH          reduce using rule 75 (callFunction -> ID LPAREN RPAREN SEMICOLON .)
    VAR             reduce using rule 75 (callFunction -> ID LPAREN RPAREN SEMICOLON .)
    FUNCTION        reduce using rule 75 (callFunction -> ID LPAREN RPAREN SEMICOLON .)
    FN              reduce using rule 75 (callFunction -> ID LPAREN RPAREN SEMICOLON .)
    ECHO            reduce using rule 75 (callFunction -> ID LPAREN RPAREN SEMICOLON .)
    PRINT           reduce using rule 75 (callFunction -> ID LPAREN RPAREN SEMICOLON .)
    ID              reduce using rule 75 (callFunction -> ID LPAREN RPAREN SEMICOLON .)
    INTEGER         reduce using rule 75 (callFunction -> ID LPAREN RPAREN SEMICOLON .)
    FLOAT           reduce using rule 75 (callFunction -> ID LPAREN RPAREN SEMICOLON .)
    $end            reduce using rule 75 (callFunction -> ID LPAREN RPAREN SEMICOLON .)
    RCURLY          reduce using rule 75 (callFunction -> ID LPAREN RPAREN SEMICOLON .)
    CONTINUE        reduce using rule 75 (callFunction -> ID LPAREN RPAREN SEMICOLON .)
    SEMICOLON       reduce using rule 75 (callFunction -> ID LPAREN RPAREN SEMICOLON .)
    BREAK           reduce using rule 75 (callFunction -> ID LPAREN RPAREN SEMICOLON .)


state 154

    (76) callFunction -> ID LPAREN value RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 177


state 155

    (62) arrowFunction -> FN LPAREN VAR RPAREN . FNARROW arrowBody SEMICOLON

    FNARROW         shift and go to state 178


state 156

    (69) values -> values COMMA value .
    (109) stringConcatenation -> value . CONCAT value

    SEMICOLON       reduce using rule 69 (values -> values COMMA value .)
    COMMA           reduce using rule 69 (values -> values COMMA value .)
    RPAREN          reduce using rule 69 (values -> values COMMA value .)
    RSQUARE         reduce using rule 69 (values -> values COMMA value .)
    CONCAT          shift and go to state 51


state 157

    (66) print -> PRINT LPAREN values RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 179


state 158

    (31) if_elseStatement -> IF LPAREN logicalCondition RPAREN LCURLY . ifStatementBody RCURLY ELSE LCURLY ifStatementBody RCURLY
    (32) if_elseStatement -> IF LPAREN logicalCondition RPAREN LCURLY . ifStatementBody
    (33) ifStatementBody -> . cuerpo
    (34) ifStatementBody -> . cuerpo CONTINUE SEMICOLON
    (35) ifStatementBody -> . ifStatementBody cuerpo
    (3) cuerpo -> . arithmeticExpression
    (4) cuerpo -> . if_elseStatement
    (5) cuerpo -> . forStatement
    (6) cuerpo -> . switchStatement
    (7) cuerpo -> . arrayAsignation
    (8) cuerpo -> . queueDeclaration
    (9) cuerpo -> . queueEnqueue
    (10) cuerpo -> . queueDequeue
    (11) cuerpo -> . defineFunction
    (12) cuerpo -> . anonymousFunction
    (13) cuerpo -> . arrowFunction
    (14) cuerpo -> . echo
    (15) cuerpo -> . fgets
    (16) cuerpo -> . stackDeclaration
    (17) cuerpo -> . stackPush
    (18) cuerpo -> . stackPop
    (19) cuerpo -> . line
    (20) cuerpo -> . print
    (21) cuerpo -> . logicalCondition
    (22) cuerpo -> . OPEN_TAG
    (23) cuerpo -> . CLOSE_TAG
    (24) cuerpo -> . stringConcatenation
    (25) cuerpo -> . callFunction
    (71) arithmeticExpression -> . value
    (72) arithmeticExpression -> . STRING
    (73) arithmeticExpression -> . LPAREN arithmeticExpression RPAREN
    (74) arithmeticExpression -> . arithmeticExpression arithmeticOperator arithmeticExpression
    (31) if_elseStatement -> . IF LPAREN logicalCondition RPAREN LCURLY ifStatementBody RCURLY ELSE LCURLY ifStatementBody RCURLY
    (32) if_elseStatement -> . IF LPAREN logicalCondition RPAREN LCURLY ifStatementBody
    (36) forStatement -> . FOR LPAREN forStatementCondition RPAREN LCURLY forStatementBody RCURLY
    (26) switchStatement -> . SWITCH LPAREN value RPAREN LCURLY switchCases switchDefault RCURLY
    (42) arrayAsignation -> . VAR EQUAL arrayDeclaration SEMICOLON
    (53) queueDeclaration -> . VAR EQUAL NEW QUEUE SEMICOLON
    (54) queueEnqueue -> . VAR OBJOP PUSH LPAREN value RPAREN SEMICOLON
    (55) queueDequeue -> . VAR OBJOP POP SEMICOLON
    (56) defineFunction -> . FUNCTION ID LPAREN arguments RPAREN LCURLY programa RCURLY
    (57) defineFunction -> . FUNCTION ID LPAREN RPAREN LCURLY programa RCURLY
    (60) anonymousFunction -> . FUNCTION LPAREN RPAREN LCURLY cuerpo RCURLY
    (61) anonymousFunction -> . FUNCTION LPAREN arguments RPAREN LCURLY cuerpo RCURLY
    (62) arrowFunction -> . FN LPAREN VAR RPAREN FNARROW arrowBody SEMICOLON
    (65) echo -> . ECHO values SEMICOLON
    (70) fgets -> . VAR EQUAL FGETS LPAREN STDIN RPAREN SEMICOLON
    (50) stackDeclaration -> . VAR EQUAL NEW STACK SEMICOLON
    (51) stackPush -> . VAR OBJOP PUSH LPAREN value RPAREN SEMICOLON
    (52) stackPop -> . VAR OBJOP POP SEMICOLON
    (88) line -> . variableAsignation SEMICOLON
    (66) print -> . PRINT LPAREN values RPAREN SEMICOLON
    (67) print -> . PRINT value SEMICOLON
    (103) logicalCondition -> . comparingValue
    (104) logicalCondition -> . comparingValue conditionOperator comparingValue
    (105) logicalCondition -> . LPAREN logicalCondition RPAREN
    (109) stringConcatenation -> . value CONCAT value
    (110) stringConcatenation -> . stringConcatenation CONCAT stringConcatenation
    (75) callFunction -> . ID LPAREN RPAREN SEMICOLON
    (76) callFunction -> . ID LPAREN value RPAREN SEMICOLON
    (77) value -> . VAR
    (78) value -> . INTEGER
    (79) value -> . FLOAT
    (80) value -> . STRING
    (81) value -> . stringConcatenation
    (89) variableAsignation -> . VAR EQUAL value
    (90) variableAsignation -> . VAR EQUAL arithmeticExpression
    (91) variableAsignation -> . VAR INCREMENT
    (92) variableAsignation -> . VAR DECREMENT
    (93) variableAsignation -> . VAR EQUAL stringConcatenation
    (94) variableAsignation -> . VAR EQUAL anonymousFunction
    (102) comparingValue -> . value comparingSign value

    OPEN_TAG        shift and go to state 22
    CLOSE_TAG       shift and go to state 23
    STRING          shift and go to state 27
    LPAREN          shift and go to state 28
    IF              shift and go to state 29
    FOR             shift and go to state 30
    SWITCH          shift and go to state 31
    VAR             shift and go to state 32
    FUNCTION        shift and go to state 33
    FN              shift and go to state 35
    ECHO            shift and go to state 36
    PRINT           shift and go to state 38
    ID              shift and go to state 34
    INTEGER         shift and go to state 40
    FLOAT           shift and go to state 41

    logicalCondition               shift and go to state 21
    ifStatementBody                shift and go to state 180
    cuerpo                         shift and go to state 181
    arithmeticExpression           shift and go to state 3
    if_elseStatement               shift and go to state 4
    forStatement                   shift and go to state 5
    switchStatement                shift and go to state 6
    arrayAsignation                shift and go to state 7
    queueDeclaration               shift and go to state 8
    queueEnqueue                   shift and go to state 9
    queueDequeue                   shift and go to state 10
    defineFunction                 shift and go to state 11
    anonymousFunction              shift and go to state 12
    arrowFunction                  shift and go to state 13
    echo                           shift and go to state 14
    fgets                          shift and go to state 15
    stackDeclaration               shift and go to state 16
    stackPush                      shift and go to state 17
    stackPop                       shift and go to state 18
    line                           shift and go to state 19
    print                          shift and go to state 20
    stringConcatenation            shift and go to state 24
    callFunction                   shift and go to state 25
    value                          shift and go to state 26
    variableAsignation             shift and go to state 37
    comparingValue                 shift and go to state 39

state 159

    (36) forStatement -> FOR LPAREN forStatementCondition RPAREN LCURLY . forStatementBody RCURLY
    (40) forStatementBody -> . cuerpo
    (41) forStatementBody -> . forStatementBody cuerpo
    (3) cuerpo -> . arithmeticExpression
    (4) cuerpo -> . if_elseStatement
    (5) cuerpo -> . forStatement
    (6) cuerpo -> . switchStatement
    (7) cuerpo -> . arrayAsignation
    (8) cuerpo -> . queueDeclaration
    (9) cuerpo -> . queueEnqueue
    (10) cuerpo -> . queueDequeue
    (11) cuerpo -> . defineFunction
    (12) cuerpo -> . anonymousFunction
    (13) cuerpo -> . arrowFunction
    (14) cuerpo -> . echo
    (15) cuerpo -> . fgets
    (16) cuerpo -> . stackDeclaration
    (17) cuerpo -> . stackPush
    (18) cuerpo -> . stackPop
    (19) cuerpo -> . line
    (20) cuerpo -> . print
    (21) cuerpo -> . logicalCondition
    (22) cuerpo -> . OPEN_TAG
    (23) cuerpo -> . CLOSE_TAG
    (24) cuerpo -> . stringConcatenation
    (25) cuerpo -> . callFunction
    (71) arithmeticExpression -> . value
    (72) arithmeticExpression -> . STRING
    (73) arithmeticExpression -> . LPAREN arithmeticExpression RPAREN
    (74) arithmeticExpression -> . arithmeticExpression arithmeticOperator arithmeticExpression
    (31) if_elseStatement -> . IF LPAREN logicalCondition RPAREN LCURLY ifStatementBody RCURLY ELSE LCURLY ifStatementBody RCURLY
    (32) if_elseStatement -> . IF LPAREN logicalCondition RPAREN LCURLY ifStatementBody
    (36) forStatement -> . FOR LPAREN forStatementCondition RPAREN LCURLY forStatementBody RCURLY
    (26) switchStatement -> . SWITCH LPAREN value RPAREN LCURLY switchCases switchDefault RCURLY
    (42) arrayAsignation -> . VAR EQUAL arrayDeclaration SEMICOLON
    (53) queueDeclaration -> . VAR EQUAL NEW QUEUE SEMICOLON
    (54) queueEnqueue -> . VAR OBJOP PUSH LPAREN value RPAREN SEMICOLON
    (55) queueDequeue -> . VAR OBJOP POP SEMICOLON
    (56) defineFunction -> . FUNCTION ID LPAREN arguments RPAREN LCURLY programa RCURLY
    (57) defineFunction -> . FUNCTION ID LPAREN RPAREN LCURLY programa RCURLY
    (60) anonymousFunction -> . FUNCTION LPAREN RPAREN LCURLY cuerpo RCURLY
    (61) anonymousFunction -> . FUNCTION LPAREN arguments RPAREN LCURLY cuerpo RCURLY
    (62) arrowFunction -> . FN LPAREN VAR RPAREN FNARROW arrowBody SEMICOLON
    (65) echo -> . ECHO values SEMICOLON
    (70) fgets -> . VAR EQUAL FGETS LPAREN STDIN RPAREN SEMICOLON
    (50) stackDeclaration -> . VAR EQUAL NEW STACK SEMICOLON
    (51) stackPush -> . VAR OBJOP PUSH LPAREN value RPAREN SEMICOLON
    (52) stackPop -> . VAR OBJOP POP SEMICOLON
    (88) line -> . variableAsignation SEMICOLON
    (66) print -> . PRINT LPAREN values RPAREN SEMICOLON
    (67) print -> . PRINT value SEMICOLON
    (103) logicalCondition -> . comparingValue
    (104) logicalCondition -> . comparingValue conditionOperator comparingValue
    (105) logicalCondition -> . LPAREN logicalCondition RPAREN
    (109) stringConcatenation -> . value CONCAT value
    (110) stringConcatenation -> . stringConcatenation CONCAT stringConcatenation
    (75) callFunction -> . ID LPAREN RPAREN SEMICOLON
    (76) callFunction -> . ID LPAREN value RPAREN SEMICOLON
    (77) value -> . VAR
    (78) value -> . INTEGER
    (79) value -> . FLOAT
    (80) value -> . STRING
    (81) value -> . stringConcatenation
    (89) variableAsignation -> . VAR EQUAL value
    (90) variableAsignation -> . VAR EQUAL arithmeticExpression
    (91) variableAsignation -> . VAR INCREMENT
    (92) variableAsignation -> . VAR DECREMENT
    (93) variableAsignation -> . VAR EQUAL stringConcatenation
    (94) variableAsignation -> . VAR EQUAL anonymousFunction
    (102) comparingValue -> . value comparingSign value

    OPEN_TAG        shift and go to state 22
    CLOSE_TAG       shift and go to state 23
    STRING          shift and go to state 27
    LPAREN          shift and go to state 28
    IF              shift and go to state 29
    FOR             shift and go to state 30
    SWITCH          shift and go to state 31
    VAR             shift and go to state 32
    FUNCTION        shift and go to state 33
    FN              shift and go to state 35
    ECHO            shift and go to state 36
    PRINT           shift and go to state 38
    ID              shift and go to state 34
    INTEGER         shift and go to state 40
    FLOAT           shift and go to state 41

    forStatementBody               shift and go to state 182
    cuerpo                         shift and go to state 183
    arithmeticExpression           shift and go to state 3
    if_elseStatement               shift and go to state 4
    forStatement                   shift and go to state 5
    switchStatement                shift and go to state 6
    arrayAsignation                shift and go to state 7
    queueDeclaration               shift and go to state 8
    queueEnqueue                   shift and go to state 9
    queueDequeue                   shift and go to state 10
    defineFunction                 shift and go to state 11
    anonymousFunction              shift and go to state 12
    arrowFunction                  shift and go to state 13
    echo                           shift and go to state 14
    fgets                          shift and go to state 15
    stackDeclaration               shift and go to state 16
    stackPush                      shift and go to state 17
    stackPop                       shift and go to state 18
    line                           shift and go to state 19
    print                          shift and go to state 20
    logicalCondition               shift and go to state 21
    stringConcatenation            shift and go to state 24
    callFunction                   shift and go to state 25
    value                          shift and go to state 26
    variableAsignation             shift and go to state 37
    comparingValue                 shift and go to state 39

state 160

    (38) forStatementCondition -> variableAsignation SEMICOLON SEMICOLON . variableAsignation
    (89) variableAsignation -> . VAR EQUAL value
    (90) variableAsignation -> . VAR EQUAL arithmeticExpression
    (91) variableAsignation -> . VAR INCREMENT
    (92) variableAsignation -> . VAR DECREMENT
    (93) variableAsignation -> . VAR EQUAL stringConcatenation
    (94) variableAsignation -> . VAR EQUAL anonymousFunction

    VAR             shift and go to state 101

    variableAsignation             shift and go to state 184

state 161

    (39) forStatementCondition -> variableAsignation SEMICOLON comparingValue . SEMICOLON variableAsignation

    SEMICOLON       shift and go to state 185


state 162

    (26) switchStatement -> SWITCH LPAREN value RPAREN LCURLY . switchCases switchDefault RCURLY
    (29) switchCases -> . switchCase
    (30) switchCases -> . switchCases switchCase
    (28) switchCase -> . CASE value COLON programa BREAK SEMICOLON

    CASE            shift and go to state 188

    switchCases                    shift and go to state 186
    switchCase                     shift and go to state 187

state 163

    (53) queueDeclaration -> VAR EQUAL NEW QUEUE SEMICOLON .

    OPEN_TAG        reduce using rule 53 (queueDeclaration -> VAR EQUAL NEW QUEUE SEMICOLON .)
    CLOSE_TAG       reduce using rule 53 (queueDeclaration -> VAR EQUAL NEW QUEUE SEMICOLON .)
    STRING          reduce using rule 53 (queueDeclaration -> VAR EQUAL NEW QUEUE SEMICOLON .)
    LPAREN          reduce using rule 53 (queueDeclaration -> VAR EQUAL NEW QUEUE SEMICOLON .)
    IF              reduce using rule 53 (queueDeclaration -> VAR EQUAL NEW QUEUE SEMICOLON .)
    FOR             reduce using rule 53 (queueDeclaration -> VAR EQUAL NEW QUEUE SEMICOLON .)
    SWITCH          reduce using rule 53 (queueDeclaration -> VAR EQUAL NEW QUEUE SEMICOLON .)
    VAR             reduce using rule 53 (queueDeclaration -> VAR EQUAL NEW QUEUE SEMICOLON .)
    FUNCTION        reduce using rule 53 (queueDeclaration -> VAR EQUAL NEW QUEUE SEMICOLON .)
    FN              reduce using rule 53 (queueDeclaration -> VAR EQUAL NEW QUEUE SEMICOLON .)
    ECHO            reduce using rule 53 (queueDeclaration -> VAR EQUAL NEW QUEUE SEMICOLON .)
    PRINT           reduce using rule 53 (queueDeclaration -> VAR EQUAL NEW QUEUE SEMICOLON .)
    ID              reduce using rule 53 (queueDeclaration -> VAR EQUAL NEW QUEUE SEMICOLON .)
    INTEGER         reduce using rule 53 (queueDeclaration -> VAR EQUAL NEW QUEUE SEMICOLON .)
    FLOAT           reduce using rule 53 (queueDeclaration -> VAR EQUAL NEW QUEUE SEMICOLON .)
    $end            reduce using rule 53 (queueDeclaration -> VAR EQUAL NEW QUEUE SEMICOLON .)
    RCURLY          reduce using rule 53 (queueDeclaration -> VAR EQUAL NEW QUEUE SEMICOLON .)
    CONTINUE        reduce using rule 53 (queueDeclaration -> VAR EQUAL NEW QUEUE SEMICOLON .)
    SEMICOLON       reduce using rule 53 (queueDeclaration -> VAR EQUAL NEW QUEUE SEMICOLON .)
    BREAK           reduce using rule 53 (queueDeclaration -> VAR EQUAL NEW QUEUE SEMICOLON .)


state 164

    (50) stackDeclaration -> VAR EQUAL NEW STACK SEMICOLON .

    OPEN_TAG        reduce using rule 50 (stackDeclaration -> VAR EQUAL NEW STACK SEMICOLON .)
    CLOSE_TAG       reduce using rule 50 (stackDeclaration -> VAR EQUAL NEW STACK SEMICOLON .)
    STRING          reduce using rule 50 (stackDeclaration -> VAR EQUAL NEW STACK SEMICOLON .)
    LPAREN          reduce using rule 50 (stackDeclaration -> VAR EQUAL NEW STACK SEMICOLON .)
    IF              reduce using rule 50 (stackDeclaration -> VAR EQUAL NEW STACK SEMICOLON .)
    FOR             reduce using rule 50 (stackDeclaration -> VAR EQUAL NEW STACK SEMICOLON .)
    SWITCH          reduce using rule 50 (stackDeclaration -> VAR EQUAL NEW STACK SEMICOLON .)
    VAR             reduce using rule 50 (stackDeclaration -> VAR EQUAL NEW STACK SEMICOLON .)
    FUNCTION        reduce using rule 50 (stackDeclaration -> VAR EQUAL NEW STACK SEMICOLON .)
    FN              reduce using rule 50 (stackDeclaration -> VAR EQUAL NEW STACK SEMICOLON .)
    ECHO            reduce using rule 50 (stackDeclaration -> VAR EQUAL NEW STACK SEMICOLON .)
    PRINT           reduce using rule 50 (stackDeclaration -> VAR EQUAL NEW STACK SEMICOLON .)
    ID              reduce using rule 50 (stackDeclaration -> VAR EQUAL NEW STACK SEMICOLON .)
    INTEGER         reduce using rule 50 (stackDeclaration -> VAR EQUAL NEW STACK SEMICOLON .)
    FLOAT           reduce using rule 50 (stackDeclaration -> VAR EQUAL NEW STACK SEMICOLON .)
    $end            reduce using rule 50 (stackDeclaration -> VAR EQUAL NEW STACK SEMICOLON .)
    RCURLY          reduce using rule 50 (stackDeclaration -> VAR EQUAL NEW STACK SEMICOLON .)
    CONTINUE        reduce using rule 50 (stackDeclaration -> VAR EQUAL NEW STACK SEMICOLON .)
    SEMICOLON       reduce using rule 50 (stackDeclaration -> VAR EQUAL NEW STACK SEMICOLON .)
    BREAK           reduce using rule 50 (stackDeclaration -> VAR EQUAL NEW STACK SEMICOLON .)


state 165

    (70) fgets -> VAR EQUAL FGETS LPAREN STDIN . RPAREN SEMICOLON

    RPAREN          shift and go to state 189


state 166

    (43) arrayDeclaration -> ARRAY arraysValues RPAREN .

    SEMICOLON       reduce using rule 43 (arrayDeclaration -> ARRAY arraysValues RPAREN .)


state 167

    (47) arraysValues -> arraysValues COMMA . arrayValue
    (48) arrayValue -> . ARRAY values RPAREN
    (49) arrayValue -> . LSQUARE values RSQUARE

    ARRAY           shift and go to state 139
    LSQUARE         shift and go to state 143

    arrayValue                     shift and go to state 190

state 168

    (48) arrayValue -> ARRAY values RPAREN .

    SEMICOLON       reduce using rule 48 (arrayValue -> ARRAY values RPAREN .)
    RPAREN          reduce using rule 48 (arrayValue -> ARRAY values RPAREN .)
    COMMA           reduce using rule 48 (arrayValue -> ARRAY values RPAREN .)
    RSQUARE         reduce using rule 48 (arrayValue -> ARRAY values RPAREN .)


state 169

    (44) arrayDeclaration -> LSQUARE arraysValues RSQUARE .

    SEMICOLON       reduce using rule 44 (arrayDeclaration -> LSQUARE arraysValues RSQUARE .)


state 170

    (49) arrayValue -> LSQUARE values RSQUARE .

    SEMICOLON       reduce using rule 49 (arrayValue -> LSQUARE values RSQUARE .)
    RPAREN          reduce using rule 49 (arrayValue -> LSQUARE values RSQUARE .)
    COMMA           reduce using rule 49 (arrayValue -> LSQUARE values RSQUARE .)
    RSQUARE         reduce using rule 49 (arrayValue -> LSQUARE values RSQUARE .)


state 171

    (54) queueEnqueue -> VAR OBJOP PUSH LPAREN value . RPAREN SEMICOLON
    (51) stackPush -> VAR OBJOP PUSH LPAREN value . RPAREN SEMICOLON
    (109) stringConcatenation -> value . CONCAT value

    RPAREN          shift and go to state 191
    CONCAT          shift and go to state 51


state 172

    (56) defineFunction -> FUNCTION ID LPAREN arguments RPAREN . LCURLY programa RCURLY

    LCURLY          shift and go to state 192


state 173

    (57) defineFunction -> FUNCTION ID LPAREN RPAREN LCURLY . programa RCURLY
    (1) programa -> . cuerpo
    (2) programa -> . programa cuerpo
    (3) cuerpo -> . arithmeticExpression
    (4) cuerpo -> . if_elseStatement
    (5) cuerpo -> . forStatement
    (6) cuerpo -> . switchStatement
    (7) cuerpo -> . arrayAsignation
    (8) cuerpo -> . queueDeclaration
    (9) cuerpo -> . queueEnqueue
    (10) cuerpo -> . queueDequeue
    (11) cuerpo -> . defineFunction
    (12) cuerpo -> . anonymousFunction
    (13) cuerpo -> . arrowFunction
    (14) cuerpo -> . echo
    (15) cuerpo -> . fgets
    (16) cuerpo -> . stackDeclaration
    (17) cuerpo -> . stackPush
    (18) cuerpo -> . stackPop
    (19) cuerpo -> . line
    (20) cuerpo -> . print
    (21) cuerpo -> . logicalCondition
    (22) cuerpo -> . OPEN_TAG
    (23) cuerpo -> . CLOSE_TAG
    (24) cuerpo -> . stringConcatenation
    (25) cuerpo -> . callFunction
    (71) arithmeticExpression -> . value
    (72) arithmeticExpression -> . STRING
    (73) arithmeticExpression -> . LPAREN arithmeticExpression RPAREN
    (74) arithmeticExpression -> . arithmeticExpression arithmeticOperator arithmeticExpression
    (31) if_elseStatement -> . IF LPAREN logicalCondition RPAREN LCURLY ifStatementBody RCURLY ELSE LCURLY ifStatementBody RCURLY
    (32) if_elseStatement -> . IF LPAREN logicalCondition RPAREN LCURLY ifStatementBody
    (36) forStatement -> . FOR LPAREN forStatementCondition RPAREN LCURLY forStatementBody RCURLY
    (26) switchStatement -> . SWITCH LPAREN value RPAREN LCURLY switchCases switchDefault RCURLY
    (42) arrayAsignation -> . VAR EQUAL arrayDeclaration SEMICOLON
    (53) queueDeclaration -> . VAR EQUAL NEW QUEUE SEMICOLON
    (54) queueEnqueue -> . VAR OBJOP PUSH LPAREN value RPAREN SEMICOLON
    (55) queueDequeue -> . VAR OBJOP POP SEMICOLON
    (56) defineFunction -> . FUNCTION ID LPAREN arguments RPAREN LCURLY programa RCURLY
    (57) defineFunction -> . FUNCTION ID LPAREN RPAREN LCURLY programa RCURLY
    (60) anonymousFunction -> . FUNCTION LPAREN RPAREN LCURLY cuerpo RCURLY
    (61) anonymousFunction -> . FUNCTION LPAREN arguments RPAREN LCURLY cuerpo RCURLY
    (62) arrowFunction -> . FN LPAREN VAR RPAREN FNARROW arrowBody SEMICOLON
    (65) echo -> . ECHO values SEMICOLON
    (70) fgets -> . VAR EQUAL FGETS LPAREN STDIN RPAREN SEMICOLON
    (50) stackDeclaration -> . VAR EQUAL NEW STACK SEMICOLON
    (51) stackPush -> . VAR OBJOP PUSH LPAREN value RPAREN SEMICOLON
    (52) stackPop -> . VAR OBJOP POP SEMICOLON
    (88) line -> . variableAsignation SEMICOLON
    (66) print -> . PRINT LPAREN values RPAREN SEMICOLON
    (67) print -> . PRINT value SEMICOLON
    (103) logicalCondition -> . comparingValue
    (104) logicalCondition -> . comparingValue conditionOperator comparingValue
    (105) logicalCondition -> . LPAREN logicalCondition RPAREN
    (109) stringConcatenation -> . value CONCAT value
    (110) stringConcatenation -> . stringConcatenation CONCAT stringConcatenation
    (75) callFunction -> . ID LPAREN RPAREN SEMICOLON
    (76) callFunction -> . ID LPAREN value RPAREN SEMICOLON
    (77) value -> . VAR
    (78) value -> . INTEGER
    (79) value -> . FLOAT
    (80) value -> . STRING
    (81) value -> . stringConcatenation
    (89) variableAsignation -> . VAR EQUAL value
    (90) variableAsignation -> . VAR EQUAL arithmeticExpression
    (91) variableAsignation -> . VAR INCREMENT
    (92) variableAsignation -> . VAR DECREMENT
    (93) variableAsignation -> . VAR EQUAL stringConcatenation
    (94) variableAsignation -> . VAR EQUAL anonymousFunction
    (102) comparingValue -> . value comparingSign value

    OPEN_TAG        shift and go to state 22
    CLOSE_TAG       shift and go to state 23
    STRING          shift and go to state 27
    LPAREN          shift and go to state 28
    IF              shift and go to state 29
    FOR             shift and go to state 30
    SWITCH          shift and go to state 31
    VAR             shift and go to state 32
    FUNCTION        shift and go to state 33
    FN              shift and go to state 35
    ECHO            shift and go to state 36
    PRINT           shift and go to state 38
    ID              shift and go to state 34
    INTEGER         shift and go to state 40
    FLOAT           shift and go to state 41

    programa                       shift and go to state 193
    cuerpo                         shift and go to state 2
    arithmeticExpression           shift and go to state 3
    if_elseStatement               shift and go to state 4
    forStatement                   shift and go to state 5
    switchStatement                shift and go to state 6
    arrayAsignation                shift and go to state 7
    queueDeclaration               shift and go to state 8
    queueEnqueue                   shift and go to state 9
    queueDequeue                   shift and go to state 10
    defineFunction                 shift and go to state 11
    anonymousFunction              shift and go to state 12
    arrowFunction                  shift and go to state 13
    echo                           shift and go to state 14
    fgets                          shift and go to state 15
    stackDeclaration               shift and go to state 16
    stackPush                      shift and go to state 17
    stackPop                       shift and go to state 18
    line                           shift and go to state 19
    print                          shift and go to state 20
    logicalCondition               shift and go to state 21
    stringConcatenation            shift and go to state 24
    callFunction                   shift and go to state 25
    value                          shift and go to state 26
    variableAsignation             shift and go to state 37
    comparingValue                 shift and go to state 39

state 174

    (60) anonymousFunction -> FUNCTION LPAREN RPAREN LCURLY cuerpo . RCURLY

    RCURLY          shift and go to state 194


state 175

    (61) anonymousFunction -> FUNCTION LPAREN arguments RPAREN LCURLY . cuerpo RCURLY
    (3) cuerpo -> . arithmeticExpression
    (4) cuerpo -> . if_elseStatement
    (5) cuerpo -> . forStatement
    (6) cuerpo -> . switchStatement
    (7) cuerpo -> . arrayAsignation
    (8) cuerpo -> . queueDeclaration
    (9) cuerpo -> . queueEnqueue
    (10) cuerpo -> . queueDequeue
    (11) cuerpo -> . defineFunction
    (12) cuerpo -> . anonymousFunction
    (13) cuerpo -> . arrowFunction
    (14) cuerpo -> . echo
    (15) cuerpo -> . fgets
    (16) cuerpo -> . stackDeclaration
    (17) cuerpo -> . stackPush
    (18) cuerpo -> . stackPop
    (19) cuerpo -> . line
    (20) cuerpo -> . print
    (21) cuerpo -> . logicalCondition
    (22) cuerpo -> . OPEN_TAG
    (23) cuerpo -> . CLOSE_TAG
    (24) cuerpo -> . stringConcatenation
    (25) cuerpo -> . callFunction
    (71) arithmeticExpression -> . value
    (72) arithmeticExpression -> . STRING
    (73) arithmeticExpression -> . LPAREN arithmeticExpression RPAREN
    (74) arithmeticExpression -> . arithmeticExpression arithmeticOperator arithmeticExpression
    (31) if_elseStatement -> . IF LPAREN logicalCondition RPAREN LCURLY ifStatementBody RCURLY ELSE LCURLY ifStatementBody RCURLY
    (32) if_elseStatement -> . IF LPAREN logicalCondition RPAREN LCURLY ifStatementBody
    (36) forStatement -> . FOR LPAREN forStatementCondition RPAREN LCURLY forStatementBody RCURLY
    (26) switchStatement -> . SWITCH LPAREN value RPAREN LCURLY switchCases switchDefault RCURLY
    (42) arrayAsignation -> . VAR EQUAL arrayDeclaration SEMICOLON
    (53) queueDeclaration -> . VAR EQUAL NEW QUEUE SEMICOLON
    (54) queueEnqueue -> . VAR OBJOP PUSH LPAREN value RPAREN SEMICOLON
    (55) queueDequeue -> . VAR OBJOP POP SEMICOLON
    (56) defineFunction -> . FUNCTION ID LPAREN arguments RPAREN LCURLY programa RCURLY
    (57) defineFunction -> . FUNCTION ID LPAREN RPAREN LCURLY programa RCURLY
    (60) anonymousFunction -> . FUNCTION LPAREN RPAREN LCURLY cuerpo RCURLY
    (61) anonymousFunction -> . FUNCTION LPAREN arguments RPAREN LCURLY cuerpo RCURLY
    (62) arrowFunction -> . FN LPAREN VAR RPAREN FNARROW arrowBody SEMICOLON
    (65) echo -> . ECHO values SEMICOLON
    (70) fgets -> . VAR EQUAL FGETS LPAREN STDIN RPAREN SEMICOLON
    (50) stackDeclaration -> . VAR EQUAL NEW STACK SEMICOLON
    (51) stackPush -> . VAR OBJOP PUSH LPAREN value RPAREN SEMICOLON
    (52) stackPop -> . VAR OBJOP POP SEMICOLON
    (88) line -> . variableAsignation SEMICOLON
    (66) print -> . PRINT LPAREN values RPAREN SEMICOLON
    (67) print -> . PRINT value SEMICOLON
    (103) logicalCondition -> . comparingValue
    (104) logicalCondition -> . comparingValue conditionOperator comparingValue
    (105) logicalCondition -> . LPAREN logicalCondition RPAREN
    (109) stringConcatenation -> . value CONCAT value
    (110) stringConcatenation -> . stringConcatenation CONCAT stringConcatenation
    (75) callFunction -> . ID LPAREN RPAREN SEMICOLON
    (76) callFunction -> . ID LPAREN value RPAREN SEMICOLON
    (77) value -> . VAR
    (78) value -> . INTEGER
    (79) value -> . FLOAT
    (80) value -> . STRING
    (81) value -> . stringConcatenation
    (89) variableAsignation -> . VAR EQUAL value
    (90) variableAsignation -> . VAR EQUAL arithmeticExpression
    (91) variableAsignation -> . VAR INCREMENT
    (92) variableAsignation -> . VAR DECREMENT
    (93) variableAsignation -> . VAR EQUAL stringConcatenation
    (94) variableAsignation -> . VAR EQUAL anonymousFunction
    (102) comparingValue -> . value comparingSign value

    OPEN_TAG        shift and go to state 22
    CLOSE_TAG       shift and go to state 23
    STRING          shift and go to state 27
    LPAREN          shift and go to state 28
    IF              shift and go to state 29
    FOR             shift and go to state 30
    SWITCH          shift and go to state 31
    VAR             shift and go to state 32
    FUNCTION        shift and go to state 33
    FN              shift and go to state 35
    ECHO            shift and go to state 36
    PRINT           shift and go to state 38
    ID              shift and go to state 34
    INTEGER         shift and go to state 40
    FLOAT           shift and go to state 41

    cuerpo                         shift and go to state 195
    arithmeticExpression           shift and go to state 3
    if_elseStatement               shift and go to state 4
    forStatement                   shift and go to state 5
    switchStatement                shift and go to state 6
    arrayAsignation                shift and go to state 7
    queueDeclaration               shift and go to state 8
    queueEnqueue                   shift and go to state 9
    queueDequeue                   shift and go to state 10
    defineFunction                 shift and go to state 11
    anonymousFunction              shift and go to state 12
    arrowFunction                  shift and go to state 13
    echo                           shift and go to state 14
    fgets                          shift and go to state 15
    stackDeclaration               shift and go to state 16
    stackPush                      shift and go to state 17
    stackPop                       shift and go to state 18
    line                           shift and go to state 19
    print                          shift and go to state 20
    logicalCondition               shift and go to state 21
    stringConcatenation            shift and go to state 24
    callFunction                   shift and go to state 25
    value                          shift and go to state 26
    variableAsignation             shift and go to state 37
    comparingValue                 shift and go to state 39

state 176

    (59) arguments -> VAR COMMA arguments .

    RPAREN          reduce using rule 59 (arguments -> VAR COMMA arguments .)


state 177

    (76) callFunction -> ID LPAREN value RPAREN SEMICOLON .

    OPEN_TAG        reduce using rule 76 (callFunction -> ID LPAREN value RPAREN SEMICOLON .)
    CLOSE_TAG       reduce using rule 76 (callFunction -> ID LPAREN value RPAREN SEMICOLON .)
    STRING          reduce using rule 76 (callFunction -> ID LPAREN value RPAREN SEMICOLON .)
    LPAREN          reduce using rule 76 (callFunction -> ID LPAREN value RPAREN SEMICOLON .)
    IF              reduce using rule 76 (callFunction -> ID LPAREN value RPAREN SEMICOLON .)
    FOR             reduce using rule 76 (callFunction -> ID LPAREN value RPAREN SEMICOLON .)
    SWITCH          reduce using rule 76 (callFunction -> ID LPAREN value RPAREN SEMICOLON .)
    VAR             reduce using rule 76 (callFunction -> ID LPAREN value RPAREN SEMICOLON .)
    FUNCTION        reduce using rule 76 (callFunction -> ID LPAREN value RPAREN SEMICOLON .)
    FN              reduce using rule 76 (callFunction -> ID LPAREN value RPAREN SEMICOLON .)
    ECHO            reduce using rule 76 (callFunction -> ID LPAREN value RPAREN SEMICOLON .)
    PRINT           reduce using rule 76 (callFunction -> ID LPAREN value RPAREN SEMICOLON .)
    ID              reduce using rule 76 (callFunction -> ID LPAREN value RPAREN SEMICOLON .)
    INTEGER         reduce using rule 76 (callFunction -> ID LPAREN value RPAREN SEMICOLON .)
    FLOAT           reduce using rule 76 (callFunction -> ID LPAREN value RPAREN SEMICOLON .)
    $end            reduce using rule 76 (callFunction -> ID LPAREN value RPAREN SEMICOLON .)
    RCURLY          reduce using rule 76 (callFunction -> ID LPAREN value RPAREN SEMICOLON .)
    CONTINUE        reduce using rule 76 (callFunction -> ID LPAREN value RPAREN SEMICOLON .)
    SEMICOLON       reduce using rule 76 (callFunction -> ID LPAREN value RPAREN SEMICOLON .)
    BREAK           reduce using rule 76 (callFunction -> ID LPAREN value RPAREN SEMICOLON .)


state 178

    (62) arrowFunction -> FN LPAREN VAR RPAREN FNARROW . arrowBody SEMICOLON
    (63) arrowBody -> . FN LPAREN VAR RPAREN FNARROW arrowBody
    (64) arrowBody -> . cuerpo
    (3) cuerpo -> . arithmeticExpression
    (4) cuerpo -> . if_elseStatement
    (5) cuerpo -> . forStatement
    (6) cuerpo -> . switchStatement
    (7) cuerpo -> . arrayAsignation
    (8) cuerpo -> . queueDeclaration
    (9) cuerpo -> . queueEnqueue
    (10) cuerpo -> . queueDequeue
    (11) cuerpo -> . defineFunction
    (12) cuerpo -> . anonymousFunction
    (13) cuerpo -> . arrowFunction
    (14) cuerpo -> . echo
    (15) cuerpo -> . fgets
    (16) cuerpo -> . stackDeclaration
    (17) cuerpo -> . stackPush
    (18) cuerpo -> . stackPop
    (19) cuerpo -> . line
    (20) cuerpo -> . print
    (21) cuerpo -> . logicalCondition
    (22) cuerpo -> . OPEN_TAG
    (23) cuerpo -> . CLOSE_TAG
    (24) cuerpo -> . stringConcatenation
    (25) cuerpo -> . callFunction
    (71) arithmeticExpression -> . value
    (72) arithmeticExpression -> . STRING
    (73) arithmeticExpression -> . LPAREN arithmeticExpression RPAREN
    (74) arithmeticExpression -> . arithmeticExpression arithmeticOperator arithmeticExpression
    (31) if_elseStatement -> . IF LPAREN logicalCondition RPAREN LCURLY ifStatementBody RCURLY ELSE LCURLY ifStatementBody RCURLY
    (32) if_elseStatement -> . IF LPAREN logicalCondition RPAREN LCURLY ifStatementBody
    (36) forStatement -> . FOR LPAREN forStatementCondition RPAREN LCURLY forStatementBody RCURLY
    (26) switchStatement -> . SWITCH LPAREN value RPAREN LCURLY switchCases switchDefault RCURLY
    (42) arrayAsignation -> . VAR EQUAL arrayDeclaration SEMICOLON
    (53) queueDeclaration -> . VAR EQUAL NEW QUEUE SEMICOLON
    (54) queueEnqueue -> . VAR OBJOP PUSH LPAREN value RPAREN SEMICOLON
    (55) queueDequeue -> . VAR OBJOP POP SEMICOLON
    (56) defineFunction -> . FUNCTION ID LPAREN arguments RPAREN LCURLY programa RCURLY
    (57) defineFunction -> . FUNCTION ID LPAREN RPAREN LCURLY programa RCURLY
    (60) anonymousFunction -> . FUNCTION LPAREN RPAREN LCURLY cuerpo RCURLY
    (61) anonymousFunction -> . FUNCTION LPAREN arguments RPAREN LCURLY cuerpo RCURLY
    (62) arrowFunction -> . FN LPAREN VAR RPAREN FNARROW arrowBody SEMICOLON
    (65) echo -> . ECHO values SEMICOLON
    (70) fgets -> . VAR EQUAL FGETS LPAREN STDIN RPAREN SEMICOLON
    (50) stackDeclaration -> . VAR EQUAL NEW STACK SEMICOLON
    (51) stackPush -> . VAR OBJOP PUSH LPAREN value RPAREN SEMICOLON
    (52) stackPop -> . VAR OBJOP POP SEMICOLON
    (88) line -> . variableAsignation SEMICOLON
    (66) print -> . PRINT LPAREN values RPAREN SEMICOLON
    (67) print -> . PRINT value SEMICOLON
    (103) logicalCondition -> . comparingValue
    (104) logicalCondition -> . comparingValue conditionOperator comparingValue
    (105) logicalCondition -> . LPAREN logicalCondition RPAREN
    (109) stringConcatenation -> . value CONCAT value
    (110) stringConcatenation -> . stringConcatenation CONCAT stringConcatenation
    (75) callFunction -> . ID LPAREN RPAREN SEMICOLON
    (76) callFunction -> . ID LPAREN value RPAREN SEMICOLON
    (77) value -> . VAR
    (78) value -> . INTEGER
    (79) value -> . FLOAT
    (80) value -> . STRING
    (81) value -> . stringConcatenation
    (89) variableAsignation -> . VAR EQUAL value
    (90) variableAsignation -> . VAR EQUAL arithmeticExpression
    (91) variableAsignation -> . VAR INCREMENT
    (92) variableAsignation -> . VAR DECREMENT
    (93) variableAsignation -> . VAR EQUAL stringConcatenation
    (94) variableAsignation -> . VAR EQUAL anonymousFunction
    (102) comparingValue -> . value comparingSign value

    FN              shift and go to state 196
    OPEN_TAG        shift and go to state 22
    CLOSE_TAG       shift and go to state 23
    STRING          shift and go to state 27
    LPAREN          shift and go to state 28
    IF              shift and go to state 29
    FOR             shift and go to state 30
    SWITCH          shift and go to state 31
    VAR             shift and go to state 32
    FUNCTION        shift and go to state 33
    ECHO            shift and go to state 36
    PRINT           shift and go to state 38
    ID              shift and go to state 34
    INTEGER         shift and go to state 40
    FLOAT           shift and go to state 41

    arrowBody                      shift and go to state 197
    cuerpo                         shift and go to state 198
    arithmeticExpression           shift and go to state 3
    if_elseStatement               shift and go to state 4
    forStatement                   shift and go to state 5
    switchStatement                shift and go to state 6
    arrayAsignation                shift and go to state 7
    queueDeclaration               shift and go to state 8
    queueEnqueue                   shift and go to state 9
    queueDequeue                   shift and go to state 10
    defineFunction                 shift and go to state 11
    anonymousFunction              shift and go to state 12
    arrowFunction                  shift and go to state 13
    echo                           shift and go to state 14
    fgets                          shift and go to state 15
    stackDeclaration               shift and go to state 16
    stackPush                      shift and go to state 17
    stackPop                       shift and go to state 18
    line                           shift and go to state 19
    print                          shift and go to state 20
    logicalCondition               shift and go to state 21
    stringConcatenation            shift and go to state 24
    callFunction                   shift and go to state 25
    value                          shift and go to state 26
    variableAsignation             shift and go to state 37
    comparingValue                 shift and go to state 39

state 179

    (66) print -> PRINT LPAREN values RPAREN SEMICOLON .

    OPEN_TAG        reduce using rule 66 (print -> PRINT LPAREN values RPAREN SEMICOLON .)
    CLOSE_TAG       reduce using rule 66 (print -> PRINT LPAREN values RPAREN SEMICOLON .)
    STRING          reduce using rule 66 (print -> PRINT LPAREN values RPAREN SEMICOLON .)
    LPAREN          reduce using rule 66 (print -> PRINT LPAREN values RPAREN SEMICOLON .)
    IF              reduce using rule 66 (print -> PRINT LPAREN values RPAREN SEMICOLON .)
    FOR             reduce using rule 66 (print -> PRINT LPAREN values RPAREN SEMICOLON .)
    SWITCH          reduce using rule 66 (print -> PRINT LPAREN values RPAREN SEMICOLON .)
    VAR             reduce using rule 66 (print -> PRINT LPAREN values RPAREN SEMICOLON .)
    FUNCTION        reduce using rule 66 (print -> PRINT LPAREN values RPAREN SEMICOLON .)
    FN              reduce using rule 66 (print -> PRINT LPAREN values RPAREN SEMICOLON .)
    ECHO            reduce using rule 66 (print -> PRINT LPAREN values RPAREN SEMICOLON .)
    PRINT           reduce using rule 66 (print -> PRINT LPAREN values RPAREN SEMICOLON .)
    ID              reduce using rule 66 (print -> PRINT LPAREN values RPAREN SEMICOLON .)
    INTEGER         reduce using rule 66 (print -> PRINT LPAREN values RPAREN SEMICOLON .)
    FLOAT           reduce using rule 66 (print -> PRINT LPAREN values RPAREN SEMICOLON .)
    $end            reduce using rule 66 (print -> PRINT LPAREN values RPAREN SEMICOLON .)
    RCURLY          reduce using rule 66 (print -> PRINT LPAREN values RPAREN SEMICOLON .)
    CONTINUE        reduce using rule 66 (print -> PRINT LPAREN values RPAREN SEMICOLON .)
    SEMICOLON       reduce using rule 66 (print -> PRINT LPAREN values RPAREN SEMICOLON .)
    BREAK           reduce using rule 66 (print -> PRINT LPAREN values RPAREN SEMICOLON .)


state 180

    (31) if_elseStatement -> IF LPAREN logicalCondition RPAREN LCURLY ifStatementBody . RCURLY ELSE LCURLY ifStatementBody RCURLY
    (32) if_elseStatement -> IF LPAREN logicalCondition RPAREN LCURLY ifStatementBody .
    (35) ifStatementBody -> ifStatementBody . cuerpo
    (3) cuerpo -> . arithmeticExpression
    (4) cuerpo -> . if_elseStatement
    (5) cuerpo -> . forStatement
    (6) cuerpo -> . switchStatement
    (7) cuerpo -> . arrayAsignation
    (8) cuerpo -> . queueDeclaration
    (9) cuerpo -> . queueEnqueue
    (10) cuerpo -> . queueDequeue
    (11) cuerpo -> . defineFunction
    (12) cuerpo -> . anonymousFunction
    (13) cuerpo -> . arrowFunction
    (14) cuerpo -> . echo
    (15) cuerpo -> . fgets
    (16) cuerpo -> . stackDeclaration
    (17) cuerpo -> . stackPush
    (18) cuerpo -> . stackPop
    (19) cuerpo -> . line
    (20) cuerpo -> . print
    (21) cuerpo -> . logicalCondition
    (22) cuerpo -> . OPEN_TAG
    (23) cuerpo -> . CLOSE_TAG
    (24) cuerpo -> . stringConcatenation
    (25) cuerpo -> . callFunction
    (71) arithmeticExpression -> . value
    (72) arithmeticExpression -> . STRING
    (73) arithmeticExpression -> . LPAREN arithmeticExpression RPAREN
    (74) arithmeticExpression -> . arithmeticExpression arithmeticOperator arithmeticExpression
    (31) if_elseStatement -> . IF LPAREN logicalCondition RPAREN LCURLY ifStatementBody RCURLY ELSE LCURLY ifStatementBody RCURLY
    (32) if_elseStatement -> . IF LPAREN logicalCondition RPAREN LCURLY ifStatementBody
    (36) forStatement -> . FOR LPAREN forStatementCondition RPAREN LCURLY forStatementBody RCURLY
    (26) switchStatement -> . SWITCH LPAREN value RPAREN LCURLY switchCases switchDefault RCURLY
    (42) arrayAsignation -> . VAR EQUAL arrayDeclaration SEMICOLON
    (53) queueDeclaration -> . VAR EQUAL NEW QUEUE SEMICOLON
    (54) queueEnqueue -> . VAR OBJOP PUSH LPAREN value RPAREN SEMICOLON
    (55) queueDequeue -> . VAR OBJOP POP SEMICOLON
    (56) defineFunction -> . FUNCTION ID LPAREN arguments RPAREN LCURLY programa RCURLY
    (57) defineFunction -> . FUNCTION ID LPAREN RPAREN LCURLY programa RCURLY
    (60) anonymousFunction -> . FUNCTION LPAREN RPAREN LCURLY cuerpo RCURLY
    (61) anonymousFunction -> . FUNCTION LPAREN arguments RPAREN LCURLY cuerpo RCURLY
    (62) arrowFunction -> . FN LPAREN VAR RPAREN FNARROW arrowBody SEMICOLON
    (65) echo -> . ECHO values SEMICOLON
    (70) fgets -> . VAR EQUAL FGETS LPAREN STDIN RPAREN SEMICOLON
    (50) stackDeclaration -> . VAR EQUAL NEW STACK SEMICOLON
    (51) stackPush -> . VAR OBJOP PUSH LPAREN value RPAREN SEMICOLON
    (52) stackPop -> . VAR OBJOP POP SEMICOLON
    (88) line -> . variableAsignation SEMICOLON
    (66) print -> . PRINT LPAREN values RPAREN SEMICOLON
    (67) print -> . PRINT value SEMICOLON
    (103) logicalCondition -> . comparingValue
    (104) logicalCondition -> . comparingValue conditionOperator comparingValue
    (105) logicalCondition -> . LPAREN logicalCondition RPAREN
    (109) stringConcatenation -> . value CONCAT value
    (110) stringConcatenation -> . stringConcatenation CONCAT stringConcatenation
    (75) callFunction -> . ID LPAREN RPAREN SEMICOLON
    (76) callFunction -> . ID LPAREN value RPAREN SEMICOLON
    (77) value -> . VAR
    (78) value -> . INTEGER
    (79) value -> . FLOAT
    (80) value -> . STRING
    (81) value -> . stringConcatenation
    (89) variableAsignation -> . VAR EQUAL value
    (90) variableAsignation -> . VAR EQUAL arithmeticExpression
    (91) variableAsignation -> . VAR INCREMENT
    (92) variableAsignation -> . VAR DECREMENT
    (93) variableAsignation -> . VAR EQUAL stringConcatenation
    (94) variableAsignation -> . VAR EQUAL anonymousFunction
    (102) comparingValue -> . value comparingSign value

  ! shift/reduce conflict for RCURLY resolved as shift
  ! shift/reduce conflict for OPEN_TAG resolved as shift
  ! shift/reduce conflict for CLOSE_TAG resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for SWITCH resolved as shift
  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for FUNCTION resolved as shift
  ! shift/reduce conflict for FN resolved as shift
  ! shift/reduce conflict for ECHO resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
    RCURLY          shift and go to state 199
    $end            reduce using rule 32 (if_elseStatement -> IF LPAREN logicalCondition RPAREN LCURLY ifStatementBody .)
    CONTINUE        reduce using rule 32 (if_elseStatement -> IF LPAREN logicalCondition RPAREN LCURLY ifStatementBody .)
    SEMICOLON       reduce using rule 32 (if_elseStatement -> IF LPAREN logicalCondition RPAREN LCURLY ifStatementBody .)
    BREAK           reduce using rule 32 (if_elseStatement -> IF LPAREN logicalCondition RPAREN LCURLY ifStatementBody .)
    OPEN_TAG        shift and go to state 22
    CLOSE_TAG       shift and go to state 23
    STRING          shift and go to state 27
    LPAREN          shift and go to state 28
    IF              shift and go to state 29
    FOR             shift and go to state 30
    SWITCH          shift and go to state 31
    VAR             shift and go to state 32
    FUNCTION        shift and go to state 33
    FN              shift and go to state 35
    ECHO            shift and go to state 36
    PRINT           shift and go to state 38
    ID              shift and go to state 34
    INTEGER         shift and go to state 40
    FLOAT           shift and go to state 41

  ! OPEN_TAG        [ reduce using rule 32 (if_elseStatement -> IF LPAREN logicalCondition RPAREN LCURLY ifStatementBody .) ]
  ! CLOSE_TAG       [ reduce using rule 32 (if_elseStatement -> IF LPAREN logicalCondition RPAREN LCURLY ifStatementBody .) ]
  ! STRING          [ reduce using rule 32 (if_elseStatement -> IF LPAREN logicalCondition RPAREN LCURLY ifStatementBody .) ]
  ! LPAREN          [ reduce using rule 32 (if_elseStatement -> IF LPAREN logicalCondition RPAREN LCURLY ifStatementBody .) ]
  ! IF              [ reduce using rule 32 (if_elseStatement -> IF LPAREN logicalCondition RPAREN LCURLY ifStatementBody .) ]
  ! FOR             [ reduce using rule 32 (if_elseStatement -> IF LPAREN logicalCondition RPAREN LCURLY ifStatementBody .) ]
  ! SWITCH          [ reduce using rule 32 (if_elseStatement -> IF LPAREN logicalCondition RPAREN LCURLY ifStatementBody .) ]
  ! VAR             [ reduce using rule 32 (if_elseStatement -> IF LPAREN logicalCondition RPAREN LCURLY ifStatementBody .) ]
  ! FUNCTION        [ reduce using rule 32 (if_elseStatement -> IF LPAREN logicalCondition RPAREN LCURLY ifStatementBody .) ]
  ! FN              [ reduce using rule 32 (if_elseStatement -> IF LPAREN logicalCondition RPAREN LCURLY ifStatementBody .) ]
  ! ECHO            [ reduce using rule 32 (if_elseStatement -> IF LPAREN logicalCondition RPAREN LCURLY ifStatementBody .) ]
  ! PRINT           [ reduce using rule 32 (if_elseStatement -> IF LPAREN logicalCondition RPAREN LCURLY ifStatementBody .) ]
  ! ID              [ reduce using rule 32 (if_elseStatement -> IF LPAREN logicalCondition RPAREN LCURLY ifStatementBody .) ]
  ! INTEGER         [ reduce using rule 32 (if_elseStatement -> IF LPAREN logicalCondition RPAREN LCURLY ifStatementBody .) ]
  ! FLOAT           [ reduce using rule 32 (if_elseStatement -> IF LPAREN logicalCondition RPAREN LCURLY ifStatementBody .) ]
  ! RCURLY          [ reduce using rule 32 (if_elseStatement -> IF LPAREN logicalCondition RPAREN LCURLY ifStatementBody .) ]

    logicalCondition               shift and go to state 21
    cuerpo                         shift and go to state 200
    arithmeticExpression           shift and go to state 3
    if_elseStatement               shift and go to state 4
    forStatement                   shift and go to state 5
    switchStatement                shift and go to state 6
    arrayAsignation                shift and go to state 7
    queueDeclaration               shift and go to state 8
    queueEnqueue                   shift and go to state 9
    queueDequeue                   shift and go to state 10
    defineFunction                 shift and go to state 11
    anonymousFunction              shift and go to state 12
    arrowFunction                  shift and go to state 13
    echo                           shift and go to state 14
    fgets                          shift and go to state 15
    stackDeclaration               shift and go to state 16
    stackPush                      shift and go to state 17
    stackPop                       shift and go to state 18
    line                           shift and go to state 19
    print                          shift and go to state 20
    stringConcatenation            shift and go to state 24
    callFunction                   shift and go to state 25
    value                          shift and go to state 26
    variableAsignation             shift and go to state 37
    comparingValue                 shift and go to state 39

state 181

    (33) ifStatementBody -> cuerpo .
    (34) ifStatementBody -> cuerpo . CONTINUE SEMICOLON

  ! shift/reduce conflict for CONTINUE resolved as shift
    RCURLY          reduce using rule 33 (ifStatementBody -> cuerpo .)
    OPEN_TAG        reduce using rule 33 (ifStatementBody -> cuerpo .)
    CLOSE_TAG       reduce using rule 33 (ifStatementBody -> cuerpo .)
    STRING          reduce using rule 33 (ifStatementBody -> cuerpo .)
    LPAREN          reduce using rule 33 (ifStatementBody -> cuerpo .)
    IF              reduce using rule 33 (ifStatementBody -> cuerpo .)
    FOR             reduce using rule 33 (ifStatementBody -> cuerpo .)
    SWITCH          reduce using rule 33 (ifStatementBody -> cuerpo .)
    VAR             reduce using rule 33 (ifStatementBody -> cuerpo .)
    FUNCTION        reduce using rule 33 (ifStatementBody -> cuerpo .)
    FN              reduce using rule 33 (ifStatementBody -> cuerpo .)
    ECHO            reduce using rule 33 (ifStatementBody -> cuerpo .)
    PRINT           reduce using rule 33 (ifStatementBody -> cuerpo .)
    ID              reduce using rule 33 (ifStatementBody -> cuerpo .)
    INTEGER         reduce using rule 33 (ifStatementBody -> cuerpo .)
    FLOAT           reduce using rule 33 (ifStatementBody -> cuerpo .)
    $end            reduce using rule 33 (ifStatementBody -> cuerpo .)
    SEMICOLON       reduce using rule 33 (ifStatementBody -> cuerpo .)
    BREAK           reduce using rule 33 (ifStatementBody -> cuerpo .)
    CONTINUE        shift and go to state 201

  ! CONTINUE        [ reduce using rule 33 (ifStatementBody -> cuerpo .) ]


state 182

    (36) forStatement -> FOR LPAREN forStatementCondition RPAREN LCURLY forStatementBody . RCURLY
    (41) forStatementBody -> forStatementBody . cuerpo
    (3) cuerpo -> . arithmeticExpression
    (4) cuerpo -> . if_elseStatement
    (5) cuerpo -> . forStatement
    (6) cuerpo -> . switchStatement
    (7) cuerpo -> . arrayAsignation
    (8) cuerpo -> . queueDeclaration
    (9) cuerpo -> . queueEnqueue
    (10) cuerpo -> . queueDequeue
    (11) cuerpo -> . defineFunction
    (12) cuerpo -> . anonymousFunction
    (13) cuerpo -> . arrowFunction
    (14) cuerpo -> . echo
    (15) cuerpo -> . fgets
    (16) cuerpo -> . stackDeclaration
    (17) cuerpo -> . stackPush
    (18) cuerpo -> . stackPop
    (19) cuerpo -> . line
    (20) cuerpo -> . print
    (21) cuerpo -> . logicalCondition
    (22) cuerpo -> . OPEN_TAG
    (23) cuerpo -> . CLOSE_TAG
    (24) cuerpo -> . stringConcatenation
    (25) cuerpo -> . callFunction
    (71) arithmeticExpression -> . value
    (72) arithmeticExpression -> . STRING
    (73) arithmeticExpression -> . LPAREN arithmeticExpression RPAREN
    (74) arithmeticExpression -> . arithmeticExpression arithmeticOperator arithmeticExpression
    (31) if_elseStatement -> . IF LPAREN logicalCondition RPAREN LCURLY ifStatementBody RCURLY ELSE LCURLY ifStatementBody RCURLY
    (32) if_elseStatement -> . IF LPAREN logicalCondition RPAREN LCURLY ifStatementBody
    (36) forStatement -> . FOR LPAREN forStatementCondition RPAREN LCURLY forStatementBody RCURLY
    (26) switchStatement -> . SWITCH LPAREN value RPAREN LCURLY switchCases switchDefault RCURLY
    (42) arrayAsignation -> . VAR EQUAL arrayDeclaration SEMICOLON
    (53) queueDeclaration -> . VAR EQUAL NEW QUEUE SEMICOLON
    (54) queueEnqueue -> . VAR OBJOP PUSH LPAREN value RPAREN SEMICOLON
    (55) queueDequeue -> . VAR OBJOP POP SEMICOLON
    (56) defineFunction -> . FUNCTION ID LPAREN arguments RPAREN LCURLY programa RCURLY
    (57) defineFunction -> . FUNCTION ID LPAREN RPAREN LCURLY programa RCURLY
    (60) anonymousFunction -> . FUNCTION LPAREN RPAREN LCURLY cuerpo RCURLY
    (61) anonymousFunction -> . FUNCTION LPAREN arguments RPAREN LCURLY cuerpo RCURLY
    (62) arrowFunction -> . FN LPAREN VAR RPAREN FNARROW arrowBody SEMICOLON
    (65) echo -> . ECHO values SEMICOLON
    (70) fgets -> . VAR EQUAL FGETS LPAREN STDIN RPAREN SEMICOLON
    (50) stackDeclaration -> . VAR EQUAL NEW STACK SEMICOLON
    (51) stackPush -> . VAR OBJOP PUSH LPAREN value RPAREN SEMICOLON
    (52) stackPop -> . VAR OBJOP POP SEMICOLON
    (88) line -> . variableAsignation SEMICOLON
    (66) print -> . PRINT LPAREN values RPAREN SEMICOLON
    (67) print -> . PRINT value SEMICOLON
    (103) logicalCondition -> . comparingValue
    (104) logicalCondition -> . comparingValue conditionOperator comparingValue
    (105) logicalCondition -> . LPAREN logicalCondition RPAREN
    (109) stringConcatenation -> . value CONCAT value
    (110) stringConcatenation -> . stringConcatenation CONCAT stringConcatenation
    (75) callFunction -> . ID LPAREN RPAREN SEMICOLON
    (76) callFunction -> . ID LPAREN value RPAREN SEMICOLON
    (77) value -> . VAR
    (78) value -> . INTEGER
    (79) value -> . FLOAT
    (80) value -> . STRING
    (81) value -> . stringConcatenation
    (89) variableAsignation -> . VAR EQUAL value
    (90) variableAsignation -> . VAR EQUAL arithmeticExpression
    (91) variableAsignation -> . VAR INCREMENT
    (92) variableAsignation -> . VAR DECREMENT
    (93) variableAsignation -> . VAR EQUAL stringConcatenation
    (94) variableAsignation -> . VAR EQUAL anonymousFunction
    (102) comparingValue -> . value comparingSign value

    RCURLY          shift and go to state 202
    OPEN_TAG        shift and go to state 22
    CLOSE_TAG       shift and go to state 23
    STRING          shift and go to state 27
    LPAREN          shift and go to state 28
    IF              shift and go to state 29
    FOR             shift and go to state 30
    SWITCH          shift and go to state 31
    VAR             shift and go to state 32
    FUNCTION        shift and go to state 33
    FN              shift and go to state 35
    ECHO            shift and go to state 36
    PRINT           shift and go to state 38
    ID              shift and go to state 34
    INTEGER         shift and go to state 40
    FLOAT           shift and go to state 41

    cuerpo                         shift and go to state 203
    arithmeticExpression           shift and go to state 3
    if_elseStatement               shift and go to state 4
    forStatement                   shift and go to state 5
    switchStatement                shift and go to state 6
    arrayAsignation                shift and go to state 7
    queueDeclaration               shift and go to state 8
    queueEnqueue                   shift and go to state 9
    queueDequeue                   shift and go to state 10
    defineFunction                 shift and go to state 11
    anonymousFunction              shift and go to state 12
    arrowFunction                  shift and go to state 13
    echo                           shift and go to state 14
    fgets                          shift and go to state 15
    stackDeclaration               shift and go to state 16
    stackPush                      shift and go to state 17
    stackPop                       shift and go to state 18
    line                           shift and go to state 19
    print                          shift and go to state 20
    logicalCondition               shift and go to state 21
    stringConcatenation            shift and go to state 24
    callFunction                   shift and go to state 25
    value                          shift and go to state 26
    variableAsignation             shift and go to state 37
    comparingValue                 shift and go to state 39

state 183

    (40) forStatementBody -> cuerpo .

    RCURLY          reduce using rule 40 (forStatementBody -> cuerpo .)
    OPEN_TAG        reduce using rule 40 (forStatementBody -> cuerpo .)
    CLOSE_TAG       reduce using rule 40 (forStatementBody -> cuerpo .)
    STRING          reduce using rule 40 (forStatementBody -> cuerpo .)
    LPAREN          reduce using rule 40 (forStatementBody -> cuerpo .)
    IF              reduce using rule 40 (forStatementBody -> cuerpo .)
    FOR             reduce using rule 40 (forStatementBody -> cuerpo .)
    SWITCH          reduce using rule 40 (forStatementBody -> cuerpo .)
    VAR             reduce using rule 40 (forStatementBody -> cuerpo .)
    FUNCTION        reduce using rule 40 (forStatementBody -> cuerpo .)
    FN              reduce using rule 40 (forStatementBody -> cuerpo .)
    ECHO            reduce using rule 40 (forStatementBody -> cuerpo .)
    PRINT           reduce using rule 40 (forStatementBody -> cuerpo .)
    ID              reduce using rule 40 (forStatementBody -> cuerpo .)
    INTEGER         reduce using rule 40 (forStatementBody -> cuerpo .)
    FLOAT           reduce using rule 40 (forStatementBody -> cuerpo .)


state 184

    (38) forStatementCondition -> variableAsignation SEMICOLON SEMICOLON variableAsignation .

    RPAREN          reduce using rule 38 (forStatementCondition -> variableAsignation SEMICOLON SEMICOLON variableAsignation .)


state 185

    (39) forStatementCondition -> variableAsignation SEMICOLON comparingValue SEMICOLON . variableAsignation
    (89) variableAsignation -> . VAR EQUAL value
    (90) variableAsignation -> . VAR EQUAL arithmeticExpression
    (91) variableAsignation -> . VAR INCREMENT
    (92) variableAsignation -> . VAR DECREMENT
    (93) variableAsignation -> . VAR EQUAL stringConcatenation
    (94) variableAsignation -> . VAR EQUAL anonymousFunction

    VAR             shift and go to state 101

    variableAsignation             shift and go to state 204

state 186

    (26) switchStatement -> SWITCH LPAREN value RPAREN LCURLY switchCases . switchDefault RCURLY
    (30) switchCases -> switchCases . switchCase
    (27) switchDefault -> . DEFAULT COLON programa
    (28) switchCase -> . CASE value COLON programa BREAK SEMICOLON

    DEFAULT         shift and go to state 207
    CASE            shift and go to state 188

    switchDefault                  shift and go to state 205
    switchCase                     shift and go to state 206

state 187

    (29) switchCases -> switchCase .

    DEFAULT         reduce using rule 29 (switchCases -> switchCase .)
    CASE            reduce using rule 29 (switchCases -> switchCase .)


state 188

    (28) switchCase -> CASE . value COLON programa BREAK SEMICOLON
    (77) value -> . VAR
    (78) value -> . INTEGER
    (79) value -> . FLOAT
    (80) value -> . STRING
    (81) value -> . stringConcatenation
    (109) stringConcatenation -> . value CONCAT value
    (110) stringConcatenation -> . stringConcatenation CONCAT stringConcatenation

    VAR             shift and go to state 63
    INTEGER         shift and go to state 40
    FLOAT           shift and go to state 41
    STRING          shift and go to state 78

    value                          shift and go to state 208
    stringConcatenation            shift and go to state 64

state 189

    (70) fgets -> VAR EQUAL FGETS LPAREN STDIN RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 209


state 190

    (47) arraysValues -> arraysValues COMMA arrayValue .

    RPAREN          reduce using rule 47 (arraysValues -> arraysValues COMMA arrayValue .)
    COMMA           reduce using rule 47 (arraysValues -> arraysValues COMMA arrayValue .)
    RSQUARE         reduce using rule 47 (arraysValues -> arraysValues COMMA arrayValue .)


state 191

    (54) queueEnqueue -> VAR OBJOP PUSH LPAREN value RPAREN . SEMICOLON
    (51) stackPush -> VAR OBJOP PUSH LPAREN value RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 210


state 192

    (56) defineFunction -> FUNCTION ID LPAREN arguments RPAREN LCURLY . programa RCURLY
    (1) programa -> . cuerpo
    (2) programa -> . programa cuerpo
    (3) cuerpo -> . arithmeticExpression
    (4) cuerpo -> . if_elseStatement
    (5) cuerpo -> . forStatement
    (6) cuerpo -> . switchStatement
    (7) cuerpo -> . arrayAsignation
    (8) cuerpo -> . queueDeclaration
    (9) cuerpo -> . queueEnqueue
    (10) cuerpo -> . queueDequeue
    (11) cuerpo -> . defineFunction
    (12) cuerpo -> . anonymousFunction
    (13) cuerpo -> . arrowFunction
    (14) cuerpo -> . echo
    (15) cuerpo -> . fgets
    (16) cuerpo -> . stackDeclaration
    (17) cuerpo -> . stackPush
    (18) cuerpo -> . stackPop
    (19) cuerpo -> . line
    (20) cuerpo -> . print
    (21) cuerpo -> . logicalCondition
    (22) cuerpo -> . OPEN_TAG
    (23) cuerpo -> . CLOSE_TAG
    (24) cuerpo -> . stringConcatenation
    (25) cuerpo -> . callFunction
    (71) arithmeticExpression -> . value
    (72) arithmeticExpression -> . STRING
    (73) arithmeticExpression -> . LPAREN arithmeticExpression RPAREN
    (74) arithmeticExpression -> . arithmeticExpression arithmeticOperator arithmeticExpression
    (31) if_elseStatement -> . IF LPAREN logicalCondition RPAREN LCURLY ifStatementBody RCURLY ELSE LCURLY ifStatementBody RCURLY
    (32) if_elseStatement -> . IF LPAREN logicalCondition RPAREN LCURLY ifStatementBody
    (36) forStatement -> . FOR LPAREN forStatementCondition RPAREN LCURLY forStatementBody RCURLY
    (26) switchStatement -> . SWITCH LPAREN value RPAREN LCURLY switchCases switchDefault RCURLY
    (42) arrayAsignation -> . VAR EQUAL arrayDeclaration SEMICOLON
    (53) queueDeclaration -> . VAR EQUAL NEW QUEUE SEMICOLON
    (54) queueEnqueue -> . VAR OBJOP PUSH LPAREN value RPAREN SEMICOLON
    (55) queueDequeue -> . VAR OBJOP POP SEMICOLON
    (56) defineFunction -> . FUNCTION ID LPAREN arguments RPAREN LCURLY programa RCURLY
    (57) defineFunction -> . FUNCTION ID LPAREN RPAREN LCURLY programa RCURLY
    (60) anonymousFunction -> . FUNCTION LPAREN RPAREN LCURLY cuerpo RCURLY
    (61) anonymousFunction -> . FUNCTION LPAREN arguments RPAREN LCURLY cuerpo RCURLY
    (62) arrowFunction -> . FN LPAREN VAR RPAREN FNARROW arrowBody SEMICOLON
    (65) echo -> . ECHO values SEMICOLON
    (70) fgets -> . VAR EQUAL FGETS LPAREN STDIN RPAREN SEMICOLON
    (50) stackDeclaration -> . VAR EQUAL NEW STACK SEMICOLON
    (51) stackPush -> . VAR OBJOP PUSH LPAREN value RPAREN SEMICOLON
    (52) stackPop -> . VAR OBJOP POP SEMICOLON
    (88) line -> . variableAsignation SEMICOLON
    (66) print -> . PRINT LPAREN values RPAREN SEMICOLON
    (67) print -> . PRINT value SEMICOLON
    (103) logicalCondition -> . comparingValue
    (104) logicalCondition -> . comparingValue conditionOperator comparingValue
    (105) logicalCondition -> . LPAREN logicalCondition RPAREN
    (109) stringConcatenation -> . value CONCAT value
    (110) stringConcatenation -> . stringConcatenation CONCAT stringConcatenation
    (75) callFunction -> . ID LPAREN RPAREN SEMICOLON
    (76) callFunction -> . ID LPAREN value RPAREN SEMICOLON
    (77) value -> . VAR
    (78) value -> . INTEGER
    (79) value -> . FLOAT
    (80) value -> . STRING
    (81) value -> . stringConcatenation
    (89) variableAsignation -> . VAR EQUAL value
    (90) variableAsignation -> . VAR EQUAL arithmeticExpression
    (91) variableAsignation -> . VAR INCREMENT
    (92) variableAsignation -> . VAR DECREMENT
    (93) variableAsignation -> . VAR EQUAL stringConcatenation
    (94) variableAsignation -> . VAR EQUAL anonymousFunction
    (102) comparingValue -> . value comparingSign value

    OPEN_TAG        shift and go to state 22
    CLOSE_TAG       shift and go to state 23
    STRING          shift and go to state 27
    LPAREN          shift and go to state 28
    IF              shift and go to state 29
    FOR             shift and go to state 30
    SWITCH          shift and go to state 31
    VAR             shift and go to state 32
    FUNCTION        shift and go to state 33
    FN              shift and go to state 35
    ECHO            shift and go to state 36
    PRINT           shift and go to state 38
    ID              shift and go to state 34
    INTEGER         shift and go to state 40
    FLOAT           shift and go to state 41

    programa                       shift and go to state 211
    cuerpo                         shift and go to state 2
    arithmeticExpression           shift and go to state 3
    if_elseStatement               shift and go to state 4
    forStatement                   shift and go to state 5
    switchStatement                shift and go to state 6
    arrayAsignation                shift and go to state 7
    queueDeclaration               shift and go to state 8
    queueEnqueue                   shift and go to state 9
    queueDequeue                   shift and go to state 10
    defineFunction                 shift and go to state 11
    anonymousFunction              shift and go to state 12
    arrowFunction                  shift and go to state 13
    echo                           shift and go to state 14
    fgets                          shift and go to state 15
    stackDeclaration               shift and go to state 16
    stackPush                      shift and go to state 17
    stackPop                       shift and go to state 18
    line                           shift and go to state 19
    print                          shift and go to state 20
    logicalCondition               shift and go to state 21
    stringConcatenation            shift and go to state 24
    callFunction                   shift and go to state 25
    value                          shift and go to state 26
    variableAsignation             shift and go to state 37
    comparingValue                 shift and go to state 39

state 193

    (57) defineFunction -> FUNCTION ID LPAREN RPAREN LCURLY programa . RCURLY
    (2) programa -> programa . cuerpo
    (3) cuerpo -> . arithmeticExpression
    (4) cuerpo -> . if_elseStatement
    (5) cuerpo -> . forStatement
    (6) cuerpo -> . switchStatement
    (7) cuerpo -> . arrayAsignation
    (8) cuerpo -> . queueDeclaration
    (9) cuerpo -> . queueEnqueue
    (10) cuerpo -> . queueDequeue
    (11) cuerpo -> . defineFunction
    (12) cuerpo -> . anonymousFunction
    (13) cuerpo -> . arrowFunction
    (14) cuerpo -> . echo
    (15) cuerpo -> . fgets
    (16) cuerpo -> . stackDeclaration
    (17) cuerpo -> . stackPush
    (18) cuerpo -> . stackPop
    (19) cuerpo -> . line
    (20) cuerpo -> . print
    (21) cuerpo -> . logicalCondition
    (22) cuerpo -> . OPEN_TAG
    (23) cuerpo -> . CLOSE_TAG
    (24) cuerpo -> . stringConcatenation
    (25) cuerpo -> . callFunction
    (71) arithmeticExpression -> . value
    (72) arithmeticExpression -> . STRING
    (73) arithmeticExpression -> . LPAREN arithmeticExpression RPAREN
    (74) arithmeticExpression -> . arithmeticExpression arithmeticOperator arithmeticExpression
    (31) if_elseStatement -> . IF LPAREN logicalCondition RPAREN LCURLY ifStatementBody RCURLY ELSE LCURLY ifStatementBody RCURLY
    (32) if_elseStatement -> . IF LPAREN logicalCondition RPAREN LCURLY ifStatementBody
    (36) forStatement -> . FOR LPAREN forStatementCondition RPAREN LCURLY forStatementBody RCURLY
    (26) switchStatement -> . SWITCH LPAREN value RPAREN LCURLY switchCases switchDefault RCURLY
    (42) arrayAsignation -> . VAR EQUAL arrayDeclaration SEMICOLON
    (53) queueDeclaration -> . VAR EQUAL NEW QUEUE SEMICOLON
    (54) queueEnqueue -> . VAR OBJOP PUSH LPAREN value RPAREN SEMICOLON
    (55) queueDequeue -> . VAR OBJOP POP SEMICOLON
    (56) defineFunction -> . FUNCTION ID LPAREN arguments RPAREN LCURLY programa RCURLY
    (57) defineFunction -> . FUNCTION ID LPAREN RPAREN LCURLY programa RCURLY
    (60) anonymousFunction -> . FUNCTION LPAREN RPAREN LCURLY cuerpo RCURLY
    (61) anonymousFunction -> . FUNCTION LPAREN arguments RPAREN LCURLY cuerpo RCURLY
    (62) arrowFunction -> . FN LPAREN VAR RPAREN FNARROW arrowBody SEMICOLON
    (65) echo -> . ECHO values SEMICOLON
    (70) fgets -> . VAR EQUAL FGETS LPAREN STDIN RPAREN SEMICOLON
    (50) stackDeclaration -> . VAR EQUAL NEW STACK SEMICOLON
    (51) stackPush -> . VAR OBJOP PUSH LPAREN value RPAREN SEMICOLON
    (52) stackPop -> . VAR OBJOP POP SEMICOLON
    (88) line -> . variableAsignation SEMICOLON
    (66) print -> . PRINT LPAREN values RPAREN SEMICOLON
    (67) print -> . PRINT value SEMICOLON
    (103) logicalCondition -> . comparingValue
    (104) logicalCondition -> . comparingValue conditionOperator comparingValue
    (105) logicalCondition -> . LPAREN logicalCondition RPAREN
    (109) stringConcatenation -> . value CONCAT value
    (110) stringConcatenation -> . stringConcatenation CONCAT stringConcatenation
    (75) callFunction -> . ID LPAREN RPAREN SEMICOLON
    (76) callFunction -> . ID LPAREN value RPAREN SEMICOLON
    (77) value -> . VAR
    (78) value -> . INTEGER
    (79) value -> . FLOAT
    (80) value -> . STRING
    (81) value -> . stringConcatenation
    (89) variableAsignation -> . VAR EQUAL value
    (90) variableAsignation -> . VAR EQUAL arithmeticExpression
    (91) variableAsignation -> . VAR INCREMENT
    (92) variableAsignation -> . VAR DECREMENT
    (93) variableAsignation -> . VAR EQUAL stringConcatenation
    (94) variableAsignation -> . VAR EQUAL anonymousFunction
    (102) comparingValue -> . value comparingSign value

    RCURLY          shift and go to state 212
    OPEN_TAG        shift and go to state 22
    CLOSE_TAG       shift and go to state 23
    STRING          shift and go to state 27
    LPAREN          shift and go to state 28
    IF              shift and go to state 29
    FOR             shift and go to state 30
    SWITCH          shift and go to state 31
    VAR             shift and go to state 32
    FUNCTION        shift and go to state 33
    FN              shift and go to state 35
    ECHO            shift and go to state 36
    PRINT           shift and go to state 38
    ID              shift and go to state 34
    INTEGER         shift and go to state 40
    FLOAT           shift and go to state 41

    cuerpo                         shift and go to state 42
    arithmeticExpression           shift and go to state 3
    if_elseStatement               shift and go to state 4
    forStatement                   shift and go to state 5
    switchStatement                shift and go to state 6
    arrayAsignation                shift and go to state 7
    queueDeclaration               shift and go to state 8
    queueEnqueue                   shift and go to state 9
    queueDequeue                   shift and go to state 10
    defineFunction                 shift and go to state 11
    anonymousFunction              shift and go to state 12
    arrowFunction                  shift and go to state 13
    echo                           shift and go to state 14
    fgets                          shift and go to state 15
    stackDeclaration               shift and go to state 16
    stackPush                      shift and go to state 17
    stackPop                       shift and go to state 18
    line                           shift and go to state 19
    print                          shift and go to state 20
    logicalCondition               shift and go to state 21
    stringConcatenation            shift and go to state 24
    callFunction                   shift and go to state 25
    value                          shift and go to state 26
    variableAsignation             shift and go to state 37
    comparingValue                 shift and go to state 39

state 194

    (60) anonymousFunction -> FUNCTION LPAREN RPAREN LCURLY cuerpo RCURLY .

    OPEN_TAG        reduce using rule 60 (anonymousFunction -> FUNCTION LPAREN RPAREN LCURLY cuerpo RCURLY .)
    CLOSE_TAG       reduce using rule 60 (anonymousFunction -> FUNCTION LPAREN RPAREN LCURLY cuerpo RCURLY .)
    STRING          reduce using rule 60 (anonymousFunction -> FUNCTION LPAREN RPAREN LCURLY cuerpo RCURLY .)
    LPAREN          reduce using rule 60 (anonymousFunction -> FUNCTION LPAREN RPAREN LCURLY cuerpo RCURLY .)
    IF              reduce using rule 60 (anonymousFunction -> FUNCTION LPAREN RPAREN LCURLY cuerpo RCURLY .)
    FOR             reduce using rule 60 (anonymousFunction -> FUNCTION LPAREN RPAREN LCURLY cuerpo RCURLY .)
    SWITCH          reduce using rule 60 (anonymousFunction -> FUNCTION LPAREN RPAREN LCURLY cuerpo RCURLY .)
    VAR             reduce using rule 60 (anonymousFunction -> FUNCTION LPAREN RPAREN LCURLY cuerpo RCURLY .)
    FUNCTION        reduce using rule 60 (anonymousFunction -> FUNCTION LPAREN RPAREN LCURLY cuerpo RCURLY .)
    FN              reduce using rule 60 (anonymousFunction -> FUNCTION LPAREN RPAREN LCURLY cuerpo RCURLY .)
    ECHO            reduce using rule 60 (anonymousFunction -> FUNCTION LPAREN RPAREN LCURLY cuerpo RCURLY .)
    PRINT           reduce using rule 60 (anonymousFunction -> FUNCTION LPAREN RPAREN LCURLY cuerpo RCURLY .)
    ID              reduce using rule 60 (anonymousFunction -> FUNCTION LPAREN RPAREN LCURLY cuerpo RCURLY .)
    INTEGER         reduce using rule 60 (anonymousFunction -> FUNCTION LPAREN RPAREN LCURLY cuerpo RCURLY .)
    FLOAT           reduce using rule 60 (anonymousFunction -> FUNCTION LPAREN RPAREN LCURLY cuerpo RCURLY .)
    $end            reduce using rule 60 (anonymousFunction -> FUNCTION LPAREN RPAREN LCURLY cuerpo RCURLY .)
    SEMICOLON       reduce using rule 60 (anonymousFunction -> FUNCTION LPAREN RPAREN LCURLY cuerpo RCURLY .)
    RPAREN          reduce using rule 60 (anonymousFunction -> FUNCTION LPAREN RPAREN LCURLY cuerpo RCURLY .)
    RCURLY          reduce using rule 60 (anonymousFunction -> FUNCTION LPAREN RPAREN LCURLY cuerpo RCURLY .)
    CONTINUE        reduce using rule 60 (anonymousFunction -> FUNCTION LPAREN RPAREN LCURLY cuerpo RCURLY .)
    BREAK           reduce using rule 60 (anonymousFunction -> FUNCTION LPAREN RPAREN LCURLY cuerpo RCURLY .)


state 195

    (61) anonymousFunction -> FUNCTION LPAREN arguments RPAREN LCURLY cuerpo . RCURLY

    RCURLY          shift and go to state 213


state 196

    (63) arrowBody -> FN . LPAREN VAR RPAREN FNARROW arrowBody
    (62) arrowFunction -> FN . LPAREN VAR RPAREN FNARROW arrowBody SEMICOLON

    LPAREN          shift and go to state 214


state 197

    (62) arrowFunction -> FN LPAREN VAR RPAREN FNARROW arrowBody . SEMICOLON

    SEMICOLON       shift and go to state 215


state 198

    (64) arrowBody -> cuerpo .

    SEMICOLON       reduce using rule 64 (arrowBody -> cuerpo .)


state 199

    (31) if_elseStatement -> IF LPAREN logicalCondition RPAREN LCURLY ifStatementBody RCURLY . ELSE LCURLY ifStatementBody RCURLY

    ELSE            shift and go to state 216


state 200

    (35) ifStatementBody -> ifStatementBody cuerpo .

    CONTINUE        reduce using rule 35 (ifStatementBody -> ifStatementBody cuerpo .)
    RCURLY          reduce using rule 35 (ifStatementBody -> ifStatementBody cuerpo .)
    OPEN_TAG        reduce using rule 35 (ifStatementBody -> ifStatementBody cuerpo .)
    CLOSE_TAG       reduce using rule 35 (ifStatementBody -> ifStatementBody cuerpo .)
    STRING          reduce using rule 35 (ifStatementBody -> ifStatementBody cuerpo .)
    LPAREN          reduce using rule 35 (ifStatementBody -> ifStatementBody cuerpo .)
    IF              reduce using rule 35 (ifStatementBody -> ifStatementBody cuerpo .)
    FOR             reduce using rule 35 (ifStatementBody -> ifStatementBody cuerpo .)
    SWITCH          reduce using rule 35 (ifStatementBody -> ifStatementBody cuerpo .)
    VAR             reduce using rule 35 (ifStatementBody -> ifStatementBody cuerpo .)
    FUNCTION        reduce using rule 35 (ifStatementBody -> ifStatementBody cuerpo .)
    FN              reduce using rule 35 (ifStatementBody -> ifStatementBody cuerpo .)
    ECHO            reduce using rule 35 (ifStatementBody -> ifStatementBody cuerpo .)
    PRINT           reduce using rule 35 (ifStatementBody -> ifStatementBody cuerpo .)
    ID              reduce using rule 35 (ifStatementBody -> ifStatementBody cuerpo .)
    INTEGER         reduce using rule 35 (ifStatementBody -> ifStatementBody cuerpo .)
    FLOAT           reduce using rule 35 (ifStatementBody -> ifStatementBody cuerpo .)
    $end            reduce using rule 35 (ifStatementBody -> ifStatementBody cuerpo .)
    SEMICOLON       reduce using rule 35 (ifStatementBody -> ifStatementBody cuerpo .)
    BREAK           reduce using rule 35 (ifStatementBody -> ifStatementBody cuerpo .)


state 201

    (34) ifStatementBody -> cuerpo CONTINUE . SEMICOLON

    SEMICOLON       shift and go to state 217


state 202

    (36) forStatement -> FOR LPAREN forStatementCondition RPAREN LCURLY forStatementBody RCURLY .

    OPEN_TAG        reduce using rule 36 (forStatement -> FOR LPAREN forStatementCondition RPAREN LCURLY forStatementBody RCURLY .)
    CLOSE_TAG       reduce using rule 36 (forStatement -> FOR LPAREN forStatementCondition RPAREN LCURLY forStatementBody RCURLY .)
    STRING          reduce using rule 36 (forStatement -> FOR LPAREN forStatementCondition RPAREN LCURLY forStatementBody RCURLY .)
    LPAREN          reduce using rule 36 (forStatement -> FOR LPAREN forStatementCondition RPAREN LCURLY forStatementBody RCURLY .)
    IF              reduce using rule 36 (forStatement -> FOR LPAREN forStatementCondition RPAREN LCURLY forStatementBody RCURLY .)
    FOR             reduce using rule 36 (forStatement -> FOR LPAREN forStatementCondition RPAREN LCURLY forStatementBody RCURLY .)
    SWITCH          reduce using rule 36 (forStatement -> FOR LPAREN forStatementCondition RPAREN LCURLY forStatementBody RCURLY .)
    VAR             reduce using rule 36 (forStatement -> FOR LPAREN forStatementCondition RPAREN LCURLY forStatementBody RCURLY .)
    FUNCTION        reduce using rule 36 (forStatement -> FOR LPAREN forStatementCondition RPAREN LCURLY forStatementBody RCURLY .)
    FN              reduce using rule 36 (forStatement -> FOR LPAREN forStatementCondition RPAREN LCURLY forStatementBody RCURLY .)
    ECHO            reduce using rule 36 (forStatement -> FOR LPAREN forStatementCondition RPAREN LCURLY forStatementBody RCURLY .)
    PRINT           reduce using rule 36 (forStatement -> FOR LPAREN forStatementCondition RPAREN LCURLY forStatementBody RCURLY .)
    ID              reduce using rule 36 (forStatement -> FOR LPAREN forStatementCondition RPAREN LCURLY forStatementBody RCURLY .)
    INTEGER         reduce using rule 36 (forStatement -> FOR LPAREN forStatementCondition RPAREN LCURLY forStatementBody RCURLY .)
    FLOAT           reduce using rule 36 (forStatement -> FOR LPAREN forStatementCondition RPAREN LCURLY forStatementBody RCURLY .)
    $end            reduce using rule 36 (forStatement -> FOR LPAREN forStatementCondition RPAREN LCURLY forStatementBody RCURLY .)
    RCURLY          reduce using rule 36 (forStatement -> FOR LPAREN forStatementCondition RPAREN LCURLY forStatementBody RCURLY .)
    CONTINUE        reduce using rule 36 (forStatement -> FOR LPAREN forStatementCondition RPAREN LCURLY forStatementBody RCURLY .)
    SEMICOLON       reduce using rule 36 (forStatement -> FOR LPAREN forStatementCondition RPAREN LCURLY forStatementBody RCURLY .)
    BREAK           reduce using rule 36 (forStatement -> FOR LPAREN forStatementCondition RPAREN LCURLY forStatementBody RCURLY .)


state 203

    (41) forStatementBody -> forStatementBody cuerpo .

    RCURLY          reduce using rule 41 (forStatementBody -> forStatementBody cuerpo .)
    OPEN_TAG        reduce using rule 41 (forStatementBody -> forStatementBody cuerpo .)
    CLOSE_TAG       reduce using rule 41 (forStatementBody -> forStatementBody cuerpo .)
    STRING          reduce using rule 41 (forStatementBody -> forStatementBody cuerpo .)
    LPAREN          reduce using rule 41 (forStatementBody -> forStatementBody cuerpo .)
    IF              reduce using rule 41 (forStatementBody -> forStatementBody cuerpo .)
    FOR             reduce using rule 41 (forStatementBody -> forStatementBody cuerpo .)
    SWITCH          reduce using rule 41 (forStatementBody -> forStatementBody cuerpo .)
    VAR             reduce using rule 41 (forStatementBody -> forStatementBody cuerpo .)
    FUNCTION        reduce using rule 41 (forStatementBody -> forStatementBody cuerpo .)
    FN              reduce using rule 41 (forStatementBody -> forStatementBody cuerpo .)
    ECHO            reduce using rule 41 (forStatementBody -> forStatementBody cuerpo .)
    PRINT           reduce using rule 41 (forStatementBody -> forStatementBody cuerpo .)
    ID              reduce using rule 41 (forStatementBody -> forStatementBody cuerpo .)
    INTEGER         reduce using rule 41 (forStatementBody -> forStatementBody cuerpo .)
    FLOAT           reduce using rule 41 (forStatementBody -> forStatementBody cuerpo .)


state 204

    (39) forStatementCondition -> variableAsignation SEMICOLON comparingValue SEMICOLON variableAsignation .

    RPAREN          reduce using rule 39 (forStatementCondition -> variableAsignation SEMICOLON comparingValue SEMICOLON variableAsignation .)


state 205

    (26) switchStatement -> SWITCH LPAREN value RPAREN LCURLY switchCases switchDefault . RCURLY

    RCURLY          shift and go to state 218


state 206

    (30) switchCases -> switchCases switchCase .

    DEFAULT         reduce using rule 30 (switchCases -> switchCases switchCase .)
    CASE            reduce using rule 30 (switchCases -> switchCases switchCase .)


state 207

    (27) switchDefault -> DEFAULT . COLON programa

    COLON           shift and go to state 219


state 208

    (28) switchCase -> CASE value . COLON programa BREAK SEMICOLON
    (109) stringConcatenation -> value . CONCAT value

    COLON           shift and go to state 220
    CONCAT          shift and go to state 51


state 209

    (70) fgets -> VAR EQUAL FGETS LPAREN STDIN RPAREN SEMICOLON .

    OPEN_TAG        reduce using rule 70 (fgets -> VAR EQUAL FGETS LPAREN STDIN RPAREN SEMICOLON .)
    CLOSE_TAG       reduce using rule 70 (fgets -> VAR EQUAL FGETS LPAREN STDIN RPAREN SEMICOLON .)
    STRING          reduce using rule 70 (fgets -> VAR EQUAL FGETS LPAREN STDIN RPAREN SEMICOLON .)
    LPAREN          reduce using rule 70 (fgets -> VAR EQUAL FGETS LPAREN STDIN RPAREN SEMICOLON .)
    IF              reduce using rule 70 (fgets -> VAR EQUAL FGETS LPAREN STDIN RPAREN SEMICOLON .)
    FOR             reduce using rule 70 (fgets -> VAR EQUAL FGETS LPAREN STDIN RPAREN SEMICOLON .)
    SWITCH          reduce using rule 70 (fgets -> VAR EQUAL FGETS LPAREN STDIN RPAREN SEMICOLON .)
    VAR             reduce using rule 70 (fgets -> VAR EQUAL FGETS LPAREN STDIN RPAREN SEMICOLON .)
    FUNCTION        reduce using rule 70 (fgets -> VAR EQUAL FGETS LPAREN STDIN RPAREN SEMICOLON .)
    FN              reduce using rule 70 (fgets -> VAR EQUAL FGETS LPAREN STDIN RPAREN SEMICOLON .)
    ECHO            reduce using rule 70 (fgets -> VAR EQUAL FGETS LPAREN STDIN RPAREN SEMICOLON .)
    PRINT           reduce using rule 70 (fgets -> VAR EQUAL FGETS LPAREN STDIN RPAREN SEMICOLON .)
    ID              reduce using rule 70 (fgets -> VAR EQUAL FGETS LPAREN STDIN RPAREN SEMICOLON .)
    INTEGER         reduce using rule 70 (fgets -> VAR EQUAL FGETS LPAREN STDIN RPAREN SEMICOLON .)
    FLOAT           reduce using rule 70 (fgets -> VAR EQUAL FGETS LPAREN STDIN RPAREN SEMICOLON .)
    $end            reduce using rule 70 (fgets -> VAR EQUAL FGETS LPAREN STDIN RPAREN SEMICOLON .)
    RCURLY          reduce using rule 70 (fgets -> VAR EQUAL FGETS LPAREN STDIN RPAREN SEMICOLON .)
    CONTINUE        reduce using rule 70 (fgets -> VAR EQUAL FGETS LPAREN STDIN RPAREN SEMICOLON .)
    SEMICOLON       reduce using rule 70 (fgets -> VAR EQUAL FGETS LPAREN STDIN RPAREN SEMICOLON .)
    BREAK           reduce using rule 70 (fgets -> VAR EQUAL FGETS LPAREN STDIN RPAREN SEMICOLON .)


state 210

    (54) queueEnqueue -> VAR OBJOP PUSH LPAREN value RPAREN SEMICOLON .
    (51) stackPush -> VAR OBJOP PUSH LPAREN value RPAREN SEMICOLON .

  ! reduce/reduce conflict for OPEN_TAG resolved using rule 51 (stackPush -> VAR OBJOP PUSH LPAREN value RPAREN SEMICOLON .)
  ! reduce/reduce conflict for CLOSE_TAG resolved using rule 51 (stackPush -> VAR OBJOP PUSH LPAREN value RPAREN SEMICOLON .)
  ! reduce/reduce conflict for STRING resolved using rule 51 (stackPush -> VAR OBJOP PUSH LPAREN value RPAREN SEMICOLON .)
  ! reduce/reduce conflict for LPAREN resolved using rule 51 (stackPush -> VAR OBJOP PUSH LPAREN value RPAREN SEMICOLON .)
  ! reduce/reduce conflict for IF resolved using rule 51 (stackPush -> VAR OBJOP PUSH LPAREN value RPAREN SEMICOLON .)
  ! reduce/reduce conflict for FOR resolved using rule 51 (stackPush -> VAR OBJOP PUSH LPAREN value RPAREN SEMICOLON .)
  ! reduce/reduce conflict for SWITCH resolved using rule 51 (stackPush -> VAR OBJOP PUSH LPAREN value RPAREN SEMICOLON .)
  ! reduce/reduce conflict for VAR resolved using rule 51 (stackPush -> VAR OBJOP PUSH LPAREN value RPAREN SEMICOLON .)
  ! reduce/reduce conflict for FUNCTION resolved using rule 51 (stackPush -> VAR OBJOP PUSH LPAREN value RPAREN SEMICOLON .)
  ! reduce/reduce conflict for FN resolved using rule 51 (stackPush -> VAR OBJOP PUSH LPAREN value RPAREN SEMICOLON .)
  ! reduce/reduce conflict for ECHO resolved using rule 51 (stackPush -> VAR OBJOP PUSH LPAREN value RPAREN SEMICOLON .)
  ! reduce/reduce conflict for PRINT resolved using rule 51 (stackPush -> VAR OBJOP PUSH LPAREN value RPAREN SEMICOLON .)
  ! reduce/reduce conflict for ID resolved using rule 51 (stackPush -> VAR OBJOP PUSH LPAREN value RPAREN SEMICOLON .)
  ! reduce/reduce conflict for INTEGER resolved using rule 51 (stackPush -> VAR OBJOP PUSH LPAREN value RPAREN SEMICOLON .)
  ! reduce/reduce conflict for FLOAT resolved using rule 51 (stackPush -> VAR OBJOP PUSH LPAREN value RPAREN SEMICOLON .)
  ! reduce/reduce conflict for $end resolved using rule 51 (stackPush -> VAR OBJOP PUSH LPAREN value RPAREN SEMICOLON .)
  ! reduce/reduce conflict for RCURLY resolved using rule 51 (stackPush -> VAR OBJOP PUSH LPAREN value RPAREN SEMICOLON .)
  ! reduce/reduce conflict for CONTINUE resolved using rule 51 (stackPush -> VAR OBJOP PUSH LPAREN value RPAREN SEMICOLON .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 51 (stackPush -> VAR OBJOP PUSH LPAREN value RPAREN SEMICOLON .)
  ! reduce/reduce conflict for BREAK resolved using rule 51 (stackPush -> VAR OBJOP PUSH LPAREN value RPAREN SEMICOLON .)
    OPEN_TAG        reduce using rule 51 (stackPush -> VAR OBJOP PUSH LPAREN value RPAREN SEMICOLON .)
    CLOSE_TAG       reduce using rule 51 (stackPush -> VAR OBJOP PUSH LPAREN value RPAREN SEMICOLON .)
    STRING          reduce using rule 51 (stackPush -> VAR OBJOP PUSH LPAREN value RPAREN SEMICOLON .)
    LPAREN          reduce using rule 51 (stackPush -> VAR OBJOP PUSH LPAREN value RPAREN SEMICOLON .)
    IF              reduce using rule 51 (stackPush -> VAR OBJOP PUSH LPAREN value RPAREN SEMICOLON .)
    FOR             reduce using rule 51 (stackPush -> VAR OBJOP PUSH LPAREN value RPAREN SEMICOLON .)
    SWITCH          reduce using rule 51 (stackPush -> VAR OBJOP PUSH LPAREN value RPAREN SEMICOLON .)
    VAR             reduce using rule 51 (stackPush -> VAR OBJOP PUSH LPAREN value RPAREN SEMICOLON .)
    FUNCTION        reduce using rule 51 (stackPush -> VAR OBJOP PUSH LPAREN value RPAREN SEMICOLON .)
    FN              reduce using rule 51 (stackPush -> VAR OBJOP PUSH LPAREN value RPAREN SEMICOLON .)
    ECHO            reduce using rule 51 (stackPush -> VAR OBJOP PUSH LPAREN value RPAREN SEMICOLON .)
    PRINT           reduce using rule 51 (stackPush -> VAR OBJOP PUSH LPAREN value RPAREN SEMICOLON .)
    ID              reduce using rule 51 (stackPush -> VAR OBJOP PUSH LPAREN value RPAREN SEMICOLON .)
    INTEGER         reduce using rule 51 (stackPush -> VAR OBJOP PUSH LPAREN value RPAREN SEMICOLON .)
    FLOAT           reduce using rule 51 (stackPush -> VAR OBJOP PUSH LPAREN value RPAREN SEMICOLON .)
    $end            reduce using rule 51 (stackPush -> VAR OBJOP PUSH LPAREN value RPAREN SEMICOLON .)
    RCURLY          reduce using rule 51 (stackPush -> VAR OBJOP PUSH LPAREN value RPAREN SEMICOLON .)
    CONTINUE        reduce using rule 51 (stackPush -> VAR OBJOP PUSH LPAREN value RPAREN SEMICOLON .)
    SEMICOLON       reduce using rule 51 (stackPush -> VAR OBJOP PUSH LPAREN value RPAREN SEMICOLON .)
    BREAK           reduce using rule 51 (stackPush -> VAR OBJOP PUSH LPAREN value RPAREN SEMICOLON .)

  ! OPEN_TAG        [ reduce using rule 54 (queueEnqueue -> VAR OBJOP PUSH LPAREN value RPAREN SEMICOLON .) ]
  ! CLOSE_TAG       [ reduce using rule 54 (queueEnqueue -> VAR OBJOP PUSH LPAREN value RPAREN SEMICOLON .) ]
  ! STRING          [ reduce using rule 54 (queueEnqueue -> VAR OBJOP PUSH LPAREN value RPAREN SEMICOLON .) ]
  ! LPAREN          [ reduce using rule 54 (queueEnqueue -> VAR OBJOP PUSH LPAREN value RPAREN SEMICOLON .) ]
  ! IF              [ reduce using rule 54 (queueEnqueue -> VAR OBJOP PUSH LPAREN value RPAREN SEMICOLON .) ]
  ! FOR             [ reduce using rule 54 (queueEnqueue -> VAR OBJOP PUSH LPAREN value RPAREN SEMICOLON .) ]
  ! SWITCH          [ reduce using rule 54 (queueEnqueue -> VAR OBJOP PUSH LPAREN value RPAREN SEMICOLON .) ]
  ! VAR             [ reduce using rule 54 (queueEnqueue -> VAR OBJOP PUSH LPAREN value RPAREN SEMICOLON .) ]
  ! FUNCTION        [ reduce using rule 54 (queueEnqueue -> VAR OBJOP PUSH LPAREN value RPAREN SEMICOLON .) ]
  ! FN              [ reduce using rule 54 (queueEnqueue -> VAR OBJOP PUSH LPAREN value RPAREN SEMICOLON .) ]
  ! ECHO            [ reduce using rule 54 (queueEnqueue -> VAR OBJOP PUSH LPAREN value RPAREN SEMICOLON .) ]
  ! PRINT           [ reduce using rule 54 (queueEnqueue -> VAR OBJOP PUSH LPAREN value RPAREN SEMICOLON .) ]
  ! ID              [ reduce using rule 54 (queueEnqueue -> VAR OBJOP PUSH LPAREN value RPAREN SEMICOLON .) ]
  ! INTEGER         [ reduce using rule 54 (queueEnqueue -> VAR OBJOP PUSH LPAREN value RPAREN SEMICOLON .) ]
  ! FLOAT           [ reduce using rule 54 (queueEnqueue -> VAR OBJOP PUSH LPAREN value RPAREN SEMICOLON .) ]
  ! $end            [ reduce using rule 54 (queueEnqueue -> VAR OBJOP PUSH LPAREN value RPAREN SEMICOLON .) ]
  ! RCURLY          [ reduce using rule 54 (queueEnqueue -> VAR OBJOP PUSH LPAREN value RPAREN SEMICOLON .) ]
  ! CONTINUE        [ reduce using rule 54 (queueEnqueue -> VAR OBJOP PUSH LPAREN value RPAREN SEMICOLON .) ]
  ! SEMICOLON       [ reduce using rule 54 (queueEnqueue -> VAR OBJOP PUSH LPAREN value RPAREN SEMICOLON .) ]
  ! BREAK           [ reduce using rule 54 (queueEnqueue -> VAR OBJOP PUSH LPAREN value RPAREN SEMICOLON .) ]


state 211

    (56) defineFunction -> FUNCTION ID LPAREN arguments RPAREN LCURLY programa . RCURLY
    (2) programa -> programa . cuerpo
    (3) cuerpo -> . arithmeticExpression
    (4) cuerpo -> . if_elseStatement
    (5) cuerpo -> . forStatement
    (6) cuerpo -> . switchStatement
    (7) cuerpo -> . arrayAsignation
    (8) cuerpo -> . queueDeclaration
    (9) cuerpo -> . queueEnqueue
    (10) cuerpo -> . queueDequeue
    (11) cuerpo -> . defineFunction
    (12) cuerpo -> . anonymousFunction
    (13) cuerpo -> . arrowFunction
    (14) cuerpo -> . echo
    (15) cuerpo -> . fgets
    (16) cuerpo -> . stackDeclaration
    (17) cuerpo -> . stackPush
    (18) cuerpo -> . stackPop
    (19) cuerpo -> . line
    (20) cuerpo -> . print
    (21) cuerpo -> . logicalCondition
    (22) cuerpo -> . OPEN_TAG
    (23) cuerpo -> . CLOSE_TAG
    (24) cuerpo -> . stringConcatenation
    (25) cuerpo -> . callFunction
    (71) arithmeticExpression -> . value
    (72) arithmeticExpression -> . STRING
    (73) arithmeticExpression -> . LPAREN arithmeticExpression RPAREN
    (74) arithmeticExpression -> . arithmeticExpression arithmeticOperator arithmeticExpression
    (31) if_elseStatement -> . IF LPAREN logicalCondition RPAREN LCURLY ifStatementBody RCURLY ELSE LCURLY ifStatementBody RCURLY
    (32) if_elseStatement -> . IF LPAREN logicalCondition RPAREN LCURLY ifStatementBody
    (36) forStatement -> . FOR LPAREN forStatementCondition RPAREN LCURLY forStatementBody RCURLY
    (26) switchStatement -> . SWITCH LPAREN value RPAREN LCURLY switchCases switchDefault RCURLY
    (42) arrayAsignation -> . VAR EQUAL arrayDeclaration SEMICOLON
    (53) queueDeclaration -> . VAR EQUAL NEW QUEUE SEMICOLON
    (54) queueEnqueue -> . VAR OBJOP PUSH LPAREN value RPAREN SEMICOLON
    (55) queueDequeue -> . VAR OBJOP POP SEMICOLON
    (56) defineFunction -> . FUNCTION ID LPAREN arguments RPAREN LCURLY programa RCURLY
    (57) defineFunction -> . FUNCTION ID LPAREN RPAREN LCURLY programa RCURLY
    (60) anonymousFunction -> . FUNCTION LPAREN RPAREN LCURLY cuerpo RCURLY
    (61) anonymousFunction -> . FUNCTION LPAREN arguments RPAREN LCURLY cuerpo RCURLY
    (62) arrowFunction -> . FN LPAREN VAR RPAREN FNARROW arrowBody SEMICOLON
    (65) echo -> . ECHO values SEMICOLON
    (70) fgets -> . VAR EQUAL FGETS LPAREN STDIN RPAREN SEMICOLON
    (50) stackDeclaration -> . VAR EQUAL NEW STACK SEMICOLON
    (51) stackPush -> . VAR OBJOP PUSH LPAREN value RPAREN SEMICOLON
    (52) stackPop -> . VAR OBJOP POP SEMICOLON
    (88) line -> . variableAsignation SEMICOLON
    (66) print -> . PRINT LPAREN values RPAREN SEMICOLON
    (67) print -> . PRINT value SEMICOLON
    (103) logicalCondition -> . comparingValue
    (104) logicalCondition -> . comparingValue conditionOperator comparingValue
    (105) logicalCondition -> . LPAREN logicalCondition RPAREN
    (109) stringConcatenation -> . value CONCAT value
    (110) stringConcatenation -> . stringConcatenation CONCAT stringConcatenation
    (75) callFunction -> . ID LPAREN RPAREN SEMICOLON
    (76) callFunction -> . ID LPAREN value RPAREN SEMICOLON
    (77) value -> . VAR
    (78) value -> . INTEGER
    (79) value -> . FLOAT
    (80) value -> . STRING
    (81) value -> . stringConcatenation
    (89) variableAsignation -> . VAR EQUAL value
    (90) variableAsignation -> . VAR EQUAL arithmeticExpression
    (91) variableAsignation -> . VAR INCREMENT
    (92) variableAsignation -> . VAR DECREMENT
    (93) variableAsignation -> . VAR EQUAL stringConcatenation
    (94) variableAsignation -> . VAR EQUAL anonymousFunction
    (102) comparingValue -> . value comparingSign value

    RCURLY          shift and go to state 221
    OPEN_TAG        shift and go to state 22
    CLOSE_TAG       shift and go to state 23
    STRING          shift and go to state 27
    LPAREN          shift and go to state 28
    IF              shift and go to state 29
    FOR             shift and go to state 30
    SWITCH          shift and go to state 31
    VAR             shift and go to state 32
    FUNCTION        shift and go to state 33
    FN              shift and go to state 35
    ECHO            shift and go to state 36
    PRINT           shift and go to state 38
    ID              shift and go to state 34
    INTEGER         shift and go to state 40
    FLOAT           shift and go to state 41

    cuerpo                         shift and go to state 42
    arithmeticExpression           shift and go to state 3
    if_elseStatement               shift and go to state 4
    forStatement                   shift and go to state 5
    switchStatement                shift and go to state 6
    arrayAsignation                shift and go to state 7
    queueDeclaration               shift and go to state 8
    queueEnqueue                   shift and go to state 9
    queueDequeue                   shift and go to state 10
    defineFunction                 shift and go to state 11
    anonymousFunction              shift and go to state 12
    arrowFunction                  shift and go to state 13
    echo                           shift and go to state 14
    fgets                          shift and go to state 15
    stackDeclaration               shift and go to state 16
    stackPush                      shift and go to state 17
    stackPop                       shift and go to state 18
    line                           shift and go to state 19
    print                          shift and go to state 20
    logicalCondition               shift and go to state 21
    stringConcatenation            shift and go to state 24
    callFunction                   shift and go to state 25
    value                          shift and go to state 26
    variableAsignation             shift and go to state 37
    comparingValue                 shift and go to state 39

state 212

    (57) defineFunction -> FUNCTION ID LPAREN RPAREN LCURLY programa RCURLY .

    OPEN_TAG        reduce using rule 57 (defineFunction -> FUNCTION ID LPAREN RPAREN LCURLY programa RCURLY .)
    CLOSE_TAG       reduce using rule 57 (defineFunction -> FUNCTION ID LPAREN RPAREN LCURLY programa RCURLY .)
    STRING          reduce using rule 57 (defineFunction -> FUNCTION ID LPAREN RPAREN LCURLY programa RCURLY .)
    LPAREN          reduce using rule 57 (defineFunction -> FUNCTION ID LPAREN RPAREN LCURLY programa RCURLY .)
    IF              reduce using rule 57 (defineFunction -> FUNCTION ID LPAREN RPAREN LCURLY programa RCURLY .)
    FOR             reduce using rule 57 (defineFunction -> FUNCTION ID LPAREN RPAREN LCURLY programa RCURLY .)
    SWITCH          reduce using rule 57 (defineFunction -> FUNCTION ID LPAREN RPAREN LCURLY programa RCURLY .)
    VAR             reduce using rule 57 (defineFunction -> FUNCTION ID LPAREN RPAREN LCURLY programa RCURLY .)
    FUNCTION        reduce using rule 57 (defineFunction -> FUNCTION ID LPAREN RPAREN LCURLY programa RCURLY .)
    FN              reduce using rule 57 (defineFunction -> FUNCTION ID LPAREN RPAREN LCURLY programa RCURLY .)
    ECHO            reduce using rule 57 (defineFunction -> FUNCTION ID LPAREN RPAREN LCURLY programa RCURLY .)
    PRINT           reduce using rule 57 (defineFunction -> FUNCTION ID LPAREN RPAREN LCURLY programa RCURLY .)
    ID              reduce using rule 57 (defineFunction -> FUNCTION ID LPAREN RPAREN LCURLY programa RCURLY .)
    INTEGER         reduce using rule 57 (defineFunction -> FUNCTION ID LPAREN RPAREN LCURLY programa RCURLY .)
    FLOAT           reduce using rule 57 (defineFunction -> FUNCTION ID LPAREN RPAREN LCURLY programa RCURLY .)
    $end            reduce using rule 57 (defineFunction -> FUNCTION ID LPAREN RPAREN LCURLY programa RCURLY .)
    RCURLY          reduce using rule 57 (defineFunction -> FUNCTION ID LPAREN RPAREN LCURLY programa RCURLY .)
    CONTINUE        reduce using rule 57 (defineFunction -> FUNCTION ID LPAREN RPAREN LCURLY programa RCURLY .)
    SEMICOLON       reduce using rule 57 (defineFunction -> FUNCTION ID LPAREN RPAREN LCURLY programa RCURLY .)
    BREAK           reduce using rule 57 (defineFunction -> FUNCTION ID LPAREN RPAREN LCURLY programa RCURLY .)


state 213

    (61) anonymousFunction -> FUNCTION LPAREN arguments RPAREN LCURLY cuerpo RCURLY .

    OPEN_TAG        reduce using rule 61 (anonymousFunction -> FUNCTION LPAREN arguments RPAREN LCURLY cuerpo RCURLY .)
    CLOSE_TAG       reduce using rule 61 (anonymousFunction -> FUNCTION LPAREN arguments RPAREN LCURLY cuerpo RCURLY .)
    STRING          reduce using rule 61 (anonymousFunction -> FUNCTION LPAREN arguments RPAREN LCURLY cuerpo RCURLY .)
    LPAREN          reduce using rule 61 (anonymousFunction -> FUNCTION LPAREN arguments RPAREN LCURLY cuerpo RCURLY .)
    IF              reduce using rule 61 (anonymousFunction -> FUNCTION LPAREN arguments RPAREN LCURLY cuerpo RCURLY .)
    FOR             reduce using rule 61 (anonymousFunction -> FUNCTION LPAREN arguments RPAREN LCURLY cuerpo RCURLY .)
    SWITCH          reduce using rule 61 (anonymousFunction -> FUNCTION LPAREN arguments RPAREN LCURLY cuerpo RCURLY .)
    VAR             reduce using rule 61 (anonymousFunction -> FUNCTION LPAREN arguments RPAREN LCURLY cuerpo RCURLY .)
    FUNCTION        reduce using rule 61 (anonymousFunction -> FUNCTION LPAREN arguments RPAREN LCURLY cuerpo RCURLY .)
    FN              reduce using rule 61 (anonymousFunction -> FUNCTION LPAREN arguments RPAREN LCURLY cuerpo RCURLY .)
    ECHO            reduce using rule 61 (anonymousFunction -> FUNCTION LPAREN arguments RPAREN LCURLY cuerpo RCURLY .)
    PRINT           reduce using rule 61 (anonymousFunction -> FUNCTION LPAREN arguments RPAREN LCURLY cuerpo RCURLY .)
    ID              reduce using rule 61 (anonymousFunction -> FUNCTION LPAREN arguments RPAREN LCURLY cuerpo RCURLY .)
    INTEGER         reduce using rule 61 (anonymousFunction -> FUNCTION LPAREN arguments RPAREN LCURLY cuerpo RCURLY .)
    FLOAT           reduce using rule 61 (anonymousFunction -> FUNCTION LPAREN arguments RPAREN LCURLY cuerpo RCURLY .)
    $end            reduce using rule 61 (anonymousFunction -> FUNCTION LPAREN arguments RPAREN LCURLY cuerpo RCURLY .)
    SEMICOLON       reduce using rule 61 (anonymousFunction -> FUNCTION LPAREN arguments RPAREN LCURLY cuerpo RCURLY .)
    RPAREN          reduce using rule 61 (anonymousFunction -> FUNCTION LPAREN arguments RPAREN LCURLY cuerpo RCURLY .)
    RCURLY          reduce using rule 61 (anonymousFunction -> FUNCTION LPAREN arguments RPAREN LCURLY cuerpo RCURLY .)
    CONTINUE        reduce using rule 61 (anonymousFunction -> FUNCTION LPAREN arguments RPAREN LCURLY cuerpo RCURLY .)
    BREAK           reduce using rule 61 (anonymousFunction -> FUNCTION LPAREN arguments RPAREN LCURLY cuerpo RCURLY .)


state 214

    (63) arrowBody -> FN LPAREN . VAR RPAREN FNARROW arrowBody
    (62) arrowFunction -> FN LPAREN . VAR RPAREN FNARROW arrowBody SEMICOLON

    VAR             shift and go to state 222


state 215

    (62) arrowFunction -> FN LPAREN VAR RPAREN FNARROW arrowBody SEMICOLON .

    OPEN_TAG        reduce using rule 62 (arrowFunction -> FN LPAREN VAR RPAREN FNARROW arrowBody SEMICOLON .)
    CLOSE_TAG       reduce using rule 62 (arrowFunction -> FN LPAREN VAR RPAREN FNARROW arrowBody SEMICOLON .)
    STRING          reduce using rule 62 (arrowFunction -> FN LPAREN VAR RPAREN FNARROW arrowBody SEMICOLON .)
    LPAREN          reduce using rule 62 (arrowFunction -> FN LPAREN VAR RPAREN FNARROW arrowBody SEMICOLON .)
    IF              reduce using rule 62 (arrowFunction -> FN LPAREN VAR RPAREN FNARROW arrowBody SEMICOLON .)
    FOR             reduce using rule 62 (arrowFunction -> FN LPAREN VAR RPAREN FNARROW arrowBody SEMICOLON .)
    SWITCH          reduce using rule 62 (arrowFunction -> FN LPAREN VAR RPAREN FNARROW arrowBody SEMICOLON .)
    VAR             reduce using rule 62 (arrowFunction -> FN LPAREN VAR RPAREN FNARROW arrowBody SEMICOLON .)
    FUNCTION        reduce using rule 62 (arrowFunction -> FN LPAREN VAR RPAREN FNARROW arrowBody SEMICOLON .)
    FN              reduce using rule 62 (arrowFunction -> FN LPAREN VAR RPAREN FNARROW arrowBody SEMICOLON .)
    ECHO            reduce using rule 62 (arrowFunction -> FN LPAREN VAR RPAREN FNARROW arrowBody SEMICOLON .)
    PRINT           reduce using rule 62 (arrowFunction -> FN LPAREN VAR RPAREN FNARROW arrowBody SEMICOLON .)
    ID              reduce using rule 62 (arrowFunction -> FN LPAREN VAR RPAREN FNARROW arrowBody SEMICOLON .)
    INTEGER         reduce using rule 62 (arrowFunction -> FN LPAREN VAR RPAREN FNARROW arrowBody SEMICOLON .)
    FLOAT           reduce using rule 62 (arrowFunction -> FN LPAREN VAR RPAREN FNARROW arrowBody SEMICOLON .)
    $end            reduce using rule 62 (arrowFunction -> FN LPAREN VAR RPAREN FNARROW arrowBody SEMICOLON .)
    RCURLY          reduce using rule 62 (arrowFunction -> FN LPAREN VAR RPAREN FNARROW arrowBody SEMICOLON .)
    CONTINUE        reduce using rule 62 (arrowFunction -> FN LPAREN VAR RPAREN FNARROW arrowBody SEMICOLON .)
    SEMICOLON       reduce using rule 62 (arrowFunction -> FN LPAREN VAR RPAREN FNARROW arrowBody SEMICOLON .)
    BREAK           reduce using rule 62 (arrowFunction -> FN LPAREN VAR RPAREN FNARROW arrowBody SEMICOLON .)


state 216

    (31) if_elseStatement -> IF LPAREN logicalCondition RPAREN LCURLY ifStatementBody RCURLY ELSE . LCURLY ifStatementBody RCURLY

    LCURLY          shift and go to state 223


state 217

    (34) ifStatementBody -> cuerpo CONTINUE SEMICOLON .

    CONTINUE        reduce using rule 34 (ifStatementBody -> cuerpo CONTINUE SEMICOLON .)
    RCURLY          reduce using rule 34 (ifStatementBody -> cuerpo CONTINUE SEMICOLON .)
    OPEN_TAG        reduce using rule 34 (ifStatementBody -> cuerpo CONTINUE SEMICOLON .)
    CLOSE_TAG       reduce using rule 34 (ifStatementBody -> cuerpo CONTINUE SEMICOLON .)
    STRING          reduce using rule 34 (ifStatementBody -> cuerpo CONTINUE SEMICOLON .)
    LPAREN          reduce using rule 34 (ifStatementBody -> cuerpo CONTINUE SEMICOLON .)
    IF              reduce using rule 34 (ifStatementBody -> cuerpo CONTINUE SEMICOLON .)
    FOR             reduce using rule 34 (ifStatementBody -> cuerpo CONTINUE SEMICOLON .)
    SWITCH          reduce using rule 34 (ifStatementBody -> cuerpo CONTINUE SEMICOLON .)
    VAR             reduce using rule 34 (ifStatementBody -> cuerpo CONTINUE SEMICOLON .)
    FUNCTION        reduce using rule 34 (ifStatementBody -> cuerpo CONTINUE SEMICOLON .)
    FN              reduce using rule 34 (ifStatementBody -> cuerpo CONTINUE SEMICOLON .)
    ECHO            reduce using rule 34 (ifStatementBody -> cuerpo CONTINUE SEMICOLON .)
    PRINT           reduce using rule 34 (ifStatementBody -> cuerpo CONTINUE SEMICOLON .)
    ID              reduce using rule 34 (ifStatementBody -> cuerpo CONTINUE SEMICOLON .)
    INTEGER         reduce using rule 34 (ifStatementBody -> cuerpo CONTINUE SEMICOLON .)
    FLOAT           reduce using rule 34 (ifStatementBody -> cuerpo CONTINUE SEMICOLON .)
    $end            reduce using rule 34 (ifStatementBody -> cuerpo CONTINUE SEMICOLON .)
    SEMICOLON       reduce using rule 34 (ifStatementBody -> cuerpo CONTINUE SEMICOLON .)
    BREAK           reduce using rule 34 (ifStatementBody -> cuerpo CONTINUE SEMICOLON .)


state 218

    (26) switchStatement -> SWITCH LPAREN value RPAREN LCURLY switchCases switchDefault RCURLY .

    OPEN_TAG        reduce using rule 26 (switchStatement -> SWITCH LPAREN value RPAREN LCURLY switchCases switchDefault RCURLY .)
    CLOSE_TAG       reduce using rule 26 (switchStatement -> SWITCH LPAREN value RPAREN LCURLY switchCases switchDefault RCURLY .)
    STRING          reduce using rule 26 (switchStatement -> SWITCH LPAREN value RPAREN LCURLY switchCases switchDefault RCURLY .)
    LPAREN          reduce using rule 26 (switchStatement -> SWITCH LPAREN value RPAREN LCURLY switchCases switchDefault RCURLY .)
    IF              reduce using rule 26 (switchStatement -> SWITCH LPAREN value RPAREN LCURLY switchCases switchDefault RCURLY .)
    FOR             reduce using rule 26 (switchStatement -> SWITCH LPAREN value RPAREN LCURLY switchCases switchDefault RCURLY .)
    SWITCH          reduce using rule 26 (switchStatement -> SWITCH LPAREN value RPAREN LCURLY switchCases switchDefault RCURLY .)
    VAR             reduce using rule 26 (switchStatement -> SWITCH LPAREN value RPAREN LCURLY switchCases switchDefault RCURLY .)
    FUNCTION        reduce using rule 26 (switchStatement -> SWITCH LPAREN value RPAREN LCURLY switchCases switchDefault RCURLY .)
    FN              reduce using rule 26 (switchStatement -> SWITCH LPAREN value RPAREN LCURLY switchCases switchDefault RCURLY .)
    ECHO            reduce using rule 26 (switchStatement -> SWITCH LPAREN value RPAREN LCURLY switchCases switchDefault RCURLY .)
    PRINT           reduce using rule 26 (switchStatement -> SWITCH LPAREN value RPAREN LCURLY switchCases switchDefault RCURLY .)
    ID              reduce using rule 26 (switchStatement -> SWITCH LPAREN value RPAREN LCURLY switchCases switchDefault RCURLY .)
    INTEGER         reduce using rule 26 (switchStatement -> SWITCH LPAREN value RPAREN LCURLY switchCases switchDefault RCURLY .)
    FLOAT           reduce using rule 26 (switchStatement -> SWITCH LPAREN value RPAREN LCURLY switchCases switchDefault RCURLY .)
    $end            reduce using rule 26 (switchStatement -> SWITCH LPAREN value RPAREN LCURLY switchCases switchDefault RCURLY .)
    RCURLY          reduce using rule 26 (switchStatement -> SWITCH LPAREN value RPAREN LCURLY switchCases switchDefault RCURLY .)
    CONTINUE        reduce using rule 26 (switchStatement -> SWITCH LPAREN value RPAREN LCURLY switchCases switchDefault RCURLY .)
    SEMICOLON       reduce using rule 26 (switchStatement -> SWITCH LPAREN value RPAREN LCURLY switchCases switchDefault RCURLY .)
    BREAK           reduce using rule 26 (switchStatement -> SWITCH LPAREN value RPAREN LCURLY switchCases switchDefault RCURLY .)


state 219

    (27) switchDefault -> DEFAULT COLON . programa
    (1) programa -> . cuerpo
    (2) programa -> . programa cuerpo
    (3) cuerpo -> . arithmeticExpression
    (4) cuerpo -> . if_elseStatement
    (5) cuerpo -> . forStatement
    (6) cuerpo -> . switchStatement
    (7) cuerpo -> . arrayAsignation
    (8) cuerpo -> . queueDeclaration
    (9) cuerpo -> . queueEnqueue
    (10) cuerpo -> . queueDequeue
    (11) cuerpo -> . defineFunction
    (12) cuerpo -> . anonymousFunction
    (13) cuerpo -> . arrowFunction
    (14) cuerpo -> . echo
    (15) cuerpo -> . fgets
    (16) cuerpo -> . stackDeclaration
    (17) cuerpo -> . stackPush
    (18) cuerpo -> . stackPop
    (19) cuerpo -> . line
    (20) cuerpo -> . print
    (21) cuerpo -> . logicalCondition
    (22) cuerpo -> . OPEN_TAG
    (23) cuerpo -> . CLOSE_TAG
    (24) cuerpo -> . stringConcatenation
    (25) cuerpo -> . callFunction
    (71) arithmeticExpression -> . value
    (72) arithmeticExpression -> . STRING
    (73) arithmeticExpression -> . LPAREN arithmeticExpression RPAREN
    (74) arithmeticExpression -> . arithmeticExpression arithmeticOperator arithmeticExpression
    (31) if_elseStatement -> . IF LPAREN logicalCondition RPAREN LCURLY ifStatementBody RCURLY ELSE LCURLY ifStatementBody RCURLY
    (32) if_elseStatement -> . IF LPAREN logicalCondition RPAREN LCURLY ifStatementBody
    (36) forStatement -> . FOR LPAREN forStatementCondition RPAREN LCURLY forStatementBody RCURLY
    (26) switchStatement -> . SWITCH LPAREN value RPAREN LCURLY switchCases switchDefault RCURLY
    (42) arrayAsignation -> . VAR EQUAL arrayDeclaration SEMICOLON
    (53) queueDeclaration -> . VAR EQUAL NEW QUEUE SEMICOLON
    (54) queueEnqueue -> . VAR OBJOP PUSH LPAREN value RPAREN SEMICOLON
    (55) queueDequeue -> . VAR OBJOP POP SEMICOLON
    (56) defineFunction -> . FUNCTION ID LPAREN arguments RPAREN LCURLY programa RCURLY
    (57) defineFunction -> . FUNCTION ID LPAREN RPAREN LCURLY programa RCURLY
    (60) anonymousFunction -> . FUNCTION LPAREN RPAREN LCURLY cuerpo RCURLY
    (61) anonymousFunction -> . FUNCTION LPAREN arguments RPAREN LCURLY cuerpo RCURLY
    (62) arrowFunction -> . FN LPAREN VAR RPAREN FNARROW arrowBody SEMICOLON
    (65) echo -> . ECHO values SEMICOLON
    (70) fgets -> . VAR EQUAL FGETS LPAREN STDIN RPAREN SEMICOLON
    (50) stackDeclaration -> . VAR EQUAL NEW STACK SEMICOLON
    (51) stackPush -> . VAR OBJOP PUSH LPAREN value RPAREN SEMICOLON
    (52) stackPop -> . VAR OBJOP POP SEMICOLON
    (88) line -> . variableAsignation SEMICOLON
    (66) print -> . PRINT LPAREN values RPAREN SEMICOLON
    (67) print -> . PRINT value SEMICOLON
    (103) logicalCondition -> . comparingValue
    (104) logicalCondition -> . comparingValue conditionOperator comparingValue
    (105) logicalCondition -> . LPAREN logicalCondition RPAREN
    (109) stringConcatenation -> . value CONCAT value
    (110) stringConcatenation -> . stringConcatenation CONCAT stringConcatenation
    (75) callFunction -> . ID LPAREN RPAREN SEMICOLON
    (76) callFunction -> . ID LPAREN value RPAREN SEMICOLON
    (77) value -> . VAR
    (78) value -> . INTEGER
    (79) value -> . FLOAT
    (80) value -> . STRING
    (81) value -> . stringConcatenation
    (89) variableAsignation -> . VAR EQUAL value
    (90) variableAsignation -> . VAR EQUAL arithmeticExpression
    (91) variableAsignation -> . VAR INCREMENT
    (92) variableAsignation -> . VAR DECREMENT
    (93) variableAsignation -> . VAR EQUAL stringConcatenation
    (94) variableAsignation -> . VAR EQUAL anonymousFunction
    (102) comparingValue -> . value comparingSign value

    OPEN_TAG        shift and go to state 22
    CLOSE_TAG       shift and go to state 23
    STRING          shift and go to state 27
    LPAREN          shift and go to state 28
    IF              shift and go to state 29
    FOR             shift and go to state 30
    SWITCH          shift and go to state 31
    VAR             shift and go to state 32
    FUNCTION        shift and go to state 33
    FN              shift and go to state 35
    ECHO            shift and go to state 36
    PRINT           shift and go to state 38
    ID              shift and go to state 34
    INTEGER         shift and go to state 40
    FLOAT           shift and go to state 41

    programa                       shift and go to state 224
    cuerpo                         shift and go to state 2
    arithmeticExpression           shift and go to state 3
    if_elseStatement               shift and go to state 4
    forStatement                   shift and go to state 5
    switchStatement                shift and go to state 6
    arrayAsignation                shift and go to state 7
    queueDeclaration               shift and go to state 8
    queueEnqueue                   shift and go to state 9
    queueDequeue                   shift and go to state 10
    defineFunction                 shift and go to state 11
    anonymousFunction              shift and go to state 12
    arrowFunction                  shift and go to state 13
    echo                           shift and go to state 14
    fgets                          shift and go to state 15
    stackDeclaration               shift and go to state 16
    stackPush                      shift and go to state 17
    stackPop                       shift and go to state 18
    line                           shift and go to state 19
    print                          shift and go to state 20
    logicalCondition               shift and go to state 21
    stringConcatenation            shift and go to state 24
    callFunction                   shift and go to state 25
    value                          shift and go to state 26
    variableAsignation             shift and go to state 37
    comparingValue                 shift and go to state 39

state 220

    (28) switchCase -> CASE value COLON . programa BREAK SEMICOLON
    (1) programa -> . cuerpo
    (2) programa -> . programa cuerpo
    (3) cuerpo -> . arithmeticExpression
    (4) cuerpo -> . if_elseStatement
    (5) cuerpo -> . forStatement
    (6) cuerpo -> . switchStatement
    (7) cuerpo -> . arrayAsignation
    (8) cuerpo -> . queueDeclaration
    (9) cuerpo -> . queueEnqueue
    (10) cuerpo -> . queueDequeue
    (11) cuerpo -> . defineFunction
    (12) cuerpo -> . anonymousFunction
    (13) cuerpo -> . arrowFunction
    (14) cuerpo -> . echo
    (15) cuerpo -> . fgets
    (16) cuerpo -> . stackDeclaration
    (17) cuerpo -> . stackPush
    (18) cuerpo -> . stackPop
    (19) cuerpo -> . line
    (20) cuerpo -> . print
    (21) cuerpo -> . logicalCondition
    (22) cuerpo -> . OPEN_TAG
    (23) cuerpo -> . CLOSE_TAG
    (24) cuerpo -> . stringConcatenation
    (25) cuerpo -> . callFunction
    (71) arithmeticExpression -> . value
    (72) arithmeticExpression -> . STRING
    (73) arithmeticExpression -> . LPAREN arithmeticExpression RPAREN
    (74) arithmeticExpression -> . arithmeticExpression arithmeticOperator arithmeticExpression
    (31) if_elseStatement -> . IF LPAREN logicalCondition RPAREN LCURLY ifStatementBody RCURLY ELSE LCURLY ifStatementBody RCURLY
    (32) if_elseStatement -> . IF LPAREN logicalCondition RPAREN LCURLY ifStatementBody
    (36) forStatement -> . FOR LPAREN forStatementCondition RPAREN LCURLY forStatementBody RCURLY
    (26) switchStatement -> . SWITCH LPAREN value RPAREN LCURLY switchCases switchDefault RCURLY
    (42) arrayAsignation -> . VAR EQUAL arrayDeclaration SEMICOLON
    (53) queueDeclaration -> . VAR EQUAL NEW QUEUE SEMICOLON
    (54) queueEnqueue -> . VAR OBJOP PUSH LPAREN value RPAREN SEMICOLON
    (55) queueDequeue -> . VAR OBJOP POP SEMICOLON
    (56) defineFunction -> . FUNCTION ID LPAREN arguments RPAREN LCURLY programa RCURLY
    (57) defineFunction -> . FUNCTION ID LPAREN RPAREN LCURLY programa RCURLY
    (60) anonymousFunction -> . FUNCTION LPAREN RPAREN LCURLY cuerpo RCURLY
    (61) anonymousFunction -> . FUNCTION LPAREN arguments RPAREN LCURLY cuerpo RCURLY
    (62) arrowFunction -> . FN LPAREN VAR RPAREN FNARROW arrowBody SEMICOLON
    (65) echo -> . ECHO values SEMICOLON
    (70) fgets -> . VAR EQUAL FGETS LPAREN STDIN RPAREN SEMICOLON
    (50) stackDeclaration -> . VAR EQUAL NEW STACK SEMICOLON
    (51) stackPush -> . VAR OBJOP PUSH LPAREN value RPAREN SEMICOLON
    (52) stackPop -> . VAR OBJOP POP SEMICOLON
    (88) line -> . variableAsignation SEMICOLON
    (66) print -> . PRINT LPAREN values RPAREN SEMICOLON
    (67) print -> . PRINT value SEMICOLON
    (103) logicalCondition -> . comparingValue
    (104) logicalCondition -> . comparingValue conditionOperator comparingValue
    (105) logicalCondition -> . LPAREN logicalCondition RPAREN
    (109) stringConcatenation -> . value CONCAT value
    (110) stringConcatenation -> . stringConcatenation CONCAT stringConcatenation
    (75) callFunction -> . ID LPAREN RPAREN SEMICOLON
    (76) callFunction -> . ID LPAREN value RPAREN SEMICOLON
    (77) value -> . VAR
    (78) value -> . INTEGER
    (79) value -> . FLOAT
    (80) value -> . STRING
    (81) value -> . stringConcatenation
    (89) variableAsignation -> . VAR EQUAL value
    (90) variableAsignation -> . VAR EQUAL arithmeticExpression
    (91) variableAsignation -> . VAR INCREMENT
    (92) variableAsignation -> . VAR DECREMENT
    (93) variableAsignation -> . VAR EQUAL stringConcatenation
    (94) variableAsignation -> . VAR EQUAL anonymousFunction
    (102) comparingValue -> . value comparingSign value

    OPEN_TAG        shift and go to state 22
    CLOSE_TAG       shift and go to state 23
    STRING          shift and go to state 27
    LPAREN          shift and go to state 28
    IF              shift and go to state 29
    FOR             shift and go to state 30
    SWITCH          shift and go to state 31
    VAR             shift and go to state 32
    FUNCTION        shift and go to state 33
    FN              shift and go to state 35
    ECHO            shift and go to state 36
    PRINT           shift and go to state 38
    ID              shift and go to state 34
    INTEGER         shift and go to state 40
    FLOAT           shift and go to state 41

    value                          shift and go to state 26
    programa                       shift and go to state 225
    cuerpo                         shift and go to state 2
    arithmeticExpression           shift and go to state 3
    if_elseStatement               shift and go to state 4
    forStatement                   shift and go to state 5
    switchStatement                shift and go to state 6
    arrayAsignation                shift and go to state 7
    queueDeclaration               shift and go to state 8
    queueEnqueue                   shift and go to state 9
    queueDequeue                   shift and go to state 10
    defineFunction                 shift and go to state 11
    anonymousFunction              shift and go to state 12
    arrowFunction                  shift and go to state 13
    echo                           shift and go to state 14
    fgets                          shift and go to state 15
    stackDeclaration               shift and go to state 16
    stackPush                      shift and go to state 17
    stackPop                       shift and go to state 18
    line                           shift and go to state 19
    print                          shift and go to state 20
    logicalCondition               shift and go to state 21
    stringConcatenation            shift and go to state 24
    callFunction                   shift and go to state 25
    variableAsignation             shift and go to state 37
    comparingValue                 shift and go to state 39

state 221

    (56) defineFunction -> FUNCTION ID LPAREN arguments RPAREN LCURLY programa RCURLY .

    OPEN_TAG        reduce using rule 56 (defineFunction -> FUNCTION ID LPAREN arguments RPAREN LCURLY programa RCURLY .)
    CLOSE_TAG       reduce using rule 56 (defineFunction -> FUNCTION ID LPAREN arguments RPAREN LCURLY programa RCURLY .)
    STRING          reduce using rule 56 (defineFunction -> FUNCTION ID LPAREN arguments RPAREN LCURLY programa RCURLY .)
    LPAREN          reduce using rule 56 (defineFunction -> FUNCTION ID LPAREN arguments RPAREN LCURLY programa RCURLY .)
    IF              reduce using rule 56 (defineFunction -> FUNCTION ID LPAREN arguments RPAREN LCURLY programa RCURLY .)
    FOR             reduce using rule 56 (defineFunction -> FUNCTION ID LPAREN arguments RPAREN LCURLY programa RCURLY .)
    SWITCH          reduce using rule 56 (defineFunction -> FUNCTION ID LPAREN arguments RPAREN LCURLY programa RCURLY .)
    VAR             reduce using rule 56 (defineFunction -> FUNCTION ID LPAREN arguments RPAREN LCURLY programa RCURLY .)
    FUNCTION        reduce using rule 56 (defineFunction -> FUNCTION ID LPAREN arguments RPAREN LCURLY programa RCURLY .)
    FN              reduce using rule 56 (defineFunction -> FUNCTION ID LPAREN arguments RPAREN LCURLY programa RCURLY .)
    ECHO            reduce using rule 56 (defineFunction -> FUNCTION ID LPAREN arguments RPAREN LCURLY programa RCURLY .)
    PRINT           reduce using rule 56 (defineFunction -> FUNCTION ID LPAREN arguments RPAREN LCURLY programa RCURLY .)
    ID              reduce using rule 56 (defineFunction -> FUNCTION ID LPAREN arguments RPAREN LCURLY programa RCURLY .)
    INTEGER         reduce using rule 56 (defineFunction -> FUNCTION ID LPAREN arguments RPAREN LCURLY programa RCURLY .)
    FLOAT           reduce using rule 56 (defineFunction -> FUNCTION ID LPAREN arguments RPAREN LCURLY programa RCURLY .)
    $end            reduce using rule 56 (defineFunction -> FUNCTION ID LPAREN arguments RPAREN LCURLY programa RCURLY .)
    RCURLY          reduce using rule 56 (defineFunction -> FUNCTION ID LPAREN arguments RPAREN LCURLY programa RCURLY .)
    CONTINUE        reduce using rule 56 (defineFunction -> FUNCTION ID LPAREN arguments RPAREN LCURLY programa RCURLY .)
    SEMICOLON       reduce using rule 56 (defineFunction -> FUNCTION ID LPAREN arguments RPAREN LCURLY programa RCURLY .)
    BREAK           reduce using rule 56 (defineFunction -> FUNCTION ID LPAREN arguments RPAREN LCURLY programa RCURLY .)


state 222

    (63) arrowBody -> FN LPAREN VAR . RPAREN FNARROW arrowBody
    (62) arrowFunction -> FN LPAREN VAR . RPAREN FNARROW arrowBody SEMICOLON

    RPAREN          shift and go to state 226


state 223

    (31) if_elseStatement -> IF LPAREN logicalCondition RPAREN LCURLY ifStatementBody RCURLY ELSE LCURLY . ifStatementBody RCURLY
    (33) ifStatementBody -> . cuerpo
    (34) ifStatementBody -> . cuerpo CONTINUE SEMICOLON
    (35) ifStatementBody -> . ifStatementBody cuerpo
    (3) cuerpo -> . arithmeticExpression
    (4) cuerpo -> . if_elseStatement
    (5) cuerpo -> . forStatement
    (6) cuerpo -> . switchStatement
    (7) cuerpo -> . arrayAsignation
    (8) cuerpo -> . queueDeclaration
    (9) cuerpo -> . queueEnqueue
    (10) cuerpo -> . queueDequeue
    (11) cuerpo -> . defineFunction
    (12) cuerpo -> . anonymousFunction
    (13) cuerpo -> . arrowFunction
    (14) cuerpo -> . echo
    (15) cuerpo -> . fgets
    (16) cuerpo -> . stackDeclaration
    (17) cuerpo -> . stackPush
    (18) cuerpo -> . stackPop
    (19) cuerpo -> . line
    (20) cuerpo -> . print
    (21) cuerpo -> . logicalCondition
    (22) cuerpo -> . OPEN_TAG
    (23) cuerpo -> . CLOSE_TAG
    (24) cuerpo -> . stringConcatenation
    (25) cuerpo -> . callFunction
    (71) arithmeticExpression -> . value
    (72) arithmeticExpression -> . STRING
    (73) arithmeticExpression -> . LPAREN arithmeticExpression RPAREN
    (74) arithmeticExpression -> . arithmeticExpression arithmeticOperator arithmeticExpression
    (31) if_elseStatement -> . IF LPAREN logicalCondition RPAREN LCURLY ifStatementBody RCURLY ELSE LCURLY ifStatementBody RCURLY
    (32) if_elseStatement -> . IF LPAREN logicalCondition RPAREN LCURLY ifStatementBody
    (36) forStatement -> . FOR LPAREN forStatementCondition RPAREN LCURLY forStatementBody RCURLY
    (26) switchStatement -> . SWITCH LPAREN value RPAREN LCURLY switchCases switchDefault RCURLY
    (42) arrayAsignation -> . VAR EQUAL arrayDeclaration SEMICOLON
    (53) queueDeclaration -> . VAR EQUAL NEW QUEUE SEMICOLON
    (54) queueEnqueue -> . VAR OBJOP PUSH LPAREN value RPAREN SEMICOLON
    (55) queueDequeue -> . VAR OBJOP POP SEMICOLON
    (56) defineFunction -> . FUNCTION ID LPAREN arguments RPAREN LCURLY programa RCURLY
    (57) defineFunction -> . FUNCTION ID LPAREN RPAREN LCURLY programa RCURLY
    (60) anonymousFunction -> . FUNCTION LPAREN RPAREN LCURLY cuerpo RCURLY
    (61) anonymousFunction -> . FUNCTION LPAREN arguments RPAREN LCURLY cuerpo RCURLY
    (62) arrowFunction -> . FN LPAREN VAR RPAREN FNARROW arrowBody SEMICOLON
    (65) echo -> . ECHO values SEMICOLON
    (70) fgets -> . VAR EQUAL FGETS LPAREN STDIN RPAREN SEMICOLON
    (50) stackDeclaration -> . VAR EQUAL NEW STACK SEMICOLON
    (51) stackPush -> . VAR OBJOP PUSH LPAREN value RPAREN SEMICOLON
    (52) stackPop -> . VAR OBJOP POP SEMICOLON
    (88) line -> . variableAsignation SEMICOLON
    (66) print -> . PRINT LPAREN values RPAREN SEMICOLON
    (67) print -> . PRINT value SEMICOLON
    (103) logicalCondition -> . comparingValue
    (104) logicalCondition -> . comparingValue conditionOperator comparingValue
    (105) logicalCondition -> . LPAREN logicalCondition RPAREN
    (109) stringConcatenation -> . value CONCAT value
    (110) stringConcatenation -> . stringConcatenation CONCAT stringConcatenation
    (75) callFunction -> . ID LPAREN RPAREN SEMICOLON
    (76) callFunction -> . ID LPAREN value RPAREN SEMICOLON
    (77) value -> . VAR
    (78) value -> . INTEGER
    (79) value -> . FLOAT
    (80) value -> . STRING
    (81) value -> . stringConcatenation
    (89) variableAsignation -> . VAR EQUAL value
    (90) variableAsignation -> . VAR EQUAL arithmeticExpression
    (91) variableAsignation -> . VAR INCREMENT
    (92) variableAsignation -> . VAR DECREMENT
    (93) variableAsignation -> . VAR EQUAL stringConcatenation
    (94) variableAsignation -> . VAR EQUAL anonymousFunction
    (102) comparingValue -> . value comparingSign value

    OPEN_TAG        shift and go to state 22
    CLOSE_TAG       shift and go to state 23
    STRING          shift and go to state 27
    LPAREN          shift and go to state 28
    IF              shift and go to state 29
    FOR             shift and go to state 30
    SWITCH          shift and go to state 31
    VAR             shift and go to state 32
    FUNCTION        shift and go to state 33
    FN              shift and go to state 35
    ECHO            shift and go to state 36
    PRINT           shift and go to state 38
    ID              shift and go to state 34
    INTEGER         shift and go to state 40
    FLOAT           shift and go to state 41

    logicalCondition               shift and go to state 21
    ifStatementBody                shift and go to state 227
    cuerpo                         shift and go to state 181
    arithmeticExpression           shift and go to state 3
    if_elseStatement               shift and go to state 4
    forStatement                   shift and go to state 5
    switchStatement                shift and go to state 6
    arrayAsignation                shift and go to state 7
    queueDeclaration               shift and go to state 8
    queueEnqueue                   shift and go to state 9
    queueDequeue                   shift and go to state 10
    defineFunction                 shift and go to state 11
    anonymousFunction              shift and go to state 12
    arrowFunction                  shift and go to state 13
    echo                           shift and go to state 14
    fgets                          shift and go to state 15
    stackDeclaration               shift and go to state 16
    stackPush                      shift and go to state 17
    stackPop                       shift and go to state 18
    line                           shift and go to state 19
    print                          shift and go to state 20
    stringConcatenation            shift and go to state 24
    callFunction                   shift and go to state 25
    value                          shift and go to state 26
    variableAsignation             shift and go to state 37
    comparingValue                 shift and go to state 39

state 224

    (27) switchDefault -> DEFAULT COLON programa .
    (2) programa -> programa . cuerpo
    (3) cuerpo -> . arithmeticExpression
    (4) cuerpo -> . if_elseStatement
    (5) cuerpo -> . forStatement
    (6) cuerpo -> . switchStatement
    (7) cuerpo -> . arrayAsignation
    (8) cuerpo -> . queueDeclaration
    (9) cuerpo -> . queueEnqueue
    (10) cuerpo -> . queueDequeue
    (11) cuerpo -> . defineFunction
    (12) cuerpo -> . anonymousFunction
    (13) cuerpo -> . arrowFunction
    (14) cuerpo -> . echo
    (15) cuerpo -> . fgets
    (16) cuerpo -> . stackDeclaration
    (17) cuerpo -> . stackPush
    (18) cuerpo -> . stackPop
    (19) cuerpo -> . line
    (20) cuerpo -> . print
    (21) cuerpo -> . logicalCondition
    (22) cuerpo -> . OPEN_TAG
    (23) cuerpo -> . CLOSE_TAG
    (24) cuerpo -> . stringConcatenation
    (25) cuerpo -> . callFunction
    (71) arithmeticExpression -> . value
    (72) arithmeticExpression -> . STRING
    (73) arithmeticExpression -> . LPAREN arithmeticExpression RPAREN
    (74) arithmeticExpression -> . arithmeticExpression arithmeticOperator arithmeticExpression
    (31) if_elseStatement -> . IF LPAREN logicalCondition RPAREN LCURLY ifStatementBody RCURLY ELSE LCURLY ifStatementBody RCURLY
    (32) if_elseStatement -> . IF LPAREN logicalCondition RPAREN LCURLY ifStatementBody
    (36) forStatement -> . FOR LPAREN forStatementCondition RPAREN LCURLY forStatementBody RCURLY
    (26) switchStatement -> . SWITCH LPAREN value RPAREN LCURLY switchCases switchDefault RCURLY
    (42) arrayAsignation -> . VAR EQUAL arrayDeclaration SEMICOLON
    (53) queueDeclaration -> . VAR EQUAL NEW QUEUE SEMICOLON
    (54) queueEnqueue -> . VAR OBJOP PUSH LPAREN value RPAREN SEMICOLON
    (55) queueDequeue -> . VAR OBJOP POP SEMICOLON
    (56) defineFunction -> . FUNCTION ID LPAREN arguments RPAREN LCURLY programa RCURLY
    (57) defineFunction -> . FUNCTION ID LPAREN RPAREN LCURLY programa RCURLY
    (60) anonymousFunction -> . FUNCTION LPAREN RPAREN LCURLY cuerpo RCURLY
    (61) anonymousFunction -> . FUNCTION LPAREN arguments RPAREN LCURLY cuerpo RCURLY
    (62) arrowFunction -> . FN LPAREN VAR RPAREN FNARROW arrowBody SEMICOLON
    (65) echo -> . ECHO values SEMICOLON
    (70) fgets -> . VAR EQUAL FGETS LPAREN STDIN RPAREN SEMICOLON
    (50) stackDeclaration -> . VAR EQUAL NEW STACK SEMICOLON
    (51) stackPush -> . VAR OBJOP PUSH LPAREN value RPAREN SEMICOLON
    (52) stackPop -> . VAR OBJOP POP SEMICOLON
    (88) line -> . variableAsignation SEMICOLON
    (66) print -> . PRINT LPAREN values RPAREN SEMICOLON
    (67) print -> . PRINT value SEMICOLON
    (103) logicalCondition -> . comparingValue
    (104) logicalCondition -> . comparingValue conditionOperator comparingValue
    (105) logicalCondition -> . LPAREN logicalCondition RPAREN
    (109) stringConcatenation -> . value CONCAT value
    (110) stringConcatenation -> . stringConcatenation CONCAT stringConcatenation
    (75) callFunction -> . ID LPAREN RPAREN SEMICOLON
    (76) callFunction -> . ID LPAREN value RPAREN SEMICOLON
    (77) value -> . VAR
    (78) value -> . INTEGER
    (79) value -> . FLOAT
    (80) value -> . STRING
    (81) value -> . stringConcatenation
    (89) variableAsignation -> . VAR EQUAL value
    (90) variableAsignation -> . VAR EQUAL arithmeticExpression
    (91) variableAsignation -> . VAR INCREMENT
    (92) variableAsignation -> . VAR DECREMENT
    (93) variableAsignation -> . VAR EQUAL stringConcatenation
    (94) variableAsignation -> . VAR EQUAL anonymousFunction
    (102) comparingValue -> . value comparingSign value

    RCURLY          reduce using rule 27 (switchDefault -> DEFAULT COLON programa .)
    OPEN_TAG        shift and go to state 22
    CLOSE_TAG       shift and go to state 23
    STRING          shift and go to state 27
    LPAREN          shift and go to state 28
    IF              shift and go to state 29
    FOR             shift and go to state 30
    SWITCH          shift and go to state 31
    VAR             shift and go to state 32
    FUNCTION        shift and go to state 33
    FN              shift and go to state 35
    ECHO            shift and go to state 36
    PRINT           shift and go to state 38
    ID              shift and go to state 34
    INTEGER         shift and go to state 40
    FLOAT           shift and go to state 41

    cuerpo                         shift and go to state 42
    arithmeticExpression           shift and go to state 3
    if_elseStatement               shift and go to state 4
    forStatement                   shift and go to state 5
    switchStatement                shift and go to state 6
    arrayAsignation                shift and go to state 7
    queueDeclaration               shift and go to state 8
    queueEnqueue                   shift and go to state 9
    queueDequeue                   shift and go to state 10
    defineFunction                 shift and go to state 11
    anonymousFunction              shift and go to state 12
    arrowFunction                  shift and go to state 13
    echo                           shift and go to state 14
    fgets                          shift and go to state 15
    stackDeclaration               shift and go to state 16
    stackPush                      shift and go to state 17
    stackPop                       shift and go to state 18
    line                           shift and go to state 19
    print                          shift and go to state 20
    logicalCondition               shift and go to state 21
    stringConcatenation            shift and go to state 24
    callFunction                   shift and go to state 25
    value                          shift and go to state 26
    variableAsignation             shift and go to state 37
    comparingValue                 shift and go to state 39

state 225

    (28) switchCase -> CASE value COLON programa . BREAK SEMICOLON
    (2) programa -> programa . cuerpo
    (3) cuerpo -> . arithmeticExpression
    (4) cuerpo -> . if_elseStatement
    (5) cuerpo -> . forStatement
    (6) cuerpo -> . switchStatement
    (7) cuerpo -> . arrayAsignation
    (8) cuerpo -> . queueDeclaration
    (9) cuerpo -> . queueEnqueue
    (10) cuerpo -> . queueDequeue
    (11) cuerpo -> . defineFunction
    (12) cuerpo -> . anonymousFunction
    (13) cuerpo -> . arrowFunction
    (14) cuerpo -> . echo
    (15) cuerpo -> . fgets
    (16) cuerpo -> . stackDeclaration
    (17) cuerpo -> . stackPush
    (18) cuerpo -> . stackPop
    (19) cuerpo -> . line
    (20) cuerpo -> . print
    (21) cuerpo -> . logicalCondition
    (22) cuerpo -> . OPEN_TAG
    (23) cuerpo -> . CLOSE_TAG
    (24) cuerpo -> . stringConcatenation
    (25) cuerpo -> . callFunction
    (71) arithmeticExpression -> . value
    (72) arithmeticExpression -> . STRING
    (73) arithmeticExpression -> . LPAREN arithmeticExpression RPAREN
    (74) arithmeticExpression -> . arithmeticExpression arithmeticOperator arithmeticExpression
    (31) if_elseStatement -> . IF LPAREN logicalCondition RPAREN LCURLY ifStatementBody RCURLY ELSE LCURLY ifStatementBody RCURLY
    (32) if_elseStatement -> . IF LPAREN logicalCondition RPAREN LCURLY ifStatementBody
    (36) forStatement -> . FOR LPAREN forStatementCondition RPAREN LCURLY forStatementBody RCURLY
    (26) switchStatement -> . SWITCH LPAREN value RPAREN LCURLY switchCases switchDefault RCURLY
    (42) arrayAsignation -> . VAR EQUAL arrayDeclaration SEMICOLON
    (53) queueDeclaration -> . VAR EQUAL NEW QUEUE SEMICOLON
    (54) queueEnqueue -> . VAR OBJOP PUSH LPAREN value RPAREN SEMICOLON
    (55) queueDequeue -> . VAR OBJOP POP SEMICOLON
    (56) defineFunction -> . FUNCTION ID LPAREN arguments RPAREN LCURLY programa RCURLY
    (57) defineFunction -> . FUNCTION ID LPAREN RPAREN LCURLY programa RCURLY
    (60) anonymousFunction -> . FUNCTION LPAREN RPAREN LCURLY cuerpo RCURLY
    (61) anonymousFunction -> . FUNCTION LPAREN arguments RPAREN LCURLY cuerpo RCURLY
    (62) arrowFunction -> . FN LPAREN VAR RPAREN FNARROW arrowBody SEMICOLON
    (65) echo -> . ECHO values SEMICOLON
    (70) fgets -> . VAR EQUAL FGETS LPAREN STDIN RPAREN SEMICOLON
    (50) stackDeclaration -> . VAR EQUAL NEW STACK SEMICOLON
    (51) stackPush -> . VAR OBJOP PUSH LPAREN value RPAREN SEMICOLON
    (52) stackPop -> . VAR OBJOP POP SEMICOLON
    (88) line -> . variableAsignation SEMICOLON
    (66) print -> . PRINT LPAREN values RPAREN SEMICOLON
    (67) print -> . PRINT value SEMICOLON
    (103) logicalCondition -> . comparingValue
    (104) logicalCondition -> . comparingValue conditionOperator comparingValue
    (105) logicalCondition -> . LPAREN logicalCondition RPAREN
    (109) stringConcatenation -> . value CONCAT value
    (110) stringConcatenation -> . stringConcatenation CONCAT stringConcatenation
    (75) callFunction -> . ID LPAREN RPAREN SEMICOLON
    (76) callFunction -> . ID LPAREN value RPAREN SEMICOLON
    (77) value -> . VAR
    (78) value -> . INTEGER
    (79) value -> . FLOAT
    (80) value -> . STRING
    (81) value -> . stringConcatenation
    (89) variableAsignation -> . VAR EQUAL value
    (90) variableAsignation -> . VAR EQUAL arithmeticExpression
    (91) variableAsignation -> . VAR INCREMENT
    (92) variableAsignation -> . VAR DECREMENT
    (93) variableAsignation -> . VAR EQUAL stringConcatenation
    (94) variableAsignation -> . VAR EQUAL anonymousFunction
    (102) comparingValue -> . value comparingSign value

    BREAK           shift and go to state 228
    OPEN_TAG        shift and go to state 22
    CLOSE_TAG       shift and go to state 23
    STRING          shift and go to state 27
    LPAREN          shift and go to state 28
    IF              shift and go to state 29
    FOR             shift and go to state 30
    SWITCH          shift and go to state 31
    VAR             shift and go to state 32
    FUNCTION        shift and go to state 33
    FN              shift and go to state 35
    ECHO            shift and go to state 36
    PRINT           shift and go to state 38
    ID              shift and go to state 34
    INTEGER         shift and go to state 40
    FLOAT           shift and go to state 41

    value                          shift and go to state 26
    cuerpo                         shift and go to state 42
    arithmeticExpression           shift and go to state 3
    if_elseStatement               shift and go to state 4
    forStatement                   shift and go to state 5
    switchStatement                shift and go to state 6
    arrayAsignation                shift and go to state 7
    queueDeclaration               shift and go to state 8
    queueEnqueue                   shift and go to state 9
    queueDequeue                   shift and go to state 10
    defineFunction                 shift and go to state 11
    anonymousFunction              shift and go to state 12
    arrowFunction                  shift and go to state 13
    echo                           shift and go to state 14
    fgets                          shift and go to state 15
    stackDeclaration               shift and go to state 16
    stackPush                      shift and go to state 17
    stackPop                       shift and go to state 18
    line                           shift and go to state 19
    print                          shift and go to state 20
    logicalCondition               shift and go to state 21
    stringConcatenation            shift and go to state 24
    callFunction                   shift and go to state 25
    variableAsignation             shift and go to state 37
    comparingValue                 shift and go to state 39

state 226

    (63) arrowBody -> FN LPAREN VAR RPAREN . FNARROW arrowBody
    (62) arrowFunction -> FN LPAREN VAR RPAREN . FNARROW arrowBody SEMICOLON

    FNARROW         shift and go to state 229


state 227

    (31) if_elseStatement -> IF LPAREN logicalCondition RPAREN LCURLY ifStatementBody RCURLY ELSE LCURLY ifStatementBody . RCURLY
    (35) ifStatementBody -> ifStatementBody . cuerpo
    (3) cuerpo -> . arithmeticExpression
    (4) cuerpo -> . if_elseStatement
    (5) cuerpo -> . forStatement
    (6) cuerpo -> . switchStatement
    (7) cuerpo -> . arrayAsignation
    (8) cuerpo -> . queueDeclaration
    (9) cuerpo -> . queueEnqueue
    (10) cuerpo -> . queueDequeue
    (11) cuerpo -> . defineFunction
    (12) cuerpo -> . anonymousFunction
    (13) cuerpo -> . arrowFunction
    (14) cuerpo -> . echo
    (15) cuerpo -> . fgets
    (16) cuerpo -> . stackDeclaration
    (17) cuerpo -> . stackPush
    (18) cuerpo -> . stackPop
    (19) cuerpo -> . line
    (20) cuerpo -> . print
    (21) cuerpo -> . logicalCondition
    (22) cuerpo -> . OPEN_TAG
    (23) cuerpo -> . CLOSE_TAG
    (24) cuerpo -> . stringConcatenation
    (25) cuerpo -> . callFunction
    (71) arithmeticExpression -> . value
    (72) arithmeticExpression -> . STRING
    (73) arithmeticExpression -> . LPAREN arithmeticExpression RPAREN
    (74) arithmeticExpression -> . arithmeticExpression arithmeticOperator arithmeticExpression
    (31) if_elseStatement -> . IF LPAREN logicalCondition RPAREN LCURLY ifStatementBody RCURLY ELSE LCURLY ifStatementBody RCURLY
    (32) if_elseStatement -> . IF LPAREN logicalCondition RPAREN LCURLY ifStatementBody
    (36) forStatement -> . FOR LPAREN forStatementCondition RPAREN LCURLY forStatementBody RCURLY
    (26) switchStatement -> . SWITCH LPAREN value RPAREN LCURLY switchCases switchDefault RCURLY
    (42) arrayAsignation -> . VAR EQUAL arrayDeclaration SEMICOLON
    (53) queueDeclaration -> . VAR EQUAL NEW QUEUE SEMICOLON
    (54) queueEnqueue -> . VAR OBJOP PUSH LPAREN value RPAREN SEMICOLON
    (55) queueDequeue -> . VAR OBJOP POP SEMICOLON
    (56) defineFunction -> . FUNCTION ID LPAREN arguments RPAREN LCURLY programa RCURLY
    (57) defineFunction -> . FUNCTION ID LPAREN RPAREN LCURLY programa RCURLY
    (60) anonymousFunction -> . FUNCTION LPAREN RPAREN LCURLY cuerpo RCURLY
    (61) anonymousFunction -> . FUNCTION LPAREN arguments RPAREN LCURLY cuerpo RCURLY
    (62) arrowFunction -> . FN LPAREN VAR RPAREN FNARROW arrowBody SEMICOLON
    (65) echo -> . ECHO values SEMICOLON
    (70) fgets -> . VAR EQUAL FGETS LPAREN STDIN RPAREN SEMICOLON
    (50) stackDeclaration -> . VAR EQUAL NEW STACK SEMICOLON
    (51) stackPush -> . VAR OBJOP PUSH LPAREN value RPAREN SEMICOLON
    (52) stackPop -> . VAR OBJOP POP SEMICOLON
    (88) line -> . variableAsignation SEMICOLON
    (66) print -> . PRINT LPAREN values RPAREN SEMICOLON
    (67) print -> . PRINT value SEMICOLON
    (103) logicalCondition -> . comparingValue
    (104) logicalCondition -> . comparingValue conditionOperator comparingValue
    (105) logicalCondition -> . LPAREN logicalCondition RPAREN
    (109) stringConcatenation -> . value CONCAT value
    (110) stringConcatenation -> . stringConcatenation CONCAT stringConcatenation
    (75) callFunction -> . ID LPAREN RPAREN SEMICOLON
    (76) callFunction -> . ID LPAREN value RPAREN SEMICOLON
    (77) value -> . VAR
    (78) value -> . INTEGER
    (79) value -> . FLOAT
    (80) value -> . STRING
    (81) value -> . stringConcatenation
    (89) variableAsignation -> . VAR EQUAL value
    (90) variableAsignation -> . VAR EQUAL arithmeticExpression
    (91) variableAsignation -> . VAR INCREMENT
    (92) variableAsignation -> . VAR DECREMENT
    (93) variableAsignation -> . VAR EQUAL stringConcatenation
    (94) variableAsignation -> . VAR EQUAL anonymousFunction
    (102) comparingValue -> . value comparingSign value

    RCURLY          shift and go to state 230
    OPEN_TAG        shift and go to state 22
    CLOSE_TAG       shift and go to state 23
    STRING          shift and go to state 27
    LPAREN          shift and go to state 28
    IF              shift and go to state 29
    FOR             shift and go to state 30
    SWITCH          shift and go to state 31
    VAR             shift and go to state 32
    FUNCTION        shift and go to state 33
    FN              shift and go to state 35
    ECHO            shift and go to state 36
    PRINT           shift and go to state 38
    ID              shift and go to state 34
    INTEGER         shift and go to state 40
    FLOAT           shift and go to state 41

    logicalCondition               shift and go to state 21
    cuerpo                         shift and go to state 200
    arithmeticExpression           shift and go to state 3
    if_elseStatement               shift and go to state 4
    forStatement                   shift and go to state 5
    switchStatement                shift and go to state 6
    arrayAsignation                shift and go to state 7
    queueDeclaration               shift and go to state 8
    queueEnqueue                   shift and go to state 9
    queueDequeue                   shift and go to state 10
    defineFunction                 shift and go to state 11
    anonymousFunction              shift and go to state 12
    arrowFunction                  shift and go to state 13
    echo                           shift and go to state 14
    fgets                          shift and go to state 15
    stackDeclaration               shift and go to state 16
    stackPush                      shift and go to state 17
    stackPop                       shift and go to state 18
    line                           shift and go to state 19
    print                          shift and go to state 20
    stringConcatenation            shift and go to state 24
    callFunction                   shift and go to state 25
    value                          shift and go to state 26
    variableAsignation             shift and go to state 37
    comparingValue                 shift and go to state 39

state 228

    (28) switchCase -> CASE value COLON programa BREAK . SEMICOLON

    SEMICOLON       shift and go to state 231


state 229

    (63) arrowBody -> FN LPAREN VAR RPAREN FNARROW . arrowBody
    (62) arrowFunction -> FN LPAREN VAR RPAREN FNARROW . arrowBody SEMICOLON
    (63) arrowBody -> . FN LPAREN VAR RPAREN FNARROW arrowBody
    (64) arrowBody -> . cuerpo
    (3) cuerpo -> . arithmeticExpression
    (4) cuerpo -> . if_elseStatement
    (5) cuerpo -> . forStatement
    (6) cuerpo -> . switchStatement
    (7) cuerpo -> . arrayAsignation
    (8) cuerpo -> . queueDeclaration
    (9) cuerpo -> . queueEnqueue
    (10) cuerpo -> . queueDequeue
    (11) cuerpo -> . defineFunction
    (12) cuerpo -> . anonymousFunction
    (13) cuerpo -> . arrowFunction
    (14) cuerpo -> . echo
    (15) cuerpo -> . fgets
    (16) cuerpo -> . stackDeclaration
    (17) cuerpo -> . stackPush
    (18) cuerpo -> . stackPop
    (19) cuerpo -> . line
    (20) cuerpo -> . print
    (21) cuerpo -> . logicalCondition
    (22) cuerpo -> . OPEN_TAG
    (23) cuerpo -> . CLOSE_TAG
    (24) cuerpo -> . stringConcatenation
    (25) cuerpo -> . callFunction
    (71) arithmeticExpression -> . value
    (72) arithmeticExpression -> . STRING
    (73) arithmeticExpression -> . LPAREN arithmeticExpression RPAREN
    (74) arithmeticExpression -> . arithmeticExpression arithmeticOperator arithmeticExpression
    (31) if_elseStatement -> . IF LPAREN logicalCondition RPAREN LCURLY ifStatementBody RCURLY ELSE LCURLY ifStatementBody RCURLY
    (32) if_elseStatement -> . IF LPAREN logicalCondition RPAREN LCURLY ifStatementBody
    (36) forStatement -> . FOR LPAREN forStatementCondition RPAREN LCURLY forStatementBody RCURLY
    (26) switchStatement -> . SWITCH LPAREN value RPAREN LCURLY switchCases switchDefault RCURLY
    (42) arrayAsignation -> . VAR EQUAL arrayDeclaration SEMICOLON
    (53) queueDeclaration -> . VAR EQUAL NEW QUEUE SEMICOLON
    (54) queueEnqueue -> . VAR OBJOP PUSH LPAREN value RPAREN SEMICOLON
    (55) queueDequeue -> . VAR OBJOP POP SEMICOLON
    (56) defineFunction -> . FUNCTION ID LPAREN arguments RPAREN LCURLY programa RCURLY
    (57) defineFunction -> . FUNCTION ID LPAREN RPAREN LCURLY programa RCURLY
    (60) anonymousFunction -> . FUNCTION LPAREN RPAREN LCURLY cuerpo RCURLY
    (61) anonymousFunction -> . FUNCTION LPAREN arguments RPAREN LCURLY cuerpo RCURLY
    (62) arrowFunction -> . FN LPAREN VAR RPAREN FNARROW arrowBody SEMICOLON
    (65) echo -> . ECHO values SEMICOLON
    (70) fgets -> . VAR EQUAL FGETS LPAREN STDIN RPAREN SEMICOLON
    (50) stackDeclaration -> . VAR EQUAL NEW STACK SEMICOLON
    (51) stackPush -> . VAR OBJOP PUSH LPAREN value RPAREN SEMICOLON
    (52) stackPop -> . VAR OBJOP POP SEMICOLON
    (88) line -> . variableAsignation SEMICOLON
    (66) print -> . PRINT LPAREN values RPAREN SEMICOLON
    (67) print -> . PRINT value SEMICOLON
    (103) logicalCondition -> . comparingValue
    (104) logicalCondition -> . comparingValue conditionOperator comparingValue
    (105) logicalCondition -> . LPAREN logicalCondition RPAREN
    (109) stringConcatenation -> . value CONCAT value
    (110) stringConcatenation -> . stringConcatenation CONCAT stringConcatenation
    (75) callFunction -> . ID LPAREN RPAREN SEMICOLON
    (76) callFunction -> . ID LPAREN value RPAREN SEMICOLON
    (77) value -> . VAR
    (78) value -> . INTEGER
    (79) value -> . FLOAT
    (80) value -> . STRING
    (81) value -> . stringConcatenation
    (89) variableAsignation -> . VAR EQUAL value
    (90) variableAsignation -> . VAR EQUAL arithmeticExpression
    (91) variableAsignation -> . VAR INCREMENT
    (92) variableAsignation -> . VAR DECREMENT
    (93) variableAsignation -> . VAR EQUAL stringConcatenation
    (94) variableAsignation -> . VAR EQUAL anonymousFunction
    (102) comparingValue -> . value comparingSign value

    FN              shift and go to state 196
    OPEN_TAG        shift and go to state 22
    CLOSE_TAG       shift and go to state 23
    STRING          shift and go to state 27
    LPAREN          shift and go to state 28
    IF              shift and go to state 29
    FOR             shift and go to state 30
    SWITCH          shift and go to state 31
    VAR             shift and go to state 32
    FUNCTION        shift and go to state 33
    ECHO            shift and go to state 36
    PRINT           shift and go to state 38
    ID              shift and go to state 34
    INTEGER         shift and go to state 40
    FLOAT           shift and go to state 41

    arrowBody                      shift and go to state 232
    cuerpo                         shift and go to state 198
    arithmeticExpression           shift and go to state 3
    if_elseStatement               shift and go to state 4
    forStatement                   shift and go to state 5
    switchStatement                shift and go to state 6
    arrayAsignation                shift and go to state 7
    queueDeclaration               shift and go to state 8
    queueEnqueue                   shift and go to state 9
    queueDequeue                   shift and go to state 10
    defineFunction                 shift and go to state 11
    anonymousFunction              shift and go to state 12
    arrowFunction                  shift and go to state 13
    echo                           shift and go to state 14
    fgets                          shift and go to state 15
    stackDeclaration               shift and go to state 16
    stackPush                      shift and go to state 17
    stackPop                       shift and go to state 18
    line                           shift and go to state 19
    print                          shift and go to state 20
    logicalCondition               shift and go to state 21
    stringConcatenation            shift and go to state 24
    callFunction                   shift and go to state 25
    value                          shift and go to state 26
    variableAsignation             shift and go to state 37
    comparingValue                 shift and go to state 39

state 230

    (31) if_elseStatement -> IF LPAREN logicalCondition RPAREN LCURLY ifStatementBody RCURLY ELSE LCURLY ifStatementBody RCURLY .

    OPEN_TAG        reduce using rule 31 (if_elseStatement -> IF LPAREN logicalCondition RPAREN LCURLY ifStatementBody RCURLY ELSE LCURLY ifStatementBody RCURLY .)
    CLOSE_TAG       reduce using rule 31 (if_elseStatement -> IF LPAREN logicalCondition RPAREN LCURLY ifStatementBody RCURLY ELSE LCURLY ifStatementBody RCURLY .)
    STRING          reduce using rule 31 (if_elseStatement -> IF LPAREN logicalCondition RPAREN LCURLY ifStatementBody RCURLY ELSE LCURLY ifStatementBody RCURLY .)
    LPAREN          reduce using rule 31 (if_elseStatement -> IF LPAREN logicalCondition RPAREN LCURLY ifStatementBody RCURLY ELSE LCURLY ifStatementBody RCURLY .)
    IF              reduce using rule 31 (if_elseStatement -> IF LPAREN logicalCondition RPAREN LCURLY ifStatementBody RCURLY ELSE LCURLY ifStatementBody RCURLY .)
    FOR             reduce using rule 31 (if_elseStatement -> IF LPAREN logicalCondition RPAREN LCURLY ifStatementBody RCURLY ELSE LCURLY ifStatementBody RCURLY .)
    SWITCH          reduce using rule 31 (if_elseStatement -> IF LPAREN logicalCondition RPAREN LCURLY ifStatementBody RCURLY ELSE LCURLY ifStatementBody RCURLY .)
    VAR             reduce using rule 31 (if_elseStatement -> IF LPAREN logicalCondition RPAREN LCURLY ifStatementBody RCURLY ELSE LCURLY ifStatementBody RCURLY .)
    FUNCTION        reduce using rule 31 (if_elseStatement -> IF LPAREN logicalCondition RPAREN LCURLY ifStatementBody RCURLY ELSE LCURLY ifStatementBody RCURLY .)
    FN              reduce using rule 31 (if_elseStatement -> IF LPAREN logicalCondition RPAREN LCURLY ifStatementBody RCURLY ELSE LCURLY ifStatementBody RCURLY .)
    ECHO            reduce using rule 31 (if_elseStatement -> IF LPAREN logicalCondition RPAREN LCURLY ifStatementBody RCURLY ELSE LCURLY ifStatementBody RCURLY .)
    PRINT           reduce using rule 31 (if_elseStatement -> IF LPAREN logicalCondition RPAREN LCURLY ifStatementBody RCURLY ELSE LCURLY ifStatementBody RCURLY .)
    ID              reduce using rule 31 (if_elseStatement -> IF LPAREN logicalCondition RPAREN LCURLY ifStatementBody RCURLY ELSE LCURLY ifStatementBody RCURLY .)
    INTEGER         reduce using rule 31 (if_elseStatement -> IF LPAREN logicalCondition RPAREN LCURLY ifStatementBody RCURLY ELSE LCURLY ifStatementBody RCURLY .)
    FLOAT           reduce using rule 31 (if_elseStatement -> IF LPAREN logicalCondition RPAREN LCURLY ifStatementBody RCURLY ELSE LCURLY ifStatementBody RCURLY .)
    $end            reduce using rule 31 (if_elseStatement -> IF LPAREN logicalCondition RPAREN LCURLY ifStatementBody RCURLY ELSE LCURLY ifStatementBody RCURLY .)
    RCURLY          reduce using rule 31 (if_elseStatement -> IF LPAREN logicalCondition RPAREN LCURLY ifStatementBody RCURLY ELSE LCURLY ifStatementBody RCURLY .)
    CONTINUE        reduce using rule 31 (if_elseStatement -> IF LPAREN logicalCondition RPAREN LCURLY ifStatementBody RCURLY ELSE LCURLY ifStatementBody RCURLY .)
    SEMICOLON       reduce using rule 31 (if_elseStatement -> IF LPAREN logicalCondition RPAREN LCURLY ifStatementBody RCURLY ELSE LCURLY ifStatementBody RCURLY .)
    BREAK           reduce using rule 31 (if_elseStatement -> IF LPAREN logicalCondition RPAREN LCURLY ifStatementBody RCURLY ELSE LCURLY ifStatementBody RCURLY .)


state 231

    (28) switchCase -> CASE value COLON programa BREAK SEMICOLON .

    DEFAULT         reduce using rule 28 (switchCase -> CASE value COLON programa BREAK SEMICOLON .)
    CASE            reduce using rule 28 (switchCase -> CASE value COLON programa BREAK SEMICOLON .)


state 232

    (63) arrowBody -> FN LPAREN VAR RPAREN FNARROW arrowBody .
    (62) arrowFunction -> FN LPAREN VAR RPAREN FNARROW arrowBody . SEMICOLON

  ! shift/reduce conflict for SEMICOLON resolved as shift
    SEMICOLON       shift and go to state 215

  ! SEMICOLON       [ reduce using rule 63 (arrowBody -> FN LPAREN VAR RPAREN FNARROW arrowBody .) ]

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for CONCAT in state 24 resolved as shift
WARNING: shift/reduce conflict for CONCAT in state 64 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 86 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 86 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 86 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 86 resolved as shift
WARNING: shift/reduce conflict for MOD in state 86 resolved as shift
WARNING: shift/reduce conflict for EXP in state 86 resolved as shift
WARNING: shift/reduce conflict for CONCAT in state 89 resolved as shift
WARNING: shift/reduce conflict for CONCAT in state 89 resolved as shift
WARNING: shift/reduce conflict for CONCAT in state 91 resolved as shift
WARNING: shift/reduce conflict for CONCAT in state 108 resolved as shift
WARNING: shift/reduce conflict for RCURLY in state 180 resolved as shift
WARNING: shift/reduce conflict for OPEN_TAG in state 180 resolved as shift
WARNING: shift/reduce conflict for CLOSE_TAG in state 180 resolved as shift
WARNING: shift/reduce conflict for STRING in state 180 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 180 resolved as shift
WARNING: shift/reduce conflict for IF in state 180 resolved as shift
WARNING: shift/reduce conflict for FOR in state 180 resolved as shift
WARNING: shift/reduce conflict for SWITCH in state 180 resolved as shift
WARNING: shift/reduce conflict for VAR in state 180 resolved as shift
WARNING: shift/reduce conflict for FUNCTION in state 180 resolved as shift
WARNING: shift/reduce conflict for FN in state 180 resolved as shift
WARNING: shift/reduce conflict for ECHO in state 180 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 180 resolved as shift
WARNING: shift/reduce conflict for ID in state 180 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 180 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 180 resolved as shift
WARNING: shift/reduce conflict for CONTINUE in state 181 resolved as shift
WARNING: shift/reduce conflict for SEMICOLON in state 232 resolved as shift
WARNING: reduce/reduce conflict in state 24 resolved using rule (cuerpo -> stringConcatenation)
WARNING: rejected rule (value -> stringConcatenation) in state 24
WARNING: reduce/reduce conflict in state 27 resolved using rule (arithmeticExpression -> STRING)
WARNING: rejected rule (value -> STRING) in state 27
WARNING: reduce/reduce conflict in state 106 resolved using rule (arithmeticExpression -> value)
WARNING: rejected rule (variableAsignation -> VAR EQUAL value) in state 106
WARNING: reduce/reduce conflict in state 108 resolved using rule (value -> stringConcatenation)
WARNING: rejected rule (variableAsignation -> VAR EQUAL stringConcatenation) in state 108
WARNING: reduce/reduce conflict in state 113 resolved using rule (arithmeticExpression -> STRING)
WARNING: rejected rule (value -> STRING) in state 113
WARNING: reduce/reduce conflict in state 147 resolved using rule (stackPop -> VAR OBJOP POP SEMICOLON)
WARNING: rejected rule (queueDequeue -> VAR OBJOP POP SEMICOLON) in state 147
WARNING: reduce/reduce conflict in state 210 resolved using rule (stackPush -> VAR OBJOP PUSH LPAREN value RPAREN SEMICOLON)
WARNING: rejected rule (queueEnqueue -> VAR OBJOP PUSH LPAREN value RPAREN SEMICOLON) in state 210
WARNING: Rule (variableAsignation -> VAR EQUAL value) is never reduced
WARNING: Rule (variableAsignation -> VAR EQUAL stringConcatenation) is never reduced
WARNING: Rule (queueDequeue -> VAR OBJOP POP SEMICOLON) is never reduced
WARNING: Rule (queueEnqueue -> VAR OBJOP PUSH LPAREN value RPAREN SEMICOLON) is never reduced
