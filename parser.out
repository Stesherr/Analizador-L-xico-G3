Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    ABSTRACT
    AND
    ARRAY
    AS
    BITAND
    BITNOT
    BITOR
    CALLABLE
    CATCH
    CLASS
    CLONE
    CLOSE_TAG
    CONCAT
    CONCATASSIGN
    CONST
    CONTINUE
    DECLARE
    DECREMENT
    DIE
    DIVIDEASSIGN
    DO
    DOC_COMMENT
    ELSE
    ELSEIF
    EMPTY
    ENDWHILE
    ERRORCONTROL
    EVAL
    EXECUTION
    EXIT
    EXPASSIGN
    EXTENDS
    FINAL
    FINALLY
    FOR
    FOREACH
    FUNCTION
    GLOBAL
    GOTO
    GREATEREQUALTHAN
    GREATERTHAN
    IDENTICAL
    IF
    IMPLEMENTS
    INCLUDE
    INCLUDE_ONCE
    INCREMENT
    INSTANCEOF
    INSTEADOF
    INTERFACE
    ISSET
    IS_EQUAL
    LESSEQUALTHAN
    LESSTHAN
    LIST
    LOGICALNOT
    LSQUARE
    MATCH
    MINUSASSIGN
    MODASSIGN
    NAMESPACE
    NOTEQUAL
    OPEN_TAG
    OR
    PLUSASSIGN
    PRINT
    PRIVATE
    PROTECTED
    PUBLIC
    QUOTE
    REQUIRE
    REQUIRE_ONCE
    RETURN
    RSQUARE
    STACK
    STATIC
    THROW
    TIMESASSIGN
    TRAIT
    TRY
    UNSET
    USE
    VAR
    WHILE
    XOR
    YIELD
    YIELD_FROM
    __HALT_COMPILER

Grammar

Rule 0     S' -> programa
Rule 1     programa -> cuerpo
Rule 2     programa -> programa cuerpo
Rule 3     cuerpo -> arithmeticExpression
Rule 4     cuerpo -> switchStatement
Rule 5     cuerpo -> queueDeclaration
Rule 6     cuerpo -> queueEnqueue
Rule 7     cuerpo -> queueDequeue
Rule 8     cuerpo -> arrowFunction
Rule 9     cuerpo -> echo
Rule 10    cuerpo -> fgets
Rule 11    switchStatement -> SWITCH LPAREN value RPAREN LCURLY switchCases switchDefault RCURLY
Rule 12    switchDefault -> DEFAULT COLON arithmeticExpression
Rule 13    switchCase -> CASE value COLON arithmeticExpression BREAK SEMICOLON
Rule 14    switchCases -> switchCase
Rule 15    switchCases -> switchCases switchCase
Rule 16    queueDeclaration -> ID EQUAL NEW QUEUE SEMICOLON
Rule 17    queueEnqueue -> ID OBJOP PUSH LPAREN value RPAREN SEMICOLON
Rule 18    queueDequeue -> ID OBJOP POP SEMICOLON
Rule 19    arrowFunction -> FN LPAREN ID RPAREN FNARROW arrowBody SEMICOLON
Rule 20    arrowBody -> FN LPAREN ID RPAREN FNARROW arrowBody
Rule 21    arrowBody -> cuerpo
Rule 22    echo -> ECHO values SEMICOLON
Rule 23    values -> value
Rule 24    values -> values COMMA value
Rule 25    fgets -> ID EQUAL FGETS LPAREN STDIN RPAREN SEMICOLON
Rule 26    arithmeticExpression -> value arithmeticOperator value
Rule 27    value -> ID
Rule 28    value -> INTEGER
Rule 29    value -> FLOAT
Rule 30    value -> STRING
Rule 31    value -> BOOL
Rule 32    value -> NULL
Rule 33    arithmeticOperator -> PLUS
Rule 34    arithmeticOperator -> MINUS
Rule 35    arithmeticOperator -> TIMES
Rule 36    arithmeticOperator -> DIVIDE
Rule 37    arithmeticOperator -> MOD
Rule 38    arithmeticOperator -> EXP

Terminals, with rules where they appear

ABSTRACT             : 
AND                  : 
ARRAY                : 
AS                   : 
BITAND               : 
BITNOT               : 
BITOR                : 
BOOL                 : 31
BREAK                : 13
CALLABLE             : 
CASE                 : 13
CATCH                : 
CLASS                : 
CLONE                : 
CLOSE_TAG            : 
COLON                : 12 13
COMMA                : 24
CONCAT               : 
CONCATASSIGN         : 
CONST                : 
CONTINUE             : 
DECLARE              : 
DECREMENT            : 
DEFAULT              : 12
DIE                  : 
DIVIDE               : 36
DIVIDEASSIGN         : 
DO                   : 
DOC_COMMENT          : 
ECHO                 : 22
ELSE                 : 
ELSEIF               : 
EMPTY                : 
ENDWHILE             : 
EQUAL                : 16 25
ERRORCONTROL         : 
EVAL                 : 
EXECUTION            : 
EXIT                 : 
EXP                  : 38
EXPASSIGN            : 
EXTENDS              : 
FGETS                : 25
FINAL                : 
FINALLY              : 
FLOAT                : 29
FN                   : 19 20
FNARROW              : 19 20
FOR                  : 
FOREACH              : 
FUNCTION             : 
GLOBAL               : 
GOTO                 : 
GREATEREQUALTHAN     : 
GREATERTHAN          : 
ID                   : 16 17 18 19 20 25 27
IDENTICAL            : 
IF                   : 
IMPLEMENTS           : 
INCLUDE              : 
INCLUDE_ONCE         : 
INCREMENT            : 
INSTANCEOF           : 
INSTEADOF            : 
INTEGER              : 28
INTERFACE            : 
ISSET                : 
IS_EQUAL             : 
LCURLY               : 11
LESSEQUALTHAN        : 
LESSTHAN             : 
LIST                 : 
LOGICALNOT           : 
LPAREN               : 11 17 19 20 25
LSQUARE              : 
MATCH                : 
MINUS                : 34
MINUSASSIGN          : 
MOD                  : 37
MODASSIGN            : 
NAMESPACE            : 
NEW                  : 16
NOTEQUAL             : 
NULL                 : 32
OBJOP                : 17 18
OPEN_TAG             : 
OR                   : 
PLUS                 : 33
PLUSASSIGN           : 
POP                  : 18
PRINT                : 
PRIVATE              : 
PROTECTED            : 
PUBLIC               : 
PUSH                 : 17
QUEUE                : 16
QUOTE                : 
RCURLY               : 11
REQUIRE              : 
REQUIRE_ONCE         : 
RETURN               : 
RPAREN               : 11 17 19 20 25
RSQUARE              : 
SEMICOLON            : 13 16 17 18 19 22 25
STACK                : 
STATIC               : 
STDIN                : 25
STRING               : 30
SWITCH               : 11
THROW                : 
TIMES                : 35
TIMESASSIGN          : 
TRAIT                : 
TRY                  : 
UNSET                : 
USE                  : 
VAR                  : 
WHILE                : 
XOR                  : 
YIELD                : 
YIELD_FROM           : 
__HALT_COMPILER      : 
error                : 

Nonterminals, with rules where they appear

arithmeticExpression : 3 12 13
arithmeticOperator   : 26
arrowBody            : 19 20
arrowFunction        : 8
cuerpo               : 1 2 21
echo                 : 9
fgets                : 10
programa             : 2 0
queueDeclaration     : 5
queueDequeue         : 7
queueEnqueue         : 6
switchCase           : 14 15
switchCases          : 11 15
switchDefault        : 11
switchStatement      : 4
value                : 11 13 17 23 24 26 26
values               : 22 24

Parsing method: LALR

state 0

    (0) S' -> . programa
    (1) programa -> . cuerpo
    (2) programa -> . programa cuerpo
    (3) cuerpo -> . arithmeticExpression
    (4) cuerpo -> . switchStatement
    (5) cuerpo -> . queueDeclaration
    (6) cuerpo -> . queueEnqueue
    (7) cuerpo -> . queueDequeue
    (8) cuerpo -> . arrowFunction
    (9) cuerpo -> . echo
    (10) cuerpo -> . fgets
    (26) arithmeticExpression -> . value arithmeticOperator value
    (11) switchStatement -> . SWITCH LPAREN value RPAREN LCURLY switchCases switchDefault RCURLY
    (16) queueDeclaration -> . ID EQUAL NEW QUEUE SEMICOLON
    (17) queueEnqueue -> . ID OBJOP PUSH LPAREN value RPAREN SEMICOLON
    (18) queueDequeue -> . ID OBJOP POP SEMICOLON
    (19) arrowFunction -> . FN LPAREN ID RPAREN FNARROW arrowBody SEMICOLON
    (22) echo -> . ECHO values SEMICOLON
    (25) fgets -> . ID EQUAL FGETS LPAREN STDIN RPAREN SEMICOLON
    (27) value -> . ID
    (28) value -> . INTEGER
    (29) value -> . FLOAT
    (30) value -> . STRING
    (31) value -> . BOOL
    (32) value -> . NULL

    SWITCH          shift and go to state 12
    ID              shift and go to state 13
    FN              shift and go to state 14
    ECHO            shift and go to state 15
    INTEGER         shift and go to state 16
    FLOAT           shift and go to state 17
    STRING          shift and go to state 18
    BOOL            shift and go to state 19
    NULL            shift and go to state 20

    programa                       shift and go to state 1
    cuerpo                         shift and go to state 2
    arithmeticExpression           shift and go to state 3
    switchStatement                shift and go to state 4
    queueDeclaration               shift and go to state 5
    queueEnqueue                   shift and go to state 6
    queueDequeue                   shift and go to state 7
    arrowFunction                  shift and go to state 8
    echo                           shift and go to state 9
    fgets                          shift and go to state 10
    value                          shift and go to state 11

state 1

    (0) S' -> programa .
    (2) programa -> programa . cuerpo
    (3) cuerpo -> . arithmeticExpression
    (4) cuerpo -> . switchStatement
    (5) cuerpo -> . queueDeclaration
    (6) cuerpo -> . queueEnqueue
    (7) cuerpo -> . queueDequeue
    (8) cuerpo -> . arrowFunction
    (9) cuerpo -> . echo
    (10) cuerpo -> . fgets
    (26) arithmeticExpression -> . value arithmeticOperator value
    (11) switchStatement -> . SWITCH LPAREN value RPAREN LCURLY switchCases switchDefault RCURLY
    (16) queueDeclaration -> . ID EQUAL NEW QUEUE SEMICOLON
    (17) queueEnqueue -> . ID OBJOP PUSH LPAREN value RPAREN SEMICOLON
    (18) queueDequeue -> . ID OBJOP POP SEMICOLON
    (19) arrowFunction -> . FN LPAREN ID RPAREN FNARROW arrowBody SEMICOLON
    (22) echo -> . ECHO values SEMICOLON
    (25) fgets -> . ID EQUAL FGETS LPAREN STDIN RPAREN SEMICOLON
    (27) value -> . ID
    (28) value -> . INTEGER
    (29) value -> . FLOAT
    (30) value -> . STRING
    (31) value -> . BOOL
    (32) value -> . NULL

    SWITCH          shift and go to state 12
    ID              shift and go to state 13
    FN              shift and go to state 14
    ECHO            shift and go to state 15
    INTEGER         shift and go to state 16
    FLOAT           shift and go to state 17
    STRING          shift and go to state 18
    BOOL            shift and go to state 19
    NULL            shift and go to state 20

    cuerpo                         shift and go to state 21
    arithmeticExpression           shift and go to state 3
    switchStatement                shift and go to state 4
    queueDeclaration               shift and go to state 5
    queueEnqueue                   shift and go to state 6
    queueDequeue                   shift and go to state 7
    arrowFunction                  shift and go to state 8
    echo                           shift and go to state 9
    fgets                          shift and go to state 10
    value                          shift and go to state 11

state 2

    (1) programa -> cuerpo .

    SWITCH          reduce using rule 1 (programa -> cuerpo .)
    ID              reduce using rule 1 (programa -> cuerpo .)
    FN              reduce using rule 1 (programa -> cuerpo .)
    ECHO            reduce using rule 1 (programa -> cuerpo .)
    INTEGER         reduce using rule 1 (programa -> cuerpo .)
    FLOAT           reduce using rule 1 (programa -> cuerpo .)
    STRING          reduce using rule 1 (programa -> cuerpo .)
    BOOL            reduce using rule 1 (programa -> cuerpo .)
    NULL            reduce using rule 1 (programa -> cuerpo .)
    $end            reduce using rule 1 (programa -> cuerpo .)


state 3

    (3) cuerpo -> arithmeticExpression .

    SWITCH          reduce using rule 3 (cuerpo -> arithmeticExpression .)
    ID              reduce using rule 3 (cuerpo -> arithmeticExpression .)
    FN              reduce using rule 3 (cuerpo -> arithmeticExpression .)
    ECHO            reduce using rule 3 (cuerpo -> arithmeticExpression .)
    INTEGER         reduce using rule 3 (cuerpo -> arithmeticExpression .)
    FLOAT           reduce using rule 3 (cuerpo -> arithmeticExpression .)
    STRING          reduce using rule 3 (cuerpo -> arithmeticExpression .)
    BOOL            reduce using rule 3 (cuerpo -> arithmeticExpression .)
    NULL            reduce using rule 3 (cuerpo -> arithmeticExpression .)
    $end            reduce using rule 3 (cuerpo -> arithmeticExpression .)
    SEMICOLON       reduce using rule 3 (cuerpo -> arithmeticExpression .)


state 4

    (4) cuerpo -> switchStatement .

    SWITCH          reduce using rule 4 (cuerpo -> switchStatement .)
    ID              reduce using rule 4 (cuerpo -> switchStatement .)
    FN              reduce using rule 4 (cuerpo -> switchStatement .)
    ECHO            reduce using rule 4 (cuerpo -> switchStatement .)
    INTEGER         reduce using rule 4 (cuerpo -> switchStatement .)
    FLOAT           reduce using rule 4 (cuerpo -> switchStatement .)
    STRING          reduce using rule 4 (cuerpo -> switchStatement .)
    BOOL            reduce using rule 4 (cuerpo -> switchStatement .)
    NULL            reduce using rule 4 (cuerpo -> switchStatement .)
    $end            reduce using rule 4 (cuerpo -> switchStatement .)
    SEMICOLON       reduce using rule 4 (cuerpo -> switchStatement .)


state 5

    (5) cuerpo -> queueDeclaration .

    SWITCH          reduce using rule 5 (cuerpo -> queueDeclaration .)
    ID              reduce using rule 5 (cuerpo -> queueDeclaration .)
    FN              reduce using rule 5 (cuerpo -> queueDeclaration .)
    ECHO            reduce using rule 5 (cuerpo -> queueDeclaration .)
    INTEGER         reduce using rule 5 (cuerpo -> queueDeclaration .)
    FLOAT           reduce using rule 5 (cuerpo -> queueDeclaration .)
    STRING          reduce using rule 5 (cuerpo -> queueDeclaration .)
    BOOL            reduce using rule 5 (cuerpo -> queueDeclaration .)
    NULL            reduce using rule 5 (cuerpo -> queueDeclaration .)
    $end            reduce using rule 5 (cuerpo -> queueDeclaration .)
    SEMICOLON       reduce using rule 5 (cuerpo -> queueDeclaration .)


state 6

    (6) cuerpo -> queueEnqueue .

    SWITCH          reduce using rule 6 (cuerpo -> queueEnqueue .)
    ID              reduce using rule 6 (cuerpo -> queueEnqueue .)
    FN              reduce using rule 6 (cuerpo -> queueEnqueue .)
    ECHO            reduce using rule 6 (cuerpo -> queueEnqueue .)
    INTEGER         reduce using rule 6 (cuerpo -> queueEnqueue .)
    FLOAT           reduce using rule 6 (cuerpo -> queueEnqueue .)
    STRING          reduce using rule 6 (cuerpo -> queueEnqueue .)
    BOOL            reduce using rule 6 (cuerpo -> queueEnqueue .)
    NULL            reduce using rule 6 (cuerpo -> queueEnqueue .)
    $end            reduce using rule 6 (cuerpo -> queueEnqueue .)
    SEMICOLON       reduce using rule 6 (cuerpo -> queueEnqueue .)


state 7

    (7) cuerpo -> queueDequeue .

    SWITCH          reduce using rule 7 (cuerpo -> queueDequeue .)
    ID              reduce using rule 7 (cuerpo -> queueDequeue .)
    FN              reduce using rule 7 (cuerpo -> queueDequeue .)
    ECHO            reduce using rule 7 (cuerpo -> queueDequeue .)
    INTEGER         reduce using rule 7 (cuerpo -> queueDequeue .)
    FLOAT           reduce using rule 7 (cuerpo -> queueDequeue .)
    STRING          reduce using rule 7 (cuerpo -> queueDequeue .)
    BOOL            reduce using rule 7 (cuerpo -> queueDequeue .)
    NULL            reduce using rule 7 (cuerpo -> queueDequeue .)
    $end            reduce using rule 7 (cuerpo -> queueDequeue .)
    SEMICOLON       reduce using rule 7 (cuerpo -> queueDequeue .)


state 8

    (8) cuerpo -> arrowFunction .

    SWITCH          reduce using rule 8 (cuerpo -> arrowFunction .)
    ID              reduce using rule 8 (cuerpo -> arrowFunction .)
    FN              reduce using rule 8 (cuerpo -> arrowFunction .)
    ECHO            reduce using rule 8 (cuerpo -> arrowFunction .)
    INTEGER         reduce using rule 8 (cuerpo -> arrowFunction .)
    FLOAT           reduce using rule 8 (cuerpo -> arrowFunction .)
    STRING          reduce using rule 8 (cuerpo -> arrowFunction .)
    BOOL            reduce using rule 8 (cuerpo -> arrowFunction .)
    NULL            reduce using rule 8 (cuerpo -> arrowFunction .)
    $end            reduce using rule 8 (cuerpo -> arrowFunction .)
    SEMICOLON       reduce using rule 8 (cuerpo -> arrowFunction .)


state 9

    (9) cuerpo -> echo .

    SWITCH          reduce using rule 9 (cuerpo -> echo .)
    ID              reduce using rule 9 (cuerpo -> echo .)
    FN              reduce using rule 9 (cuerpo -> echo .)
    ECHO            reduce using rule 9 (cuerpo -> echo .)
    INTEGER         reduce using rule 9 (cuerpo -> echo .)
    FLOAT           reduce using rule 9 (cuerpo -> echo .)
    STRING          reduce using rule 9 (cuerpo -> echo .)
    BOOL            reduce using rule 9 (cuerpo -> echo .)
    NULL            reduce using rule 9 (cuerpo -> echo .)
    $end            reduce using rule 9 (cuerpo -> echo .)
    SEMICOLON       reduce using rule 9 (cuerpo -> echo .)


state 10

    (10) cuerpo -> fgets .

    SWITCH          reduce using rule 10 (cuerpo -> fgets .)
    ID              reduce using rule 10 (cuerpo -> fgets .)
    FN              reduce using rule 10 (cuerpo -> fgets .)
    ECHO            reduce using rule 10 (cuerpo -> fgets .)
    INTEGER         reduce using rule 10 (cuerpo -> fgets .)
    FLOAT           reduce using rule 10 (cuerpo -> fgets .)
    STRING          reduce using rule 10 (cuerpo -> fgets .)
    BOOL            reduce using rule 10 (cuerpo -> fgets .)
    NULL            reduce using rule 10 (cuerpo -> fgets .)
    $end            reduce using rule 10 (cuerpo -> fgets .)
    SEMICOLON       reduce using rule 10 (cuerpo -> fgets .)


state 11

    (26) arithmeticExpression -> value . arithmeticOperator value
    (33) arithmeticOperator -> . PLUS
    (34) arithmeticOperator -> . MINUS
    (35) arithmeticOperator -> . TIMES
    (36) arithmeticOperator -> . DIVIDE
    (37) arithmeticOperator -> . MOD
    (38) arithmeticOperator -> . EXP

    PLUS            shift and go to state 23
    MINUS           shift and go to state 24
    TIMES           shift and go to state 25
    DIVIDE          shift and go to state 26
    MOD             shift and go to state 27
    EXP             shift and go to state 28

    arithmeticOperator             shift and go to state 22

state 12

    (11) switchStatement -> SWITCH . LPAREN value RPAREN LCURLY switchCases switchDefault RCURLY

    LPAREN          shift and go to state 29


state 13

    (16) queueDeclaration -> ID . EQUAL NEW QUEUE SEMICOLON
    (17) queueEnqueue -> ID . OBJOP PUSH LPAREN value RPAREN SEMICOLON
    (18) queueDequeue -> ID . OBJOP POP SEMICOLON
    (25) fgets -> ID . EQUAL FGETS LPAREN STDIN RPAREN SEMICOLON
    (27) value -> ID .

    EQUAL           shift and go to state 30
    OBJOP           shift and go to state 31
    PLUS            reduce using rule 27 (value -> ID .)
    MINUS           reduce using rule 27 (value -> ID .)
    TIMES           reduce using rule 27 (value -> ID .)
    DIVIDE          reduce using rule 27 (value -> ID .)
    MOD             reduce using rule 27 (value -> ID .)
    EXP             reduce using rule 27 (value -> ID .)


state 14

    (19) arrowFunction -> FN . LPAREN ID RPAREN FNARROW arrowBody SEMICOLON

    LPAREN          shift and go to state 32


state 15

    (22) echo -> ECHO . values SEMICOLON
    (23) values -> . value
    (24) values -> . values COMMA value
    (27) value -> . ID
    (28) value -> . INTEGER
    (29) value -> . FLOAT
    (30) value -> . STRING
    (31) value -> . BOOL
    (32) value -> . NULL

    ID              shift and go to state 35
    INTEGER         shift and go to state 16
    FLOAT           shift and go to state 17
    STRING          shift and go to state 18
    BOOL            shift and go to state 19
    NULL            shift and go to state 20

    values                         shift and go to state 33
    value                          shift and go to state 34

state 16

    (28) value -> INTEGER .

    PLUS            reduce using rule 28 (value -> INTEGER .)
    MINUS           reduce using rule 28 (value -> INTEGER .)
    TIMES           reduce using rule 28 (value -> INTEGER .)
    DIVIDE          reduce using rule 28 (value -> INTEGER .)
    MOD             reduce using rule 28 (value -> INTEGER .)
    EXP             reduce using rule 28 (value -> INTEGER .)
    SEMICOLON       reduce using rule 28 (value -> INTEGER .)
    COMMA           reduce using rule 28 (value -> INTEGER .)
    SWITCH          reduce using rule 28 (value -> INTEGER .)
    ID              reduce using rule 28 (value -> INTEGER .)
    FN              reduce using rule 28 (value -> INTEGER .)
    ECHO            reduce using rule 28 (value -> INTEGER .)
    INTEGER         reduce using rule 28 (value -> INTEGER .)
    FLOAT           reduce using rule 28 (value -> INTEGER .)
    STRING          reduce using rule 28 (value -> INTEGER .)
    BOOL            reduce using rule 28 (value -> INTEGER .)
    NULL            reduce using rule 28 (value -> INTEGER .)
    $end            reduce using rule 28 (value -> INTEGER .)
    RCURLY          reduce using rule 28 (value -> INTEGER .)
    BREAK           reduce using rule 28 (value -> INTEGER .)
    RPAREN          reduce using rule 28 (value -> INTEGER .)
    COLON           reduce using rule 28 (value -> INTEGER .)


state 17

    (29) value -> FLOAT .

    PLUS            reduce using rule 29 (value -> FLOAT .)
    MINUS           reduce using rule 29 (value -> FLOAT .)
    TIMES           reduce using rule 29 (value -> FLOAT .)
    DIVIDE          reduce using rule 29 (value -> FLOAT .)
    MOD             reduce using rule 29 (value -> FLOAT .)
    EXP             reduce using rule 29 (value -> FLOAT .)
    SEMICOLON       reduce using rule 29 (value -> FLOAT .)
    COMMA           reduce using rule 29 (value -> FLOAT .)
    SWITCH          reduce using rule 29 (value -> FLOAT .)
    ID              reduce using rule 29 (value -> FLOAT .)
    FN              reduce using rule 29 (value -> FLOAT .)
    ECHO            reduce using rule 29 (value -> FLOAT .)
    INTEGER         reduce using rule 29 (value -> FLOAT .)
    FLOAT           reduce using rule 29 (value -> FLOAT .)
    STRING          reduce using rule 29 (value -> FLOAT .)
    BOOL            reduce using rule 29 (value -> FLOAT .)
    NULL            reduce using rule 29 (value -> FLOAT .)
    $end            reduce using rule 29 (value -> FLOAT .)
    RCURLY          reduce using rule 29 (value -> FLOAT .)
    BREAK           reduce using rule 29 (value -> FLOAT .)
    RPAREN          reduce using rule 29 (value -> FLOAT .)
    COLON           reduce using rule 29 (value -> FLOAT .)


state 18

    (30) value -> STRING .

    PLUS            reduce using rule 30 (value -> STRING .)
    MINUS           reduce using rule 30 (value -> STRING .)
    TIMES           reduce using rule 30 (value -> STRING .)
    DIVIDE          reduce using rule 30 (value -> STRING .)
    MOD             reduce using rule 30 (value -> STRING .)
    EXP             reduce using rule 30 (value -> STRING .)
    SEMICOLON       reduce using rule 30 (value -> STRING .)
    COMMA           reduce using rule 30 (value -> STRING .)
    SWITCH          reduce using rule 30 (value -> STRING .)
    ID              reduce using rule 30 (value -> STRING .)
    FN              reduce using rule 30 (value -> STRING .)
    ECHO            reduce using rule 30 (value -> STRING .)
    INTEGER         reduce using rule 30 (value -> STRING .)
    FLOAT           reduce using rule 30 (value -> STRING .)
    STRING          reduce using rule 30 (value -> STRING .)
    BOOL            reduce using rule 30 (value -> STRING .)
    NULL            reduce using rule 30 (value -> STRING .)
    $end            reduce using rule 30 (value -> STRING .)
    RCURLY          reduce using rule 30 (value -> STRING .)
    BREAK           reduce using rule 30 (value -> STRING .)
    RPAREN          reduce using rule 30 (value -> STRING .)
    COLON           reduce using rule 30 (value -> STRING .)


state 19

    (31) value -> BOOL .

    PLUS            reduce using rule 31 (value -> BOOL .)
    MINUS           reduce using rule 31 (value -> BOOL .)
    TIMES           reduce using rule 31 (value -> BOOL .)
    DIVIDE          reduce using rule 31 (value -> BOOL .)
    MOD             reduce using rule 31 (value -> BOOL .)
    EXP             reduce using rule 31 (value -> BOOL .)
    SEMICOLON       reduce using rule 31 (value -> BOOL .)
    COMMA           reduce using rule 31 (value -> BOOL .)
    SWITCH          reduce using rule 31 (value -> BOOL .)
    ID              reduce using rule 31 (value -> BOOL .)
    FN              reduce using rule 31 (value -> BOOL .)
    ECHO            reduce using rule 31 (value -> BOOL .)
    INTEGER         reduce using rule 31 (value -> BOOL .)
    FLOAT           reduce using rule 31 (value -> BOOL .)
    STRING          reduce using rule 31 (value -> BOOL .)
    BOOL            reduce using rule 31 (value -> BOOL .)
    NULL            reduce using rule 31 (value -> BOOL .)
    $end            reduce using rule 31 (value -> BOOL .)
    RCURLY          reduce using rule 31 (value -> BOOL .)
    BREAK           reduce using rule 31 (value -> BOOL .)
    RPAREN          reduce using rule 31 (value -> BOOL .)
    COLON           reduce using rule 31 (value -> BOOL .)


state 20

    (32) value -> NULL .

    PLUS            reduce using rule 32 (value -> NULL .)
    MINUS           reduce using rule 32 (value -> NULL .)
    TIMES           reduce using rule 32 (value -> NULL .)
    DIVIDE          reduce using rule 32 (value -> NULL .)
    MOD             reduce using rule 32 (value -> NULL .)
    EXP             reduce using rule 32 (value -> NULL .)
    SEMICOLON       reduce using rule 32 (value -> NULL .)
    COMMA           reduce using rule 32 (value -> NULL .)
    SWITCH          reduce using rule 32 (value -> NULL .)
    ID              reduce using rule 32 (value -> NULL .)
    FN              reduce using rule 32 (value -> NULL .)
    ECHO            reduce using rule 32 (value -> NULL .)
    INTEGER         reduce using rule 32 (value -> NULL .)
    FLOAT           reduce using rule 32 (value -> NULL .)
    STRING          reduce using rule 32 (value -> NULL .)
    BOOL            reduce using rule 32 (value -> NULL .)
    NULL            reduce using rule 32 (value -> NULL .)
    $end            reduce using rule 32 (value -> NULL .)
    RCURLY          reduce using rule 32 (value -> NULL .)
    BREAK           reduce using rule 32 (value -> NULL .)
    RPAREN          reduce using rule 32 (value -> NULL .)
    COLON           reduce using rule 32 (value -> NULL .)


state 21

    (2) programa -> programa cuerpo .

    SWITCH          reduce using rule 2 (programa -> programa cuerpo .)
    ID              reduce using rule 2 (programa -> programa cuerpo .)
    FN              reduce using rule 2 (programa -> programa cuerpo .)
    ECHO            reduce using rule 2 (programa -> programa cuerpo .)
    INTEGER         reduce using rule 2 (programa -> programa cuerpo .)
    FLOAT           reduce using rule 2 (programa -> programa cuerpo .)
    STRING          reduce using rule 2 (programa -> programa cuerpo .)
    BOOL            reduce using rule 2 (programa -> programa cuerpo .)
    NULL            reduce using rule 2 (programa -> programa cuerpo .)
    $end            reduce using rule 2 (programa -> programa cuerpo .)


state 22

    (26) arithmeticExpression -> value arithmeticOperator . value
    (27) value -> . ID
    (28) value -> . INTEGER
    (29) value -> . FLOAT
    (30) value -> . STRING
    (31) value -> . BOOL
    (32) value -> . NULL

    ID              shift and go to state 35
    INTEGER         shift and go to state 16
    FLOAT           shift and go to state 17
    STRING          shift and go to state 18
    BOOL            shift and go to state 19
    NULL            shift and go to state 20

    value                          shift and go to state 36

state 23

    (33) arithmeticOperator -> PLUS .

    ID              reduce using rule 33 (arithmeticOperator -> PLUS .)
    INTEGER         reduce using rule 33 (arithmeticOperator -> PLUS .)
    FLOAT           reduce using rule 33 (arithmeticOperator -> PLUS .)
    STRING          reduce using rule 33 (arithmeticOperator -> PLUS .)
    BOOL            reduce using rule 33 (arithmeticOperator -> PLUS .)
    NULL            reduce using rule 33 (arithmeticOperator -> PLUS .)


state 24

    (34) arithmeticOperator -> MINUS .

    ID              reduce using rule 34 (arithmeticOperator -> MINUS .)
    INTEGER         reduce using rule 34 (arithmeticOperator -> MINUS .)
    FLOAT           reduce using rule 34 (arithmeticOperator -> MINUS .)
    STRING          reduce using rule 34 (arithmeticOperator -> MINUS .)
    BOOL            reduce using rule 34 (arithmeticOperator -> MINUS .)
    NULL            reduce using rule 34 (arithmeticOperator -> MINUS .)


state 25

    (35) arithmeticOperator -> TIMES .

    ID              reduce using rule 35 (arithmeticOperator -> TIMES .)
    INTEGER         reduce using rule 35 (arithmeticOperator -> TIMES .)
    FLOAT           reduce using rule 35 (arithmeticOperator -> TIMES .)
    STRING          reduce using rule 35 (arithmeticOperator -> TIMES .)
    BOOL            reduce using rule 35 (arithmeticOperator -> TIMES .)
    NULL            reduce using rule 35 (arithmeticOperator -> TIMES .)


state 26

    (36) arithmeticOperator -> DIVIDE .

    ID              reduce using rule 36 (arithmeticOperator -> DIVIDE .)
    INTEGER         reduce using rule 36 (arithmeticOperator -> DIVIDE .)
    FLOAT           reduce using rule 36 (arithmeticOperator -> DIVIDE .)
    STRING          reduce using rule 36 (arithmeticOperator -> DIVIDE .)
    BOOL            reduce using rule 36 (arithmeticOperator -> DIVIDE .)
    NULL            reduce using rule 36 (arithmeticOperator -> DIVIDE .)


state 27

    (37) arithmeticOperator -> MOD .

    ID              reduce using rule 37 (arithmeticOperator -> MOD .)
    INTEGER         reduce using rule 37 (arithmeticOperator -> MOD .)
    FLOAT           reduce using rule 37 (arithmeticOperator -> MOD .)
    STRING          reduce using rule 37 (arithmeticOperator -> MOD .)
    BOOL            reduce using rule 37 (arithmeticOperator -> MOD .)
    NULL            reduce using rule 37 (arithmeticOperator -> MOD .)


state 28

    (38) arithmeticOperator -> EXP .

    ID              reduce using rule 38 (arithmeticOperator -> EXP .)
    INTEGER         reduce using rule 38 (arithmeticOperator -> EXP .)
    FLOAT           reduce using rule 38 (arithmeticOperator -> EXP .)
    STRING          reduce using rule 38 (arithmeticOperator -> EXP .)
    BOOL            reduce using rule 38 (arithmeticOperator -> EXP .)
    NULL            reduce using rule 38 (arithmeticOperator -> EXP .)


state 29

    (11) switchStatement -> SWITCH LPAREN . value RPAREN LCURLY switchCases switchDefault RCURLY
    (27) value -> . ID
    (28) value -> . INTEGER
    (29) value -> . FLOAT
    (30) value -> . STRING
    (31) value -> . BOOL
    (32) value -> . NULL

    ID              shift and go to state 35
    INTEGER         shift and go to state 16
    FLOAT           shift and go to state 17
    STRING          shift and go to state 18
    BOOL            shift and go to state 19
    NULL            shift and go to state 20

    value                          shift and go to state 37

state 30

    (16) queueDeclaration -> ID EQUAL . NEW QUEUE SEMICOLON
    (25) fgets -> ID EQUAL . FGETS LPAREN STDIN RPAREN SEMICOLON

    NEW             shift and go to state 38
    FGETS           shift and go to state 39


state 31

    (17) queueEnqueue -> ID OBJOP . PUSH LPAREN value RPAREN SEMICOLON
    (18) queueDequeue -> ID OBJOP . POP SEMICOLON

    PUSH            shift and go to state 40
    POP             shift and go to state 41


state 32

    (19) arrowFunction -> FN LPAREN . ID RPAREN FNARROW arrowBody SEMICOLON

    ID              shift and go to state 42


state 33

    (22) echo -> ECHO values . SEMICOLON
    (24) values -> values . COMMA value

    SEMICOLON       shift and go to state 43
    COMMA           shift and go to state 44


state 34

    (23) values -> value .

    SEMICOLON       reduce using rule 23 (values -> value .)
    COMMA           reduce using rule 23 (values -> value .)


state 35

    (27) value -> ID .

    SEMICOLON       reduce using rule 27 (value -> ID .)
    COMMA           reduce using rule 27 (value -> ID .)
    SWITCH          reduce using rule 27 (value -> ID .)
    ID              reduce using rule 27 (value -> ID .)
    FN              reduce using rule 27 (value -> ID .)
    ECHO            reduce using rule 27 (value -> ID .)
    INTEGER         reduce using rule 27 (value -> ID .)
    FLOAT           reduce using rule 27 (value -> ID .)
    STRING          reduce using rule 27 (value -> ID .)
    BOOL            reduce using rule 27 (value -> ID .)
    NULL            reduce using rule 27 (value -> ID .)
    $end            reduce using rule 27 (value -> ID .)
    RCURLY          reduce using rule 27 (value -> ID .)
    BREAK           reduce using rule 27 (value -> ID .)
    RPAREN          reduce using rule 27 (value -> ID .)
    COLON           reduce using rule 27 (value -> ID .)
    PLUS            reduce using rule 27 (value -> ID .)
    MINUS           reduce using rule 27 (value -> ID .)
    TIMES           reduce using rule 27 (value -> ID .)
    DIVIDE          reduce using rule 27 (value -> ID .)
    MOD             reduce using rule 27 (value -> ID .)
    EXP             reduce using rule 27 (value -> ID .)


state 36

    (26) arithmeticExpression -> value arithmeticOperator value .

    SWITCH          reduce using rule 26 (arithmeticExpression -> value arithmeticOperator value .)
    ID              reduce using rule 26 (arithmeticExpression -> value arithmeticOperator value .)
    FN              reduce using rule 26 (arithmeticExpression -> value arithmeticOperator value .)
    ECHO            reduce using rule 26 (arithmeticExpression -> value arithmeticOperator value .)
    INTEGER         reduce using rule 26 (arithmeticExpression -> value arithmeticOperator value .)
    FLOAT           reduce using rule 26 (arithmeticExpression -> value arithmeticOperator value .)
    STRING          reduce using rule 26 (arithmeticExpression -> value arithmeticOperator value .)
    BOOL            reduce using rule 26 (arithmeticExpression -> value arithmeticOperator value .)
    NULL            reduce using rule 26 (arithmeticExpression -> value arithmeticOperator value .)
    $end            reduce using rule 26 (arithmeticExpression -> value arithmeticOperator value .)
    SEMICOLON       reduce using rule 26 (arithmeticExpression -> value arithmeticOperator value .)
    RCURLY          reduce using rule 26 (arithmeticExpression -> value arithmeticOperator value .)
    BREAK           reduce using rule 26 (arithmeticExpression -> value arithmeticOperator value .)


state 37

    (11) switchStatement -> SWITCH LPAREN value . RPAREN LCURLY switchCases switchDefault RCURLY

    RPAREN          shift and go to state 45


state 38

    (16) queueDeclaration -> ID EQUAL NEW . QUEUE SEMICOLON

    QUEUE           shift and go to state 46


state 39

    (25) fgets -> ID EQUAL FGETS . LPAREN STDIN RPAREN SEMICOLON

    LPAREN          shift and go to state 47


state 40

    (17) queueEnqueue -> ID OBJOP PUSH . LPAREN value RPAREN SEMICOLON

    LPAREN          shift and go to state 48


state 41

    (18) queueDequeue -> ID OBJOP POP . SEMICOLON

    SEMICOLON       shift and go to state 49


state 42

    (19) arrowFunction -> FN LPAREN ID . RPAREN FNARROW arrowBody SEMICOLON

    RPAREN          shift and go to state 50


state 43

    (22) echo -> ECHO values SEMICOLON .

    SWITCH          reduce using rule 22 (echo -> ECHO values SEMICOLON .)
    ID              reduce using rule 22 (echo -> ECHO values SEMICOLON .)
    FN              reduce using rule 22 (echo -> ECHO values SEMICOLON .)
    ECHO            reduce using rule 22 (echo -> ECHO values SEMICOLON .)
    INTEGER         reduce using rule 22 (echo -> ECHO values SEMICOLON .)
    FLOAT           reduce using rule 22 (echo -> ECHO values SEMICOLON .)
    STRING          reduce using rule 22 (echo -> ECHO values SEMICOLON .)
    BOOL            reduce using rule 22 (echo -> ECHO values SEMICOLON .)
    NULL            reduce using rule 22 (echo -> ECHO values SEMICOLON .)
    $end            reduce using rule 22 (echo -> ECHO values SEMICOLON .)
    SEMICOLON       reduce using rule 22 (echo -> ECHO values SEMICOLON .)


state 44

    (24) values -> values COMMA . value
    (27) value -> . ID
    (28) value -> . INTEGER
    (29) value -> . FLOAT
    (30) value -> . STRING
    (31) value -> . BOOL
    (32) value -> . NULL

    ID              shift and go to state 35
    INTEGER         shift and go to state 16
    FLOAT           shift and go to state 17
    STRING          shift and go to state 18
    BOOL            shift and go to state 19
    NULL            shift and go to state 20

    value                          shift and go to state 51

state 45

    (11) switchStatement -> SWITCH LPAREN value RPAREN . LCURLY switchCases switchDefault RCURLY

    LCURLY          shift and go to state 52


state 46

    (16) queueDeclaration -> ID EQUAL NEW QUEUE . SEMICOLON

    SEMICOLON       shift and go to state 53


state 47

    (25) fgets -> ID EQUAL FGETS LPAREN . STDIN RPAREN SEMICOLON

    STDIN           shift and go to state 54


state 48

    (17) queueEnqueue -> ID OBJOP PUSH LPAREN . value RPAREN SEMICOLON
    (27) value -> . ID
    (28) value -> . INTEGER
    (29) value -> . FLOAT
    (30) value -> . STRING
    (31) value -> . BOOL
    (32) value -> . NULL

    ID              shift and go to state 35
    INTEGER         shift and go to state 16
    FLOAT           shift and go to state 17
    STRING          shift and go to state 18
    BOOL            shift and go to state 19
    NULL            shift and go to state 20

    value                          shift and go to state 55

state 49

    (18) queueDequeue -> ID OBJOP POP SEMICOLON .

    SWITCH          reduce using rule 18 (queueDequeue -> ID OBJOP POP SEMICOLON .)
    ID              reduce using rule 18 (queueDequeue -> ID OBJOP POP SEMICOLON .)
    FN              reduce using rule 18 (queueDequeue -> ID OBJOP POP SEMICOLON .)
    ECHO            reduce using rule 18 (queueDequeue -> ID OBJOP POP SEMICOLON .)
    INTEGER         reduce using rule 18 (queueDequeue -> ID OBJOP POP SEMICOLON .)
    FLOAT           reduce using rule 18 (queueDequeue -> ID OBJOP POP SEMICOLON .)
    STRING          reduce using rule 18 (queueDequeue -> ID OBJOP POP SEMICOLON .)
    BOOL            reduce using rule 18 (queueDequeue -> ID OBJOP POP SEMICOLON .)
    NULL            reduce using rule 18 (queueDequeue -> ID OBJOP POP SEMICOLON .)
    $end            reduce using rule 18 (queueDequeue -> ID OBJOP POP SEMICOLON .)
    SEMICOLON       reduce using rule 18 (queueDequeue -> ID OBJOP POP SEMICOLON .)


state 50

    (19) arrowFunction -> FN LPAREN ID RPAREN . FNARROW arrowBody SEMICOLON

    FNARROW         shift and go to state 56


state 51

    (24) values -> values COMMA value .

    SEMICOLON       reduce using rule 24 (values -> values COMMA value .)
    COMMA           reduce using rule 24 (values -> values COMMA value .)


state 52

    (11) switchStatement -> SWITCH LPAREN value RPAREN LCURLY . switchCases switchDefault RCURLY
    (14) switchCases -> . switchCase
    (15) switchCases -> . switchCases switchCase
    (13) switchCase -> . CASE value COLON arithmeticExpression BREAK SEMICOLON

    CASE            shift and go to state 59

    switchCases                    shift and go to state 57
    switchCase                     shift and go to state 58

state 53

    (16) queueDeclaration -> ID EQUAL NEW QUEUE SEMICOLON .

    SWITCH          reduce using rule 16 (queueDeclaration -> ID EQUAL NEW QUEUE SEMICOLON .)
    ID              reduce using rule 16 (queueDeclaration -> ID EQUAL NEW QUEUE SEMICOLON .)
    FN              reduce using rule 16 (queueDeclaration -> ID EQUAL NEW QUEUE SEMICOLON .)
    ECHO            reduce using rule 16 (queueDeclaration -> ID EQUAL NEW QUEUE SEMICOLON .)
    INTEGER         reduce using rule 16 (queueDeclaration -> ID EQUAL NEW QUEUE SEMICOLON .)
    FLOAT           reduce using rule 16 (queueDeclaration -> ID EQUAL NEW QUEUE SEMICOLON .)
    STRING          reduce using rule 16 (queueDeclaration -> ID EQUAL NEW QUEUE SEMICOLON .)
    BOOL            reduce using rule 16 (queueDeclaration -> ID EQUAL NEW QUEUE SEMICOLON .)
    NULL            reduce using rule 16 (queueDeclaration -> ID EQUAL NEW QUEUE SEMICOLON .)
    $end            reduce using rule 16 (queueDeclaration -> ID EQUAL NEW QUEUE SEMICOLON .)
    SEMICOLON       reduce using rule 16 (queueDeclaration -> ID EQUAL NEW QUEUE SEMICOLON .)


state 54

    (25) fgets -> ID EQUAL FGETS LPAREN STDIN . RPAREN SEMICOLON

    RPAREN          shift and go to state 60


state 55

    (17) queueEnqueue -> ID OBJOP PUSH LPAREN value . RPAREN SEMICOLON

    RPAREN          shift and go to state 61


state 56

    (19) arrowFunction -> FN LPAREN ID RPAREN FNARROW . arrowBody SEMICOLON
    (20) arrowBody -> . FN LPAREN ID RPAREN FNARROW arrowBody
    (21) arrowBody -> . cuerpo
    (3) cuerpo -> . arithmeticExpression
    (4) cuerpo -> . switchStatement
    (5) cuerpo -> . queueDeclaration
    (6) cuerpo -> . queueEnqueue
    (7) cuerpo -> . queueDequeue
    (8) cuerpo -> . arrowFunction
    (9) cuerpo -> . echo
    (10) cuerpo -> . fgets
    (26) arithmeticExpression -> . value arithmeticOperator value
    (11) switchStatement -> . SWITCH LPAREN value RPAREN LCURLY switchCases switchDefault RCURLY
    (16) queueDeclaration -> . ID EQUAL NEW QUEUE SEMICOLON
    (17) queueEnqueue -> . ID OBJOP PUSH LPAREN value RPAREN SEMICOLON
    (18) queueDequeue -> . ID OBJOP POP SEMICOLON
    (19) arrowFunction -> . FN LPAREN ID RPAREN FNARROW arrowBody SEMICOLON
    (22) echo -> . ECHO values SEMICOLON
    (25) fgets -> . ID EQUAL FGETS LPAREN STDIN RPAREN SEMICOLON
    (27) value -> . ID
    (28) value -> . INTEGER
    (29) value -> . FLOAT
    (30) value -> . STRING
    (31) value -> . BOOL
    (32) value -> . NULL

    FN              shift and go to state 62
    SWITCH          shift and go to state 12
    ID              shift and go to state 13
    ECHO            shift and go to state 15
    INTEGER         shift and go to state 16
    FLOAT           shift and go to state 17
    STRING          shift and go to state 18
    BOOL            shift and go to state 19
    NULL            shift and go to state 20

    arrowBody                      shift and go to state 63
    cuerpo                         shift and go to state 64
    arithmeticExpression           shift and go to state 3
    switchStatement                shift and go to state 4
    queueDeclaration               shift and go to state 5
    queueEnqueue                   shift and go to state 6
    queueDequeue                   shift and go to state 7
    arrowFunction                  shift and go to state 8
    echo                           shift and go to state 9
    fgets                          shift and go to state 10
    value                          shift and go to state 11

state 57

    (11) switchStatement -> SWITCH LPAREN value RPAREN LCURLY switchCases . switchDefault RCURLY
    (15) switchCases -> switchCases . switchCase
    (12) switchDefault -> . DEFAULT COLON arithmeticExpression
    (13) switchCase -> . CASE value COLON arithmeticExpression BREAK SEMICOLON

    DEFAULT         shift and go to state 67
    CASE            shift and go to state 59

    switchDefault                  shift and go to state 65
    switchCase                     shift and go to state 66

state 58

    (14) switchCases -> switchCase .

    DEFAULT         reduce using rule 14 (switchCases -> switchCase .)
    CASE            reduce using rule 14 (switchCases -> switchCase .)


state 59

    (13) switchCase -> CASE . value COLON arithmeticExpression BREAK SEMICOLON
    (27) value -> . ID
    (28) value -> . INTEGER
    (29) value -> . FLOAT
    (30) value -> . STRING
    (31) value -> . BOOL
    (32) value -> . NULL

    ID              shift and go to state 35
    INTEGER         shift and go to state 16
    FLOAT           shift and go to state 17
    STRING          shift and go to state 18
    BOOL            shift and go to state 19
    NULL            shift and go to state 20

    value                          shift and go to state 68

state 60

    (25) fgets -> ID EQUAL FGETS LPAREN STDIN RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 69


state 61

    (17) queueEnqueue -> ID OBJOP PUSH LPAREN value RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 70


state 62

    (20) arrowBody -> FN . LPAREN ID RPAREN FNARROW arrowBody
    (19) arrowFunction -> FN . LPAREN ID RPAREN FNARROW arrowBody SEMICOLON

    LPAREN          shift and go to state 71


state 63

    (19) arrowFunction -> FN LPAREN ID RPAREN FNARROW arrowBody . SEMICOLON

    SEMICOLON       shift and go to state 72


state 64

    (21) arrowBody -> cuerpo .

    SEMICOLON       reduce using rule 21 (arrowBody -> cuerpo .)


state 65

    (11) switchStatement -> SWITCH LPAREN value RPAREN LCURLY switchCases switchDefault . RCURLY

    RCURLY          shift and go to state 73


state 66

    (15) switchCases -> switchCases switchCase .

    DEFAULT         reduce using rule 15 (switchCases -> switchCases switchCase .)
    CASE            reduce using rule 15 (switchCases -> switchCases switchCase .)


state 67

    (12) switchDefault -> DEFAULT . COLON arithmeticExpression

    COLON           shift and go to state 74


state 68

    (13) switchCase -> CASE value . COLON arithmeticExpression BREAK SEMICOLON

    COLON           shift and go to state 75


state 69

    (25) fgets -> ID EQUAL FGETS LPAREN STDIN RPAREN SEMICOLON .

    SWITCH          reduce using rule 25 (fgets -> ID EQUAL FGETS LPAREN STDIN RPAREN SEMICOLON .)
    ID              reduce using rule 25 (fgets -> ID EQUAL FGETS LPAREN STDIN RPAREN SEMICOLON .)
    FN              reduce using rule 25 (fgets -> ID EQUAL FGETS LPAREN STDIN RPAREN SEMICOLON .)
    ECHO            reduce using rule 25 (fgets -> ID EQUAL FGETS LPAREN STDIN RPAREN SEMICOLON .)
    INTEGER         reduce using rule 25 (fgets -> ID EQUAL FGETS LPAREN STDIN RPAREN SEMICOLON .)
    FLOAT           reduce using rule 25 (fgets -> ID EQUAL FGETS LPAREN STDIN RPAREN SEMICOLON .)
    STRING          reduce using rule 25 (fgets -> ID EQUAL FGETS LPAREN STDIN RPAREN SEMICOLON .)
    BOOL            reduce using rule 25 (fgets -> ID EQUAL FGETS LPAREN STDIN RPAREN SEMICOLON .)
    NULL            reduce using rule 25 (fgets -> ID EQUAL FGETS LPAREN STDIN RPAREN SEMICOLON .)
    $end            reduce using rule 25 (fgets -> ID EQUAL FGETS LPAREN STDIN RPAREN SEMICOLON .)
    SEMICOLON       reduce using rule 25 (fgets -> ID EQUAL FGETS LPAREN STDIN RPAREN SEMICOLON .)


state 70

    (17) queueEnqueue -> ID OBJOP PUSH LPAREN value RPAREN SEMICOLON .

    SWITCH          reduce using rule 17 (queueEnqueue -> ID OBJOP PUSH LPAREN value RPAREN SEMICOLON .)
    ID              reduce using rule 17 (queueEnqueue -> ID OBJOP PUSH LPAREN value RPAREN SEMICOLON .)
    FN              reduce using rule 17 (queueEnqueue -> ID OBJOP PUSH LPAREN value RPAREN SEMICOLON .)
    ECHO            reduce using rule 17 (queueEnqueue -> ID OBJOP PUSH LPAREN value RPAREN SEMICOLON .)
    INTEGER         reduce using rule 17 (queueEnqueue -> ID OBJOP PUSH LPAREN value RPAREN SEMICOLON .)
    FLOAT           reduce using rule 17 (queueEnqueue -> ID OBJOP PUSH LPAREN value RPAREN SEMICOLON .)
    STRING          reduce using rule 17 (queueEnqueue -> ID OBJOP PUSH LPAREN value RPAREN SEMICOLON .)
    BOOL            reduce using rule 17 (queueEnqueue -> ID OBJOP PUSH LPAREN value RPAREN SEMICOLON .)
    NULL            reduce using rule 17 (queueEnqueue -> ID OBJOP PUSH LPAREN value RPAREN SEMICOLON .)
    $end            reduce using rule 17 (queueEnqueue -> ID OBJOP PUSH LPAREN value RPAREN SEMICOLON .)
    SEMICOLON       reduce using rule 17 (queueEnqueue -> ID OBJOP PUSH LPAREN value RPAREN SEMICOLON .)


state 71

    (20) arrowBody -> FN LPAREN . ID RPAREN FNARROW arrowBody
    (19) arrowFunction -> FN LPAREN . ID RPAREN FNARROW arrowBody SEMICOLON

    ID              shift and go to state 76


state 72

    (19) arrowFunction -> FN LPAREN ID RPAREN FNARROW arrowBody SEMICOLON .

    SWITCH          reduce using rule 19 (arrowFunction -> FN LPAREN ID RPAREN FNARROW arrowBody SEMICOLON .)
    ID              reduce using rule 19 (arrowFunction -> FN LPAREN ID RPAREN FNARROW arrowBody SEMICOLON .)
    FN              reduce using rule 19 (arrowFunction -> FN LPAREN ID RPAREN FNARROW arrowBody SEMICOLON .)
    ECHO            reduce using rule 19 (arrowFunction -> FN LPAREN ID RPAREN FNARROW arrowBody SEMICOLON .)
    INTEGER         reduce using rule 19 (arrowFunction -> FN LPAREN ID RPAREN FNARROW arrowBody SEMICOLON .)
    FLOAT           reduce using rule 19 (arrowFunction -> FN LPAREN ID RPAREN FNARROW arrowBody SEMICOLON .)
    STRING          reduce using rule 19 (arrowFunction -> FN LPAREN ID RPAREN FNARROW arrowBody SEMICOLON .)
    BOOL            reduce using rule 19 (arrowFunction -> FN LPAREN ID RPAREN FNARROW arrowBody SEMICOLON .)
    NULL            reduce using rule 19 (arrowFunction -> FN LPAREN ID RPAREN FNARROW arrowBody SEMICOLON .)
    $end            reduce using rule 19 (arrowFunction -> FN LPAREN ID RPAREN FNARROW arrowBody SEMICOLON .)
    SEMICOLON       reduce using rule 19 (arrowFunction -> FN LPAREN ID RPAREN FNARROW arrowBody SEMICOLON .)


state 73

    (11) switchStatement -> SWITCH LPAREN value RPAREN LCURLY switchCases switchDefault RCURLY .

    SWITCH          reduce using rule 11 (switchStatement -> SWITCH LPAREN value RPAREN LCURLY switchCases switchDefault RCURLY .)
    ID              reduce using rule 11 (switchStatement -> SWITCH LPAREN value RPAREN LCURLY switchCases switchDefault RCURLY .)
    FN              reduce using rule 11 (switchStatement -> SWITCH LPAREN value RPAREN LCURLY switchCases switchDefault RCURLY .)
    ECHO            reduce using rule 11 (switchStatement -> SWITCH LPAREN value RPAREN LCURLY switchCases switchDefault RCURLY .)
    INTEGER         reduce using rule 11 (switchStatement -> SWITCH LPAREN value RPAREN LCURLY switchCases switchDefault RCURLY .)
    FLOAT           reduce using rule 11 (switchStatement -> SWITCH LPAREN value RPAREN LCURLY switchCases switchDefault RCURLY .)
    STRING          reduce using rule 11 (switchStatement -> SWITCH LPAREN value RPAREN LCURLY switchCases switchDefault RCURLY .)
    BOOL            reduce using rule 11 (switchStatement -> SWITCH LPAREN value RPAREN LCURLY switchCases switchDefault RCURLY .)
    NULL            reduce using rule 11 (switchStatement -> SWITCH LPAREN value RPAREN LCURLY switchCases switchDefault RCURLY .)
    $end            reduce using rule 11 (switchStatement -> SWITCH LPAREN value RPAREN LCURLY switchCases switchDefault RCURLY .)
    SEMICOLON       reduce using rule 11 (switchStatement -> SWITCH LPAREN value RPAREN LCURLY switchCases switchDefault RCURLY .)


state 74

    (12) switchDefault -> DEFAULT COLON . arithmeticExpression
    (26) arithmeticExpression -> . value arithmeticOperator value
    (27) value -> . ID
    (28) value -> . INTEGER
    (29) value -> . FLOAT
    (30) value -> . STRING
    (31) value -> . BOOL
    (32) value -> . NULL

    ID              shift and go to state 35
    INTEGER         shift and go to state 16
    FLOAT           shift and go to state 17
    STRING          shift and go to state 18
    BOOL            shift and go to state 19
    NULL            shift and go to state 20

    arithmeticExpression           shift and go to state 77
    value                          shift and go to state 11

state 75

    (13) switchCase -> CASE value COLON . arithmeticExpression BREAK SEMICOLON
    (26) arithmeticExpression -> . value arithmeticOperator value
    (27) value -> . ID
    (28) value -> . INTEGER
    (29) value -> . FLOAT
    (30) value -> . STRING
    (31) value -> . BOOL
    (32) value -> . NULL

    ID              shift and go to state 35
    INTEGER         shift and go to state 16
    FLOAT           shift and go to state 17
    STRING          shift and go to state 18
    BOOL            shift and go to state 19
    NULL            shift and go to state 20

    value                          shift and go to state 11
    arithmeticExpression           shift and go to state 78

state 76

    (20) arrowBody -> FN LPAREN ID . RPAREN FNARROW arrowBody
    (19) arrowFunction -> FN LPAREN ID . RPAREN FNARROW arrowBody SEMICOLON

    RPAREN          shift and go to state 79


state 77

    (12) switchDefault -> DEFAULT COLON arithmeticExpression .

    RCURLY          reduce using rule 12 (switchDefault -> DEFAULT COLON arithmeticExpression .)


state 78

    (13) switchCase -> CASE value COLON arithmeticExpression . BREAK SEMICOLON

    BREAK           shift and go to state 80


state 79

    (20) arrowBody -> FN LPAREN ID RPAREN . FNARROW arrowBody
    (19) arrowFunction -> FN LPAREN ID RPAREN . FNARROW arrowBody SEMICOLON

    FNARROW         shift and go to state 81


state 80

    (13) switchCase -> CASE value COLON arithmeticExpression BREAK . SEMICOLON

    SEMICOLON       shift and go to state 82


state 81

    (20) arrowBody -> FN LPAREN ID RPAREN FNARROW . arrowBody
    (19) arrowFunction -> FN LPAREN ID RPAREN FNARROW . arrowBody SEMICOLON
    (20) arrowBody -> . FN LPAREN ID RPAREN FNARROW arrowBody
    (21) arrowBody -> . cuerpo
    (3) cuerpo -> . arithmeticExpression
    (4) cuerpo -> . switchStatement
    (5) cuerpo -> . queueDeclaration
    (6) cuerpo -> . queueEnqueue
    (7) cuerpo -> . queueDequeue
    (8) cuerpo -> . arrowFunction
    (9) cuerpo -> . echo
    (10) cuerpo -> . fgets
    (26) arithmeticExpression -> . value arithmeticOperator value
    (11) switchStatement -> . SWITCH LPAREN value RPAREN LCURLY switchCases switchDefault RCURLY
    (16) queueDeclaration -> . ID EQUAL NEW QUEUE SEMICOLON
    (17) queueEnqueue -> . ID OBJOP PUSH LPAREN value RPAREN SEMICOLON
    (18) queueDequeue -> . ID OBJOP POP SEMICOLON
    (19) arrowFunction -> . FN LPAREN ID RPAREN FNARROW arrowBody SEMICOLON
    (22) echo -> . ECHO values SEMICOLON
    (25) fgets -> . ID EQUAL FGETS LPAREN STDIN RPAREN SEMICOLON
    (27) value -> . ID
    (28) value -> . INTEGER
    (29) value -> . FLOAT
    (30) value -> . STRING
    (31) value -> . BOOL
    (32) value -> . NULL

    FN              shift and go to state 62
    SWITCH          shift and go to state 12
    ID              shift and go to state 13
    ECHO            shift and go to state 15
    INTEGER         shift and go to state 16
    FLOAT           shift and go to state 17
    STRING          shift and go to state 18
    BOOL            shift and go to state 19
    NULL            shift and go to state 20

    arrowBody                      shift and go to state 83
    cuerpo                         shift and go to state 64
    arithmeticExpression           shift and go to state 3
    switchStatement                shift and go to state 4
    queueDeclaration               shift and go to state 5
    queueEnqueue                   shift and go to state 6
    queueDequeue                   shift and go to state 7
    arrowFunction                  shift and go to state 8
    echo                           shift and go to state 9
    fgets                          shift and go to state 10
    value                          shift and go to state 11

state 82

    (13) switchCase -> CASE value COLON arithmeticExpression BREAK SEMICOLON .

    DEFAULT         reduce using rule 13 (switchCase -> CASE value COLON arithmeticExpression BREAK SEMICOLON .)
    CASE            reduce using rule 13 (switchCase -> CASE value COLON arithmeticExpression BREAK SEMICOLON .)


state 83

    (20) arrowBody -> FN LPAREN ID RPAREN FNARROW arrowBody .
    (19) arrowFunction -> FN LPAREN ID RPAREN FNARROW arrowBody . SEMICOLON

  ! shift/reduce conflict for SEMICOLON resolved as shift
    SEMICOLON       shift and go to state 72

  ! SEMICOLON       [ reduce using rule 20 (arrowBody -> FN LPAREN ID RPAREN FNARROW arrowBody .) ]

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for SEMICOLON in state 83 resolved as shift
