Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    ABSTRACT
    AND
    ARRAY
    AS
    BITAND
    BITNOT
    BITOR
    CALLABLE
    CATCH
    CLASS
    CLONE
    CLOSE_TAG
    CONCAT
    CONCATASSIGN
    CONST
    DECLARE
    DECREMENT
    DIE
    DIVIDEASSIGN
    DO
    DOC_COMMENT
    DOUBLEQUOTE
    ELSEIF
    EMPTY
    ENDWHILE
    ERRORCONTROL
    EVAL
    EXECUTION
    EXIT
    EXPASSIGN
    EXTENDS
    FINAL
    FINALLY
    FOREACH
    GLOBAL
    GOTO
    IMPLEMENTS
    INCLUDE
    INCLUDE_ONCE
    INCREMENT
    INSTANCEOF
    INSTEADOF
    INTERFACE
    ISSET
    LIST
    LOGICALNOT
    LSQUARE
    MATCH
    MINUSASSIGN
    MODASSIGN
    NAMESPACE
    OPEN_TAG
    OR
    PLUSASSIGN
    PRIVATE
    PROTECTED
    PUBLIC
    QUOTE
    REQUIRE
    REQUIRE_ONCE
    RETURN
    RSQUARE
    STATIC
    THROW
    TIMESASSIGN
    TRAIT
    TRY
    UNSET
    USE
    VAR
    WHILE
    XOR
    YIELD
    YIELD_FROM
    __HALT_COMPILER

Grammar

Rule 0     S' -> programa
Rule 1     programa -> cuerpo
Rule 2     programa -> programa cuerpo
Rule 3     cuerpo -> arithmeticExpression
Rule 4     cuerpo -> if_elseStatement
Rule 5     cuerpo -> forStatement
Rule 6     cuerpo -> switchStatement
Rule 7     cuerpo -> queueDeclaration
Rule 8     cuerpo -> queueEnqueue
Rule 9     cuerpo -> queueDequeue
Rule 10    cuerpo -> defineFunction
Rule 11    cuerpo -> anonymousFunction
Rule 12    cuerpo -> arrowFunction
Rule 13    cuerpo -> echo
Rule 14    cuerpo -> fgets
Rule 15    cuerpo -> stackDeclaration
Rule 16    cuerpo -> stackPush
Rule 17    cuerpo -> stackPop
Rule 18    cuerpo -> line
Rule 19    cuerpo -> print
Rule 20    switchStatement -> SWITCH LPAREN value RPAREN LCURLY switchCases switchDefault RCURLY
Rule 21    switchDefault -> DEFAULT COLON cuerpo
Rule 22    switchCase -> CASE value COLON cuerpo BREAK SEMICOLON
Rule 23    switchCases -> switchCase
Rule 24    switchCases -> switchCases switchCase
Rule 25    if_elseStatement -> IF LPAREN comparingValue RPAREN LCURLY ifStatementBody RCURLY ELSE ifStatementBody
Rule 26    if_elseStatement -> IF LPAREN comparingValue RPAREN LCURLY ifStatementBody
Rule 27    ifStatementBody -> cuerpo
Rule 28    ifStatementBody -> cuerpo CONTINUE SEMICOLON
Rule 29    ifStatementBody -> ifStatementBody cuerpo
Rule 30    forStatement -> FOR LPAREN forStatementCondition RPAREN LCURLY forStatementBody RCURLY
Rule 31    forStatementCondition -> SEMICOLON SEMICOLON
Rule 32    forStatementCondition -> variableAsignation SEMICOLON SEMICOLON variableAsignation
Rule 33    forStatementCondition -> variableAsignation SEMICOLON comparingValue SEMICOLON variableAsignation
Rule 34    forStatementBody -> cuerpo
Rule 35    forStatementBody -> forStatementBody cuerpo
Rule 36    stackDeclaration -> ID EQUAL NEW STACK SEMICOLON
Rule 37    stackPush -> ID OBJOP PUSH LPAREN value RPAREN SEMICOLON
Rule 38    stackPop -> ID OBJOP POP SEMICOLON
Rule 39    queueDeclaration -> ID EQUAL NEW QUEUE SEMICOLON
Rule 40    queueEnqueue -> ID OBJOP PUSH LPAREN value RPAREN SEMICOLON
Rule 41    queueDequeue -> ID OBJOP POP SEMICOLON
Rule 42    defineFunction -> FUNCTION ID LPAREN arguments RPAREN LCURLY cuerpo RCURLY
Rule 43    defineFunction -> FUNCTION ID LPAREN RPAREN LCURLY cuerpo RCURLY
Rule 44    arguments -> ID
Rule 45    arguments -> ID COMMA arguments
Rule 46    anonymousFunction -> FUNCTION LPAREN RPAREN LCURLY cuerpo RCURLY
Rule 47    anonymousFunction -> FUNCTION LPAREN arguments RPAREN LCURLY cuerpo RCURLY
Rule 48    arrowFunction -> FN LPAREN ID RPAREN FNARROW arrowBody SEMICOLON
Rule 49    arrowBody -> FN LPAREN ID RPAREN FNARROW arrowBody
Rule 50    arrowBody -> cuerpo
Rule 51    echo -> ECHO values SEMICOLON
Rule 52    print -> PRINT LPAREN values RPAREN SEMICOLON
Rule 53    print -> PRINT value SEMICOLON
Rule 54    values -> value
Rule 55    values -> values COMMA value
Rule 56    fgets -> ID EQUAL FGETS LPAREN STDIN RPAREN SEMICOLON
Rule 57    arithmeticExpression -> value arithmeticOperator value
Rule 58    value -> ID
Rule 59    value -> INTEGER
Rule 60    value -> FLOAT
Rule 61    value -> STRING
Rule 62    value -> BOOL
Rule 63    value -> NULL
Rule 64    arithmeticOperator -> PLUS
Rule 65    arithmeticOperator -> MINUS
Rule 66    arithmeticOperator -> TIMES
Rule 67    arithmeticOperator -> DIVIDE
Rule 68    arithmeticOperator -> MOD
Rule 69    arithmeticOperator -> EXP
Rule 70    line -> variableAsignation SEMICOLON
Rule 71    variableAsignation -> ID EQUAL value
Rule 72    variableAsignation -> ID EQUAL arithmeticExpression
Rule 73    comparingSign -> IS_EQUAL
Rule 74    comparingSign -> IDENTICAL
Rule 75    comparingSign -> NOTEQUAL
Rule 76    comparingSign -> LESSTHAN
Rule 77    comparingSign -> GREATERTHAN
Rule 78    comparingSign -> LESSEQUALTHAN
Rule 79    comparingSign -> GREATEREQUALTHAN
Rule 80    comparingValue -> value comparingSign value

Terminals, with rules where they appear

ABSTRACT             : 
AND                  : 
ARRAY                : 
AS                   : 
BITAND               : 
BITNOT               : 
BITOR                : 
BOOL                 : 62
BREAK                : 22
CALLABLE             : 
CASE                 : 22
CATCH                : 
CLASS                : 
CLONE                : 
CLOSE_TAG            : 
COLON                : 21 22
COMMA                : 45 55
CONCAT               : 
CONCATASSIGN         : 
CONST                : 
CONTINUE             : 28
DECLARE              : 
DECREMENT            : 
DEFAULT              : 21
DIE                  : 
DIVIDE               : 67
DIVIDEASSIGN         : 
DO                   : 
DOC_COMMENT          : 
DOUBLEQUOTE          : 
ECHO                 : 51
ELSE                 : 25
ELSEIF               : 
EMPTY                : 
ENDWHILE             : 
EQUAL                : 36 39 56 71 72
ERRORCONTROL         : 
EVAL                 : 
EXECUTION            : 
EXIT                 : 
EXP                  : 69
EXPASSIGN            : 
EXTENDS              : 
FGETS                : 56
FINAL                : 
FINALLY              : 
FLOAT                : 60
FN                   : 48 49
FNARROW              : 48 49
FOR                  : 30
FOREACH              : 
FUNCTION             : 42 43 46 47
GLOBAL               : 
GOTO                 : 
GREATEREQUALTHAN     : 79
GREATERTHAN          : 77
ID                   : 36 37 38 39 40 41 42 43 44 45 48 49 56 58 71 72
IDENTICAL            : 74
IF                   : 25 26
IMPLEMENTS           : 
INCLUDE              : 
INCLUDE_ONCE         : 
INCREMENT            : 
INSTANCEOF           : 
INSTEADOF            : 
INTEGER              : 59
INTERFACE            : 
ISSET                : 
IS_EQUAL             : 73
LCURLY               : 20 25 26 30 42 43 46 47
LESSEQUALTHAN        : 78
LESSTHAN             : 76
LIST                 : 
LOGICALNOT           : 
LPAREN               : 20 25 26 30 37 40 42 43 46 47 48 49 52 56
LSQUARE              : 
MATCH                : 
MINUS                : 65
MINUSASSIGN          : 
MOD                  : 68
MODASSIGN            : 
NAMESPACE            : 
NEW                  : 36 39
NOTEQUAL             : 75
NULL                 : 63
OBJOP                : 37 38 40 41
OPEN_TAG             : 
OR                   : 
PLUS                 : 64
PLUSASSIGN           : 
POP                  : 38 41
PRINT                : 52 53
PRIVATE              : 
PROTECTED            : 
PUBLIC               : 
PUSH                 : 37 40
QUEUE                : 39
QUOTE                : 
RCURLY               : 20 25 30 42 43 46 47
REQUIRE              : 
REQUIRE_ONCE         : 
RETURN               : 
RPAREN               : 20 25 26 30 37 40 42 43 46 47 48 49 52 56
RSQUARE              : 
SEMICOLON            : 22 28 31 31 32 32 33 33 36 37 38 39 40 41 48 51 52 53 56 70
STACK                : 36
STATIC               : 
STDIN                : 56
STRING               : 61
SWITCH               : 20
THROW                : 
TIMES                : 66
TIMESASSIGN          : 
TRAIT                : 
TRY                  : 
UNSET                : 
USE                  : 
VAR                  : 
WHILE                : 
XOR                  : 
YIELD                : 
YIELD_FROM           : 
__HALT_COMPILER      : 
error                : 

Nonterminals, with rules where they appear

anonymousFunction    : 11
arguments            : 42 45 47
arithmeticExpression : 3 72
arithmeticOperator   : 57
arrowBody            : 48 49
arrowFunction        : 12
comparingSign        : 80
comparingValue       : 25 26 33
cuerpo               : 1 2 21 22 27 28 29 34 35 42 43 46 47 50
defineFunction       : 10
echo                 : 13
fgets                : 14
forStatement         : 5
forStatementBody     : 30 35
forStatementCondition : 30
ifStatementBody      : 25 25 26 29
if_elseStatement     : 4
line                 : 18
print                : 19
programa             : 2 0
queueDeclaration     : 7
queueDequeue         : 9
queueEnqueue         : 8
stackDeclaration     : 15
stackPop             : 17
stackPush            : 16
switchCase           : 23 24
switchCases          : 20 24
switchDefault        : 20
switchStatement      : 6
value                : 20 22 37 40 53 54 55 57 57 71 80 80
values               : 51 52 55
variableAsignation   : 32 32 33 33 70

Parsing method: LALR

state 0

    (0) S' -> . programa
    (1) programa -> . cuerpo
    (2) programa -> . programa cuerpo
    (3) cuerpo -> . arithmeticExpression
    (4) cuerpo -> . if_elseStatement
    (5) cuerpo -> . forStatement
    (6) cuerpo -> . switchStatement
    (7) cuerpo -> . queueDeclaration
    (8) cuerpo -> . queueEnqueue
    (9) cuerpo -> . queueDequeue
    (10) cuerpo -> . defineFunction
    (11) cuerpo -> . anonymousFunction
    (12) cuerpo -> . arrowFunction
    (13) cuerpo -> . echo
    (14) cuerpo -> . fgets
    (15) cuerpo -> . stackDeclaration
    (16) cuerpo -> . stackPush
    (17) cuerpo -> . stackPop
    (18) cuerpo -> . line
    (19) cuerpo -> . print
    (57) arithmeticExpression -> . value arithmeticOperator value
    (25) if_elseStatement -> . IF LPAREN comparingValue RPAREN LCURLY ifStatementBody RCURLY ELSE ifStatementBody
    (26) if_elseStatement -> . IF LPAREN comparingValue RPAREN LCURLY ifStatementBody
    (30) forStatement -> . FOR LPAREN forStatementCondition RPAREN LCURLY forStatementBody RCURLY
    (20) switchStatement -> . SWITCH LPAREN value RPAREN LCURLY switchCases switchDefault RCURLY
    (39) queueDeclaration -> . ID EQUAL NEW QUEUE SEMICOLON
    (40) queueEnqueue -> . ID OBJOP PUSH LPAREN value RPAREN SEMICOLON
    (41) queueDequeue -> . ID OBJOP POP SEMICOLON
    (42) defineFunction -> . FUNCTION ID LPAREN arguments RPAREN LCURLY cuerpo RCURLY
    (43) defineFunction -> . FUNCTION ID LPAREN RPAREN LCURLY cuerpo RCURLY
    (46) anonymousFunction -> . FUNCTION LPAREN RPAREN LCURLY cuerpo RCURLY
    (47) anonymousFunction -> . FUNCTION LPAREN arguments RPAREN LCURLY cuerpo RCURLY
    (48) arrowFunction -> . FN LPAREN ID RPAREN FNARROW arrowBody SEMICOLON
    (51) echo -> . ECHO values SEMICOLON
    (56) fgets -> . ID EQUAL FGETS LPAREN STDIN RPAREN SEMICOLON
    (36) stackDeclaration -> . ID EQUAL NEW STACK SEMICOLON
    (37) stackPush -> . ID OBJOP PUSH LPAREN value RPAREN SEMICOLON
    (38) stackPop -> . ID OBJOP POP SEMICOLON
    (70) line -> . variableAsignation SEMICOLON
    (52) print -> . PRINT LPAREN values RPAREN SEMICOLON
    (53) print -> . PRINT value SEMICOLON
    (58) value -> . ID
    (59) value -> . INTEGER
    (60) value -> . FLOAT
    (61) value -> . STRING
    (62) value -> . BOOL
    (63) value -> . NULL
    (71) variableAsignation -> . ID EQUAL value
    (72) variableAsignation -> . ID EQUAL arithmeticExpression

    IF              shift and go to state 21
    FOR             shift and go to state 22
    SWITCH          shift and go to state 23
    ID              shift and go to state 24
    FUNCTION        shift and go to state 25
    FN              shift and go to state 26
    ECHO            shift and go to state 27
    PRINT           shift and go to state 29
    INTEGER         shift and go to state 30
    FLOAT           shift and go to state 31
    STRING          shift and go to state 32
    BOOL            shift and go to state 33
    NULL            shift and go to state 34

    programa                       shift and go to state 1
    cuerpo                         shift and go to state 2
    arithmeticExpression           shift and go to state 3
    if_elseStatement               shift and go to state 4
    forStatement                   shift and go to state 5
    switchStatement                shift and go to state 6
    queueDeclaration               shift and go to state 7
    queueEnqueue                   shift and go to state 8
    queueDequeue                   shift and go to state 9
    defineFunction                 shift and go to state 10
    anonymousFunction              shift and go to state 11
    arrowFunction                  shift and go to state 12
    echo                           shift and go to state 13
    fgets                          shift and go to state 14
    stackDeclaration               shift and go to state 15
    stackPush                      shift and go to state 16
    stackPop                       shift and go to state 17
    line                           shift and go to state 18
    print                          shift and go to state 19
    value                          shift and go to state 20
    variableAsignation             shift and go to state 28

state 1

    (0) S' -> programa .
    (2) programa -> programa . cuerpo
    (3) cuerpo -> . arithmeticExpression
    (4) cuerpo -> . if_elseStatement
    (5) cuerpo -> . forStatement
    (6) cuerpo -> . switchStatement
    (7) cuerpo -> . queueDeclaration
    (8) cuerpo -> . queueEnqueue
    (9) cuerpo -> . queueDequeue
    (10) cuerpo -> . defineFunction
    (11) cuerpo -> . anonymousFunction
    (12) cuerpo -> . arrowFunction
    (13) cuerpo -> . echo
    (14) cuerpo -> . fgets
    (15) cuerpo -> . stackDeclaration
    (16) cuerpo -> . stackPush
    (17) cuerpo -> . stackPop
    (18) cuerpo -> . line
    (19) cuerpo -> . print
    (57) arithmeticExpression -> . value arithmeticOperator value
    (25) if_elseStatement -> . IF LPAREN comparingValue RPAREN LCURLY ifStatementBody RCURLY ELSE ifStatementBody
    (26) if_elseStatement -> . IF LPAREN comparingValue RPAREN LCURLY ifStatementBody
    (30) forStatement -> . FOR LPAREN forStatementCondition RPAREN LCURLY forStatementBody RCURLY
    (20) switchStatement -> . SWITCH LPAREN value RPAREN LCURLY switchCases switchDefault RCURLY
    (39) queueDeclaration -> . ID EQUAL NEW QUEUE SEMICOLON
    (40) queueEnqueue -> . ID OBJOP PUSH LPAREN value RPAREN SEMICOLON
    (41) queueDequeue -> . ID OBJOP POP SEMICOLON
    (42) defineFunction -> . FUNCTION ID LPAREN arguments RPAREN LCURLY cuerpo RCURLY
    (43) defineFunction -> . FUNCTION ID LPAREN RPAREN LCURLY cuerpo RCURLY
    (46) anonymousFunction -> . FUNCTION LPAREN RPAREN LCURLY cuerpo RCURLY
    (47) anonymousFunction -> . FUNCTION LPAREN arguments RPAREN LCURLY cuerpo RCURLY
    (48) arrowFunction -> . FN LPAREN ID RPAREN FNARROW arrowBody SEMICOLON
    (51) echo -> . ECHO values SEMICOLON
    (56) fgets -> . ID EQUAL FGETS LPAREN STDIN RPAREN SEMICOLON
    (36) stackDeclaration -> . ID EQUAL NEW STACK SEMICOLON
    (37) stackPush -> . ID OBJOP PUSH LPAREN value RPAREN SEMICOLON
    (38) stackPop -> . ID OBJOP POP SEMICOLON
    (70) line -> . variableAsignation SEMICOLON
    (52) print -> . PRINT LPAREN values RPAREN SEMICOLON
    (53) print -> . PRINT value SEMICOLON
    (58) value -> . ID
    (59) value -> . INTEGER
    (60) value -> . FLOAT
    (61) value -> . STRING
    (62) value -> . BOOL
    (63) value -> . NULL
    (71) variableAsignation -> . ID EQUAL value
    (72) variableAsignation -> . ID EQUAL arithmeticExpression

    IF              shift and go to state 21
    FOR             shift and go to state 22
    SWITCH          shift and go to state 23
    ID              shift and go to state 24
    FUNCTION        shift and go to state 25
    FN              shift and go to state 26
    ECHO            shift and go to state 27
    PRINT           shift and go to state 29
    INTEGER         shift and go to state 30
    FLOAT           shift and go to state 31
    STRING          shift and go to state 32
    BOOL            shift and go to state 33
    NULL            shift and go to state 34

    cuerpo                         shift and go to state 35
    arithmeticExpression           shift and go to state 3
    if_elseStatement               shift and go to state 4
    forStatement                   shift and go to state 5
    switchStatement                shift and go to state 6
    queueDeclaration               shift and go to state 7
    queueEnqueue                   shift and go to state 8
    queueDequeue                   shift and go to state 9
    defineFunction                 shift and go to state 10
    anonymousFunction              shift and go to state 11
    arrowFunction                  shift and go to state 12
    echo                           shift and go to state 13
    fgets                          shift and go to state 14
    stackDeclaration               shift and go to state 15
    stackPush                      shift and go to state 16
    stackPop                       shift and go to state 17
    line                           shift and go to state 18
    print                          shift and go to state 19
    value                          shift and go to state 20
    variableAsignation             shift and go to state 28

state 2

    (1) programa -> cuerpo .

    IF              reduce using rule 1 (programa -> cuerpo .)
    FOR             reduce using rule 1 (programa -> cuerpo .)
    SWITCH          reduce using rule 1 (programa -> cuerpo .)
    ID              reduce using rule 1 (programa -> cuerpo .)
    FUNCTION        reduce using rule 1 (programa -> cuerpo .)
    FN              reduce using rule 1 (programa -> cuerpo .)
    ECHO            reduce using rule 1 (programa -> cuerpo .)
    PRINT           reduce using rule 1 (programa -> cuerpo .)
    INTEGER         reduce using rule 1 (programa -> cuerpo .)
    FLOAT           reduce using rule 1 (programa -> cuerpo .)
    STRING          reduce using rule 1 (programa -> cuerpo .)
    BOOL            reduce using rule 1 (programa -> cuerpo .)
    NULL            reduce using rule 1 (programa -> cuerpo .)
    $end            reduce using rule 1 (programa -> cuerpo .)


state 3

    (3) cuerpo -> arithmeticExpression .

    IF              reduce using rule 3 (cuerpo -> arithmeticExpression .)
    FOR             reduce using rule 3 (cuerpo -> arithmeticExpression .)
    SWITCH          reduce using rule 3 (cuerpo -> arithmeticExpression .)
    ID              reduce using rule 3 (cuerpo -> arithmeticExpression .)
    FUNCTION        reduce using rule 3 (cuerpo -> arithmeticExpression .)
    FN              reduce using rule 3 (cuerpo -> arithmeticExpression .)
    ECHO            reduce using rule 3 (cuerpo -> arithmeticExpression .)
    PRINT           reduce using rule 3 (cuerpo -> arithmeticExpression .)
    INTEGER         reduce using rule 3 (cuerpo -> arithmeticExpression .)
    FLOAT           reduce using rule 3 (cuerpo -> arithmeticExpression .)
    STRING          reduce using rule 3 (cuerpo -> arithmeticExpression .)
    BOOL            reduce using rule 3 (cuerpo -> arithmeticExpression .)
    NULL            reduce using rule 3 (cuerpo -> arithmeticExpression .)
    $end            reduce using rule 3 (cuerpo -> arithmeticExpression .)
    RCURLY          reduce using rule 3 (cuerpo -> arithmeticExpression .)
    CONTINUE        reduce using rule 3 (cuerpo -> arithmeticExpression .)
    SEMICOLON       reduce using rule 3 (cuerpo -> arithmeticExpression .)
    BREAK           reduce using rule 3 (cuerpo -> arithmeticExpression .)


state 4

    (4) cuerpo -> if_elseStatement .

    IF              reduce using rule 4 (cuerpo -> if_elseStatement .)
    FOR             reduce using rule 4 (cuerpo -> if_elseStatement .)
    SWITCH          reduce using rule 4 (cuerpo -> if_elseStatement .)
    ID              reduce using rule 4 (cuerpo -> if_elseStatement .)
    FUNCTION        reduce using rule 4 (cuerpo -> if_elseStatement .)
    FN              reduce using rule 4 (cuerpo -> if_elseStatement .)
    ECHO            reduce using rule 4 (cuerpo -> if_elseStatement .)
    PRINT           reduce using rule 4 (cuerpo -> if_elseStatement .)
    INTEGER         reduce using rule 4 (cuerpo -> if_elseStatement .)
    FLOAT           reduce using rule 4 (cuerpo -> if_elseStatement .)
    STRING          reduce using rule 4 (cuerpo -> if_elseStatement .)
    BOOL            reduce using rule 4 (cuerpo -> if_elseStatement .)
    NULL            reduce using rule 4 (cuerpo -> if_elseStatement .)
    $end            reduce using rule 4 (cuerpo -> if_elseStatement .)
    RCURLY          reduce using rule 4 (cuerpo -> if_elseStatement .)
    CONTINUE        reduce using rule 4 (cuerpo -> if_elseStatement .)
    SEMICOLON       reduce using rule 4 (cuerpo -> if_elseStatement .)
    BREAK           reduce using rule 4 (cuerpo -> if_elseStatement .)


state 5

    (5) cuerpo -> forStatement .

    IF              reduce using rule 5 (cuerpo -> forStatement .)
    FOR             reduce using rule 5 (cuerpo -> forStatement .)
    SWITCH          reduce using rule 5 (cuerpo -> forStatement .)
    ID              reduce using rule 5 (cuerpo -> forStatement .)
    FUNCTION        reduce using rule 5 (cuerpo -> forStatement .)
    FN              reduce using rule 5 (cuerpo -> forStatement .)
    ECHO            reduce using rule 5 (cuerpo -> forStatement .)
    PRINT           reduce using rule 5 (cuerpo -> forStatement .)
    INTEGER         reduce using rule 5 (cuerpo -> forStatement .)
    FLOAT           reduce using rule 5 (cuerpo -> forStatement .)
    STRING          reduce using rule 5 (cuerpo -> forStatement .)
    BOOL            reduce using rule 5 (cuerpo -> forStatement .)
    NULL            reduce using rule 5 (cuerpo -> forStatement .)
    $end            reduce using rule 5 (cuerpo -> forStatement .)
    RCURLY          reduce using rule 5 (cuerpo -> forStatement .)
    CONTINUE        reduce using rule 5 (cuerpo -> forStatement .)
    SEMICOLON       reduce using rule 5 (cuerpo -> forStatement .)
    BREAK           reduce using rule 5 (cuerpo -> forStatement .)


state 6

    (6) cuerpo -> switchStatement .

    IF              reduce using rule 6 (cuerpo -> switchStatement .)
    FOR             reduce using rule 6 (cuerpo -> switchStatement .)
    SWITCH          reduce using rule 6 (cuerpo -> switchStatement .)
    ID              reduce using rule 6 (cuerpo -> switchStatement .)
    FUNCTION        reduce using rule 6 (cuerpo -> switchStatement .)
    FN              reduce using rule 6 (cuerpo -> switchStatement .)
    ECHO            reduce using rule 6 (cuerpo -> switchStatement .)
    PRINT           reduce using rule 6 (cuerpo -> switchStatement .)
    INTEGER         reduce using rule 6 (cuerpo -> switchStatement .)
    FLOAT           reduce using rule 6 (cuerpo -> switchStatement .)
    STRING          reduce using rule 6 (cuerpo -> switchStatement .)
    BOOL            reduce using rule 6 (cuerpo -> switchStatement .)
    NULL            reduce using rule 6 (cuerpo -> switchStatement .)
    $end            reduce using rule 6 (cuerpo -> switchStatement .)
    RCURLY          reduce using rule 6 (cuerpo -> switchStatement .)
    CONTINUE        reduce using rule 6 (cuerpo -> switchStatement .)
    SEMICOLON       reduce using rule 6 (cuerpo -> switchStatement .)
    BREAK           reduce using rule 6 (cuerpo -> switchStatement .)


state 7

    (7) cuerpo -> queueDeclaration .

    IF              reduce using rule 7 (cuerpo -> queueDeclaration .)
    FOR             reduce using rule 7 (cuerpo -> queueDeclaration .)
    SWITCH          reduce using rule 7 (cuerpo -> queueDeclaration .)
    ID              reduce using rule 7 (cuerpo -> queueDeclaration .)
    FUNCTION        reduce using rule 7 (cuerpo -> queueDeclaration .)
    FN              reduce using rule 7 (cuerpo -> queueDeclaration .)
    ECHO            reduce using rule 7 (cuerpo -> queueDeclaration .)
    PRINT           reduce using rule 7 (cuerpo -> queueDeclaration .)
    INTEGER         reduce using rule 7 (cuerpo -> queueDeclaration .)
    FLOAT           reduce using rule 7 (cuerpo -> queueDeclaration .)
    STRING          reduce using rule 7 (cuerpo -> queueDeclaration .)
    BOOL            reduce using rule 7 (cuerpo -> queueDeclaration .)
    NULL            reduce using rule 7 (cuerpo -> queueDeclaration .)
    $end            reduce using rule 7 (cuerpo -> queueDeclaration .)
    RCURLY          reduce using rule 7 (cuerpo -> queueDeclaration .)
    CONTINUE        reduce using rule 7 (cuerpo -> queueDeclaration .)
    SEMICOLON       reduce using rule 7 (cuerpo -> queueDeclaration .)
    BREAK           reduce using rule 7 (cuerpo -> queueDeclaration .)


state 8

    (8) cuerpo -> queueEnqueue .

    IF              reduce using rule 8 (cuerpo -> queueEnqueue .)
    FOR             reduce using rule 8 (cuerpo -> queueEnqueue .)
    SWITCH          reduce using rule 8 (cuerpo -> queueEnqueue .)
    ID              reduce using rule 8 (cuerpo -> queueEnqueue .)
    FUNCTION        reduce using rule 8 (cuerpo -> queueEnqueue .)
    FN              reduce using rule 8 (cuerpo -> queueEnqueue .)
    ECHO            reduce using rule 8 (cuerpo -> queueEnqueue .)
    PRINT           reduce using rule 8 (cuerpo -> queueEnqueue .)
    INTEGER         reduce using rule 8 (cuerpo -> queueEnqueue .)
    FLOAT           reduce using rule 8 (cuerpo -> queueEnqueue .)
    STRING          reduce using rule 8 (cuerpo -> queueEnqueue .)
    BOOL            reduce using rule 8 (cuerpo -> queueEnqueue .)
    NULL            reduce using rule 8 (cuerpo -> queueEnqueue .)
    $end            reduce using rule 8 (cuerpo -> queueEnqueue .)
    RCURLY          reduce using rule 8 (cuerpo -> queueEnqueue .)
    CONTINUE        reduce using rule 8 (cuerpo -> queueEnqueue .)
    SEMICOLON       reduce using rule 8 (cuerpo -> queueEnqueue .)
    BREAK           reduce using rule 8 (cuerpo -> queueEnqueue .)


state 9

    (9) cuerpo -> queueDequeue .

    IF              reduce using rule 9 (cuerpo -> queueDequeue .)
    FOR             reduce using rule 9 (cuerpo -> queueDequeue .)
    SWITCH          reduce using rule 9 (cuerpo -> queueDequeue .)
    ID              reduce using rule 9 (cuerpo -> queueDequeue .)
    FUNCTION        reduce using rule 9 (cuerpo -> queueDequeue .)
    FN              reduce using rule 9 (cuerpo -> queueDequeue .)
    ECHO            reduce using rule 9 (cuerpo -> queueDequeue .)
    PRINT           reduce using rule 9 (cuerpo -> queueDequeue .)
    INTEGER         reduce using rule 9 (cuerpo -> queueDequeue .)
    FLOAT           reduce using rule 9 (cuerpo -> queueDequeue .)
    STRING          reduce using rule 9 (cuerpo -> queueDequeue .)
    BOOL            reduce using rule 9 (cuerpo -> queueDequeue .)
    NULL            reduce using rule 9 (cuerpo -> queueDequeue .)
    $end            reduce using rule 9 (cuerpo -> queueDequeue .)
    RCURLY          reduce using rule 9 (cuerpo -> queueDequeue .)
    CONTINUE        reduce using rule 9 (cuerpo -> queueDequeue .)
    SEMICOLON       reduce using rule 9 (cuerpo -> queueDequeue .)
    BREAK           reduce using rule 9 (cuerpo -> queueDequeue .)


state 10

    (10) cuerpo -> defineFunction .

    IF              reduce using rule 10 (cuerpo -> defineFunction .)
    FOR             reduce using rule 10 (cuerpo -> defineFunction .)
    SWITCH          reduce using rule 10 (cuerpo -> defineFunction .)
    ID              reduce using rule 10 (cuerpo -> defineFunction .)
    FUNCTION        reduce using rule 10 (cuerpo -> defineFunction .)
    FN              reduce using rule 10 (cuerpo -> defineFunction .)
    ECHO            reduce using rule 10 (cuerpo -> defineFunction .)
    PRINT           reduce using rule 10 (cuerpo -> defineFunction .)
    INTEGER         reduce using rule 10 (cuerpo -> defineFunction .)
    FLOAT           reduce using rule 10 (cuerpo -> defineFunction .)
    STRING          reduce using rule 10 (cuerpo -> defineFunction .)
    BOOL            reduce using rule 10 (cuerpo -> defineFunction .)
    NULL            reduce using rule 10 (cuerpo -> defineFunction .)
    $end            reduce using rule 10 (cuerpo -> defineFunction .)
    RCURLY          reduce using rule 10 (cuerpo -> defineFunction .)
    CONTINUE        reduce using rule 10 (cuerpo -> defineFunction .)
    SEMICOLON       reduce using rule 10 (cuerpo -> defineFunction .)
    BREAK           reduce using rule 10 (cuerpo -> defineFunction .)


state 11

    (11) cuerpo -> anonymousFunction .

    IF              reduce using rule 11 (cuerpo -> anonymousFunction .)
    FOR             reduce using rule 11 (cuerpo -> anonymousFunction .)
    SWITCH          reduce using rule 11 (cuerpo -> anonymousFunction .)
    ID              reduce using rule 11 (cuerpo -> anonymousFunction .)
    FUNCTION        reduce using rule 11 (cuerpo -> anonymousFunction .)
    FN              reduce using rule 11 (cuerpo -> anonymousFunction .)
    ECHO            reduce using rule 11 (cuerpo -> anonymousFunction .)
    PRINT           reduce using rule 11 (cuerpo -> anonymousFunction .)
    INTEGER         reduce using rule 11 (cuerpo -> anonymousFunction .)
    FLOAT           reduce using rule 11 (cuerpo -> anonymousFunction .)
    STRING          reduce using rule 11 (cuerpo -> anonymousFunction .)
    BOOL            reduce using rule 11 (cuerpo -> anonymousFunction .)
    NULL            reduce using rule 11 (cuerpo -> anonymousFunction .)
    $end            reduce using rule 11 (cuerpo -> anonymousFunction .)
    RCURLY          reduce using rule 11 (cuerpo -> anonymousFunction .)
    CONTINUE        reduce using rule 11 (cuerpo -> anonymousFunction .)
    SEMICOLON       reduce using rule 11 (cuerpo -> anonymousFunction .)
    BREAK           reduce using rule 11 (cuerpo -> anonymousFunction .)


state 12

    (12) cuerpo -> arrowFunction .

    IF              reduce using rule 12 (cuerpo -> arrowFunction .)
    FOR             reduce using rule 12 (cuerpo -> arrowFunction .)
    SWITCH          reduce using rule 12 (cuerpo -> arrowFunction .)
    ID              reduce using rule 12 (cuerpo -> arrowFunction .)
    FUNCTION        reduce using rule 12 (cuerpo -> arrowFunction .)
    FN              reduce using rule 12 (cuerpo -> arrowFunction .)
    ECHO            reduce using rule 12 (cuerpo -> arrowFunction .)
    PRINT           reduce using rule 12 (cuerpo -> arrowFunction .)
    INTEGER         reduce using rule 12 (cuerpo -> arrowFunction .)
    FLOAT           reduce using rule 12 (cuerpo -> arrowFunction .)
    STRING          reduce using rule 12 (cuerpo -> arrowFunction .)
    BOOL            reduce using rule 12 (cuerpo -> arrowFunction .)
    NULL            reduce using rule 12 (cuerpo -> arrowFunction .)
    $end            reduce using rule 12 (cuerpo -> arrowFunction .)
    RCURLY          reduce using rule 12 (cuerpo -> arrowFunction .)
    CONTINUE        reduce using rule 12 (cuerpo -> arrowFunction .)
    SEMICOLON       reduce using rule 12 (cuerpo -> arrowFunction .)
    BREAK           reduce using rule 12 (cuerpo -> arrowFunction .)


state 13

    (13) cuerpo -> echo .

    IF              reduce using rule 13 (cuerpo -> echo .)
    FOR             reduce using rule 13 (cuerpo -> echo .)
    SWITCH          reduce using rule 13 (cuerpo -> echo .)
    ID              reduce using rule 13 (cuerpo -> echo .)
    FUNCTION        reduce using rule 13 (cuerpo -> echo .)
    FN              reduce using rule 13 (cuerpo -> echo .)
    ECHO            reduce using rule 13 (cuerpo -> echo .)
    PRINT           reduce using rule 13 (cuerpo -> echo .)
    INTEGER         reduce using rule 13 (cuerpo -> echo .)
    FLOAT           reduce using rule 13 (cuerpo -> echo .)
    STRING          reduce using rule 13 (cuerpo -> echo .)
    BOOL            reduce using rule 13 (cuerpo -> echo .)
    NULL            reduce using rule 13 (cuerpo -> echo .)
    $end            reduce using rule 13 (cuerpo -> echo .)
    RCURLY          reduce using rule 13 (cuerpo -> echo .)
    CONTINUE        reduce using rule 13 (cuerpo -> echo .)
    SEMICOLON       reduce using rule 13 (cuerpo -> echo .)
    BREAK           reduce using rule 13 (cuerpo -> echo .)


state 14

    (14) cuerpo -> fgets .

    IF              reduce using rule 14 (cuerpo -> fgets .)
    FOR             reduce using rule 14 (cuerpo -> fgets .)
    SWITCH          reduce using rule 14 (cuerpo -> fgets .)
    ID              reduce using rule 14 (cuerpo -> fgets .)
    FUNCTION        reduce using rule 14 (cuerpo -> fgets .)
    FN              reduce using rule 14 (cuerpo -> fgets .)
    ECHO            reduce using rule 14 (cuerpo -> fgets .)
    PRINT           reduce using rule 14 (cuerpo -> fgets .)
    INTEGER         reduce using rule 14 (cuerpo -> fgets .)
    FLOAT           reduce using rule 14 (cuerpo -> fgets .)
    STRING          reduce using rule 14 (cuerpo -> fgets .)
    BOOL            reduce using rule 14 (cuerpo -> fgets .)
    NULL            reduce using rule 14 (cuerpo -> fgets .)
    $end            reduce using rule 14 (cuerpo -> fgets .)
    RCURLY          reduce using rule 14 (cuerpo -> fgets .)
    CONTINUE        reduce using rule 14 (cuerpo -> fgets .)
    SEMICOLON       reduce using rule 14 (cuerpo -> fgets .)
    BREAK           reduce using rule 14 (cuerpo -> fgets .)


state 15

    (15) cuerpo -> stackDeclaration .

    IF              reduce using rule 15 (cuerpo -> stackDeclaration .)
    FOR             reduce using rule 15 (cuerpo -> stackDeclaration .)
    SWITCH          reduce using rule 15 (cuerpo -> stackDeclaration .)
    ID              reduce using rule 15 (cuerpo -> stackDeclaration .)
    FUNCTION        reduce using rule 15 (cuerpo -> stackDeclaration .)
    FN              reduce using rule 15 (cuerpo -> stackDeclaration .)
    ECHO            reduce using rule 15 (cuerpo -> stackDeclaration .)
    PRINT           reduce using rule 15 (cuerpo -> stackDeclaration .)
    INTEGER         reduce using rule 15 (cuerpo -> stackDeclaration .)
    FLOAT           reduce using rule 15 (cuerpo -> stackDeclaration .)
    STRING          reduce using rule 15 (cuerpo -> stackDeclaration .)
    BOOL            reduce using rule 15 (cuerpo -> stackDeclaration .)
    NULL            reduce using rule 15 (cuerpo -> stackDeclaration .)
    $end            reduce using rule 15 (cuerpo -> stackDeclaration .)
    RCURLY          reduce using rule 15 (cuerpo -> stackDeclaration .)
    CONTINUE        reduce using rule 15 (cuerpo -> stackDeclaration .)
    SEMICOLON       reduce using rule 15 (cuerpo -> stackDeclaration .)
    BREAK           reduce using rule 15 (cuerpo -> stackDeclaration .)


state 16

    (16) cuerpo -> stackPush .

    IF              reduce using rule 16 (cuerpo -> stackPush .)
    FOR             reduce using rule 16 (cuerpo -> stackPush .)
    SWITCH          reduce using rule 16 (cuerpo -> stackPush .)
    ID              reduce using rule 16 (cuerpo -> stackPush .)
    FUNCTION        reduce using rule 16 (cuerpo -> stackPush .)
    FN              reduce using rule 16 (cuerpo -> stackPush .)
    ECHO            reduce using rule 16 (cuerpo -> stackPush .)
    PRINT           reduce using rule 16 (cuerpo -> stackPush .)
    INTEGER         reduce using rule 16 (cuerpo -> stackPush .)
    FLOAT           reduce using rule 16 (cuerpo -> stackPush .)
    STRING          reduce using rule 16 (cuerpo -> stackPush .)
    BOOL            reduce using rule 16 (cuerpo -> stackPush .)
    NULL            reduce using rule 16 (cuerpo -> stackPush .)
    $end            reduce using rule 16 (cuerpo -> stackPush .)
    RCURLY          reduce using rule 16 (cuerpo -> stackPush .)
    CONTINUE        reduce using rule 16 (cuerpo -> stackPush .)
    SEMICOLON       reduce using rule 16 (cuerpo -> stackPush .)
    BREAK           reduce using rule 16 (cuerpo -> stackPush .)


state 17

    (17) cuerpo -> stackPop .

    IF              reduce using rule 17 (cuerpo -> stackPop .)
    FOR             reduce using rule 17 (cuerpo -> stackPop .)
    SWITCH          reduce using rule 17 (cuerpo -> stackPop .)
    ID              reduce using rule 17 (cuerpo -> stackPop .)
    FUNCTION        reduce using rule 17 (cuerpo -> stackPop .)
    FN              reduce using rule 17 (cuerpo -> stackPop .)
    ECHO            reduce using rule 17 (cuerpo -> stackPop .)
    PRINT           reduce using rule 17 (cuerpo -> stackPop .)
    INTEGER         reduce using rule 17 (cuerpo -> stackPop .)
    FLOAT           reduce using rule 17 (cuerpo -> stackPop .)
    STRING          reduce using rule 17 (cuerpo -> stackPop .)
    BOOL            reduce using rule 17 (cuerpo -> stackPop .)
    NULL            reduce using rule 17 (cuerpo -> stackPop .)
    $end            reduce using rule 17 (cuerpo -> stackPop .)
    RCURLY          reduce using rule 17 (cuerpo -> stackPop .)
    CONTINUE        reduce using rule 17 (cuerpo -> stackPop .)
    SEMICOLON       reduce using rule 17 (cuerpo -> stackPop .)
    BREAK           reduce using rule 17 (cuerpo -> stackPop .)


state 18

    (18) cuerpo -> line .

    IF              reduce using rule 18 (cuerpo -> line .)
    FOR             reduce using rule 18 (cuerpo -> line .)
    SWITCH          reduce using rule 18 (cuerpo -> line .)
    ID              reduce using rule 18 (cuerpo -> line .)
    FUNCTION        reduce using rule 18 (cuerpo -> line .)
    FN              reduce using rule 18 (cuerpo -> line .)
    ECHO            reduce using rule 18 (cuerpo -> line .)
    PRINT           reduce using rule 18 (cuerpo -> line .)
    INTEGER         reduce using rule 18 (cuerpo -> line .)
    FLOAT           reduce using rule 18 (cuerpo -> line .)
    STRING          reduce using rule 18 (cuerpo -> line .)
    BOOL            reduce using rule 18 (cuerpo -> line .)
    NULL            reduce using rule 18 (cuerpo -> line .)
    $end            reduce using rule 18 (cuerpo -> line .)
    RCURLY          reduce using rule 18 (cuerpo -> line .)
    CONTINUE        reduce using rule 18 (cuerpo -> line .)
    SEMICOLON       reduce using rule 18 (cuerpo -> line .)
    BREAK           reduce using rule 18 (cuerpo -> line .)


state 19

    (19) cuerpo -> print .

    IF              reduce using rule 19 (cuerpo -> print .)
    FOR             reduce using rule 19 (cuerpo -> print .)
    SWITCH          reduce using rule 19 (cuerpo -> print .)
    ID              reduce using rule 19 (cuerpo -> print .)
    FUNCTION        reduce using rule 19 (cuerpo -> print .)
    FN              reduce using rule 19 (cuerpo -> print .)
    ECHO            reduce using rule 19 (cuerpo -> print .)
    PRINT           reduce using rule 19 (cuerpo -> print .)
    INTEGER         reduce using rule 19 (cuerpo -> print .)
    FLOAT           reduce using rule 19 (cuerpo -> print .)
    STRING          reduce using rule 19 (cuerpo -> print .)
    BOOL            reduce using rule 19 (cuerpo -> print .)
    NULL            reduce using rule 19 (cuerpo -> print .)
    $end            reduce using rule 19 (cuerpo -> print .)
    RCURLY          reduce using rule 19 (cuerpo -> print .)
    CONTINUE        reduce using rule 19 (cuerpo -> print .)
    SEMICOLON       reduce using rule 19 (cuerpo -> print .)
    BREAK           reduce using rule 19 (cuerpo -> print .)


state 20

    (57) arithmeticExpression -> value . arithmeticOperator value
    (64) arithmeticOperator -> . PLUS
    (65) arithmeticOperator -> . MINUS
    (66) arithmeticOperator -> . TIMES
    (67) arithmeticOperator -> . DIVIDE
    (68) arithmeticOperator -> . MOD
    (69) arithmeticOperator -> . EXP

    PLUS            shift and go to state 37
    MINUS           shift and go to state 38
    TIMES           shift and go to state 39
    DIVIDE          shift and go to state 40
    MOD             shift and go to state 41
    EXP             shift and go to state 42

    arithmeticOperator             shift and go to state 36

state 21

    (25) if_elseStatement -> IF . LPAREN comparingValue RPAREN LCURLY ifStatementBody RCURLY ELSE ifStatementBody
    (26) if_elseStatement -> IF . LPAREN comparingValue RPAREN LCURLY ifStatementBody

    LPAREN          shift and go to state 43


state 22

    (30) forStatement -> FOR . LPAREN forStatementCondition RPAREN LCURLY forStatementBody RCURLY

    LPAREN          shift and go to state 44


state 23

    (20) switchStatement -> SWITCH . LPAREN value RPAREN LCURLY switchCases switchDefault RCURLY

    LPAREN          shift and go to state 45


state 24

    (39) queueDeclaration -> ID . EQUAL NEW QUEUE SEMICOLON
    (40) queueEnqueue -> ID . OBJOP PUSH LPAREN value RPAREN SEMICOLON
    (41) queueDequeue -> ID . OBJOP POP SEMICOLON
    (56) fgets -> ID . EQUAL FGETS LPAREN STDIN RPAREN SEMICOLON
    (36) stackDeclaration -> ID . EQUAL NEW STACK SEMICOLON
    (37) stackPush -> ID . OBJOP PUSH LPAREN value RPAREN SEMICOLON
    (38) stackPop -> ID . OBJOP POP SEMICOLON
    (58) value -> ID .
    (71) variableAsignation -> ID . EQUAL value
    (72) variableAsignation -> ID . EQUAL arithmeticExpression

    EQUAL           shift and go to state 46
    OBJOP           shift and go to state 47
    PLUS            reduce using rule 58 (value -> ID .)
    MINUS           reduce using rule 58 (value -> ID .)
    TIMES           reduce using rule 58 (value -> ID .)
    DIVIDE          reduce using rule 58 (value -> ID .)
    MOD             reduce using rule 58 (value -> ID .)
    EXP             reduce using rule 58 (value -> ID .)


state 25

    (42) defineFunction -> FUNCTION . ID LPAREN arguments RPAREN LCURLY cuerpo RCURLY
    (43) defineFunction -> FUNCTION . ID LPAREN RPAREN LCURLY cuerpo RCURLY
    (46) anonymousFunction -> FUNCTION . LPAREN RPAREN LCURLY cuerpo RCURLY
    (47) anonymousFunction -> FUNCTION . LPAREN arguments RPAREN LCURLY cuerpo RCURLY

    ID              shift and go to state 48
    LPAREN          shift and go to state 49


state 26

    (48) arrowFunction -> FN . LPAREN ID RPAREN FNARROW arrowBody SEMICOLON

    LPAREN          shift and go to state 50


state 27

    (51) echo -> ECHO . values SEMICOLON
    (54) values -> . value
    (55) values -> . values COMMA value
    (58) value -> . ID
    (59) value -> . INTEGER
    (60) value -> . FLOAT
    (61) value -> . STRING
    (62) value -> . BOOL
    (63) value -> . NULL

    ID              shift and go to state 53
    INTEGER         shift and go to state 30
    FLOAT           shift and go to state 31
    STRING          shift and go to state 32
    BOOL            shift and go to state 33
    NULL            shift and go to state 34

    values                         shift and go to state 51
    value                          shift and go to state 52

state 28

    (70) line -> variableAsignation . SEMICOLON

    SEMICOLON       shift and go to state 54


state 29

    (52) print -> PRINT . LPAREN values RPAREN SEMICOLON
    (53) print -> PRINT . value SEMICOLON
    (58) value -> . ID
    (59) value -> . INTEGER
    (60) value -> . FLOAT
    (61) value -> . STRING
    (62) value -> . BOOL
    (63) value -> . NULL

    LPAREN          shift and go to state 55
    ID              shift and go to state 53
    INTEGER         shift and go to state 30
    FLOAT           shift and go to state 31
    STRING          shift and go to state 32
    BOOL            shift and go to state 33
    NULL            shift and go to state 34

    value                          shift and go to state 56

state 30

    (59) value -> INTEGER .

    PLUS            reduce using rule 59 (value -> INTEGER .)
    MINUS           reduce using rule 59 (value -> INTEGER .)
    TIMES           reduce using rule 59 (value -> INTEGER .)
    DIVIDE          reduce using rule 59 (value -> INTEGER .)
    MOD             reduce using rule 59 (value -> INTEGER .)
    EXP             reduce using rule 59 (value -> INTEGER .)
    SEMICOLON       reduce using rule 59 (value -> INTEGER .)
    COMMA           reduce using rule 59 (value -> INTEGER .)
    IF              reduce using rule 59 (value -> INTEGER .)
    FOR             reduce using rule 59 (value -> INTEGER .)
    SWITCH          reduce using rule 59 (value -> INTEGER .)
    ID              reduce using rule 59 (value -> INTEGER .)
    FUNCTION        reduce using rule 59 (value -> INTEGER .)
    FN              reduce using rule 59 (value -> INTEGER .)
    ECHO            reduce using rule 59 (value -> INTEGER .)
    PRINT           reduce using rule 59 (value -> INTEGER .)
    INTEGER         reduce using rule 59 (value -> INTEGER .)
    FLOAT           reduce using rule 59 (value -> INTEGER .)
    STRING          reduce using rule 59 (value -> INTEGER .)
    BOOL            reduce using rule 59 (value -> INTEGER .)
    NULL            reduce using rule 59 (value -> INTEGER .)
    $end            reduce using rule 59 (value -> INTEGER .)
    RPAREN          reduce using rule 59 (value -> INTEGER .)
    RCURLY          reduce using rule 59 (value -> INTEGER .)
    CONTINUE        reduce using rule 59 (value -> INTEGER .)
    BREAK           reduce using rule 59 (value -> INTEGER .)
    IS_EQUAL        reduce using rule 59 (value -> INTEGER .)
    IDENTICAL       reduce using rule 59 (value -> INTEGER .)
    NOTEQUAL        reduce using rule 59 (value -> INTEGER .)
    LESSTHAN        reduce using rule 59 (value -> INTEGER .)
    GREATERTHAN     reduce using rule 59 (value -> INTEGER .)
    LESSEQUALTHAN   reduce using rule 59 (value -> INTEGER .)
    GREATEREQUALTHAN reduce using rule 59 (value -> INTEGER .)
    COLON           reduce using rule 59 (value -> INTEGER .)


state 31

    (60) value -> FLOAT .

    PLUS            reduce using rule 60 (value -> FLOAT .)
    MINUS           reduce using rule 60 (value -> FLOAT .)
    TIMES           reduce using rule 60 (value -> FLOAT .)
    DIVIDE          reduce using rule 60 (value -> FLOAT .)
    MOD             reduce using rule 60 (value -> FLOAT .)
    EXP             reduce using rule 60 (value -> FLOAT .)
    SEMICOLON       reduce using rule 60 (value -> FLOAT .)
    COMMA           reduce using rule 60 (value -> FLOAT .)
    IF              reduce using rule 60 (value -> FLOAT .)
    FOR             reduce using rule 60 (value -> FLOAT .)
    SWITCH          reduce using rule 60 (value -> FLOAT .)
    ID              reduce using rule 60 (value -> FLOAT .)
    FUNCTION        reduce using rule 60 (value -> FLOAT .)
    FN              reduce using rule 60 (value -> FLOAT .)
    ECHO            reduce using rule 60 (value -> FLOAT .)
    PRINT           reduce using rule 60 (value -> FLOAT .)
    INTEGER         reduce using rule 60 (value -> FLOAT .)
    FLOAT           reduce using rule 60 (value -> FLOAT .)
    STRING          reduce using rule 60 (value -> FLOAT .)
    BOOL            reduce using rule 60 (value -> FLOAT .)
    NULL            reduce using rule 60 (value -> FLOAT .)
    $end            reduce using rule 60 (value -> FLOAT .)
    RPAREN          reduce using rule 60 (value -> FLOAT .)
    RCURLY          reduce using rule 60 (value -> FLOAT .)
    CONTINUE        reduce using rule 60 (value -> FLOAT .)
    BREAK           reduce using rule 60 (value -> FLOAT .)
    IS_EQUAL        reduce using rule 60 (value -> FLOAT .)
    IDENTICAL       reduce using rule 60 (value -> FLOAT .)
    NOTEQUAL        reduce using rule 60 (value -> FLOAT .)
    LESSTHAN        reduce using rule 60 (value -> FLOAT .)
    GREATERTHAN     reduce using rule 60 (value -> FLOAT .)
    LESSEQUALTHAN   reduce using rule 60 (value -> FLOAT .)
    GREATEREQUALTHAN reduce using rule 60 (value -> FLOAT .)
    COLON           reduce using rule 60 (value -> FLOAT .)


state 32

    (61) value -> STRING .

    PLUS            reduce using rule 61 (value -> STRING .)
    MINUS           reduce using rule 61 (value -> STRING .)
    TIMES           reduce using rule 61 (value -> STRING .)
    DIVIDE          reduce using rule 61 (value -> STRING .)
    MOD             reduce using rule 61 (value -> STRING .)
    EXP             reduce using rule 61 (value -> STRING .)
    SEMICOLON       reduce using rule 61 (value -> STRING .)
    COMMA           reduce using rule 61 (value -> STRING .)
    IF              reduce using rule 61 (value -> STRING .)
    FOR             reduce using rule 61 (value -> STRING .)
    SWITCH          reduce using rule 61 (value -> STRING .)
    ID              reduce using rule 61 (value -> STRING .)
    FUNCTION        reduce using rule 61 (value -> STRING .)
    FN              reduce using rule 61 (value -> STRING .)
    ECHO            reduce using rule 61 (value -> STRING .)
    PRINT           reduce using rule 61 (value -> STRING .)
    INTEGER         reduce using rule 61 (value -> STRING .)
    FLOAT           reduce using rule 61 (value -> STRING .)
    STRING          reduce using rule 61 (value -> STRING .)
    BOOL            reduce using rule 61 (value -> STRING .)
    NULL            reduce using rule 61 (value -> STRING .)
    $end            reduce using rule 61 (value -> STRING .)
    RPAREN          reduce using rule 61 (value -> STRING .)
    RCURLY          reduce using rule 61 (value -> STRING .)
    CONTINUE        reduce using rule 61 (value -> STRING .)
    BREAK           reduce using rule 61 (value -> STRING .)
    IS_EQUAL        reduce using rule 61 (value -> STRING .)
    IDENTICAL       reduce using rule 61 (value -> STRING .)
    NOTEQUAL        reduce using rule 61 (value -> STRING .)
    LESSTHAN        reduce using rule 61 (value -> STRING .)
    GREATERTHAN     reduce using rule 61 (value -> STRING .)
    LESSEQUALTHAN   reduce using rule 61 (value -> STRING .)
    GREATEREQUALTHAN reduce using rule 61 (value -> STRING .)
    COLON           reduce using rule 61 (value -> STRING .)


state 33

    (62) value -> BOOL .

    PLUS            reduce using rule 62 (value -> BOOL .)
    MINUS           reduce using rule 62 (value -> BOOL .)
    TIMES           reduce using rule 62 (value -> BOOL .)
    DIVIDE          reduce using rule 62 (value -> BOOL .)
    MOD             reduce using rule 62 (value -> BOOL .)
    EXP             reduce using rule 62 (value -> BOOL .)
    SEMICOLON       reduce using rule 62 (value -> BOOL .)
    COMMA           reduce using rule 62 (value -> BOOL .)
    IF              reduce using rule 62 (value -> BOOL .)
    FOR             reduce using rule 62 (value -> BOOL .)
    SWITCH          reduce using rule 62 (value -> BOOL .)
    ID              reduce using rule 62 (value -> BOOL .)
    FUNCTION        reduce using rule 62 (value -> BOOL .)
    FN              reduce using rule 62 (value -> BOOL .)
    ECHO            reduce using rule 62 (value -> BOOL .)
    PRINT           reduce using rule 62 (value -> BOOL .)
    INTEGER         reduce using rule 62 (value -> BOOL .)
    FLOAT           reduce using rule 62 (value -> BOOL .)
    STRING          reduce using rule 62 (value -> BOOL .)
    BOOL            reduce using rule 62 (value -> BOOL .)
    NULL            reduce using rule 62 (value -> BOOL .)
    $end            reduce using rule 62 (value -> BOOL .)
    RPAREN          reduce using rule 62 (value -> BOOL .)
    RCURLY          reduce using rule 62 (value -> BOOL .)
    CONTINUE        reduce using rule 62 (value -> BOOL .)
    BREAK           reduce using rule 62 (value -> BOOL .)
    IS_EQUAL        reduce using rule 62 (value -> BOOL .)
    IDENTICAL       reduce using rule 62 (value -> BOOL .)
    NOTEQUAL        reduce using rule 62 (value -> BOOL .)
    LESSTHAN        reduce using rule 62 (value -> BOOL .)
    GREATERTHAN     reduce using rule 62 (value -> BOOL .)
    LESSEQUALTHAN   reduce using rule 62 (value -> BOOL .)
    GREATEREQUALTHAN reduce using rule 62 (value -> BOOL .)
    COLON           reduce using rule 62 (value -> BOOL .)


state 34

    (63) value -> NULL .

    PLUS            reduce using rule 63 (value -> NULL .)
    MINUS           reduce using rule 63 (value -> NULL .)
    TIMES           reduce using rule 63 (value -> NULL .)
    DIVIDE          reduce using rule 63 (value -> NULL .)
    MOD             reduce using rule 63 (value -> NULL .)
    EXP             reduce using rule 63 (value -> NULL .)
    SEMICOLON       reduce using rule 63 (value -> NULL .)
    COMMA           reduce using rule 63 (value -> NULL .)
    IF              reduce using rule 63 (value -> NULL .)
    FOR             reduce using rule 63 (value -> NULL .)
    SWITCH          reduce using rule 63 (value -> NULL .)
    ID              reduce using rule 63 (value -> NULL .)
    FUNCTION        reduce using rule 63 (value -> NULL .)
    FN              reduce using rule 63 (value -> NULL .)
    ECHO            reduce using rule 63 (value -> NULL .)
    PRINT           reduce using rule 63 (value -> NULL .)
    INTEGER         reduce using rule 63 (value -> NULL .)
    FLOAT           reduce using rule 63 (value -> NULL .)
    STRING          reduce using rule 63 (value -> NULL .)
    BOOL            reduce using rule 63 (value -> NULL .)
    NULL            reduce using rule 63 (value -> NULL .)
    $end            reduce using rule 63 (value -> NULL .)
    RPAREN          reduce using rule 63 (value -> NULL .)
    RCURLY          reduce using rule 63 (value -> NULL .)
    CONTINUE        reduce using rule 63 (value -> NULL .)
    BREAK           reduce using rule 63 (value -> NULL .)
    IS_EQUAL        reduce using rule 63 (value -> NULL .)
    IDENTICAL       reduce using rule 63 (value -> NULL .)
    NOTEQUAL        reduce using rule 63 (value -> NULL .)
    LESSTHAN        reduce using rule 63 (value -> NULL .)
    GREATERTHAN     reduce using rule 63 (value -> NULL .)
    LESSEQUALTHAN   reduce using rule 63 (value -> NULL .)
    GREATEREQUALTHAN reduce using rule 63 (value -> NULL .)
    COLON           reduce using rule 63 (value -> NULL .)


state 35

    (2) programa -> programa cuerpo .

    IF              reduce using rule 2 (programa -> programa cuerpo .)
    FOR             reduce using rule 2 (programa -> programa cuerpo .)
    SWITCH          reduce using rule 2 (programa -> programa cuerpo .)
    ID              reduce using rule 2 (programa -> programa cuerpo .)
    FUNCTION        reduce using rule 2 (programa -> programa cuerpo .)
    FN              reduce using rule 2 (programa -> programa cuerpo .)
    ECHO            reduce using rule 2 (programa -> programa cuerpo .)
    PRINT           reduce using rule 2 (programa -> programa cuerpo .)
    INTEGER         reduce using rule 2 (programa -> programa cuerpo .)
    FLOAT           reduce using rule 2 (programa -> programa cuerpo .)
    STRING          reduce using rule 2 (programa -> programa cuerpo .)
    BOOL            reduce using rule 2 (programa -> programa cuerpo .)
    NULL            reduce using rule 2 (programa -> programa cuerpo .)
    $end            reduce using rule 2 (programa -> programa cuerpo .)


state 36

    (57) arithmeticExpression -> value arithmeticOperator . value
    (58) value -> . ID
    (59) value -> . INTEGER
    (60) value -> . FLOAT
    (61) value -> . STRING
    (62) value -> . BOOL
    (63) value -> . NULL

    ID              shift and go to state 53
    INTEGER         shift and go to state 30
    FLOAT           shift and go to state 31
    STRING          shift and go to state 32
    BOOL            shift and go to state 33
    NULL            shift and go to state 34

    value                          shift and go to state 57

state 37

    (64) arithmeticOperator -> PLUS .

    ID              reduce using rule 64 (arithmeticOperator -> PLUS .)
    INTEGER         reduce using rule 64 (arithmeticOperator -> PLUS .)
    FLOAT           reduce using rule 64 (arithmeticOperator -> PLUS .)
    STRING          reduce using rule 64 (arithmeticOperator -> PLUS .)
    BOOL            reduce using rule 64 (arithmeticOperator -> PLUS .)
    NULL            reduce using rule 64 (arithmeticOperator -> PLUS .)


state 38

    (65) arithmeticOperator -> MINUS .

    ID              reduce using rule 65 (arithmeticOperator -> MINUS .)
    INTEGER         reduce using rule 65 (arithmeticOperator -> MINUS .)
    FLOAT           reduce using rule 65 (arithmeticOperator -> MINUS .)
    STRING          reduce using rule 65 (arithmeticOperator -> MINUS .)
    BOOL            reduce using rule 65 (arithmeticOperator -> MINUS .)
    NULL            reduce using rule 65 (arithmeticOperator -> MINUS .)


state 39

    (66) arithmeticOperator -> TIMES .

    ID              reduce using rule 66 (arithmeticOperator -> TIMES .)
    INTEGER         reduce using rule 66 (arithmeticOperator -> TIMES .)
    FLOAT           reduce using rule 66 (arithmeticOperator -> TIMES .)
    STRING          reduce using rule 66 (arithmeticOperator -> TIMES .)
    BOOL            reduce using rule 66 (arithmeticOperator -> TIMES .)
    NULL            reduce using rule 66 (arithmeticOperator -> TIMES .)


state 40

    (67) arithmeticOperator -> DIVIDE .

    ID              reduce using rule 67 (arithmeticOperator -> DIVIDE .)
    INTEGER         reduce using rule 67 (arithmeticOperator -> DIVIDE .)
    FLOAT           reduce using rule 67 (arithmeticOperator -> DIVIDE .)
    STRING          reduce using rule 67 (arithmeticOperator -> DIVIDE .)
    BOOL            reduce using rule 67 (arithmeticOperator -> DIVIDE .)
    NULL            reduce using rule 67 (arithmeticOperator -> DIVIDE .)


state 41

    (68) arithmeticOperator -> MOD .

    ID              reduce using rule 68 (arithmeticOperator -> MOD .)
    INTEGER         reduce using rule 68 (arithmeticOperator -> MOD .)
    FLOAT           reduce using rule 68 (arithmeticOperator -> MOD .)
    STRING          reduce using rule 68 (arithmeticOperator -> MOD .)
    BOOL            reduce using rule 68 (arithmeticOperator -> MOD .)
    NULL            reduce using rule 68 (arithmeticOperator -> MOD .)


state 42

    (69) arithmeticOperator -> EXP .

    ID              reduce using rule 69 (arithmeticOperator -> EXP .)
    INTEGER         reduce using rule 69 (arithmeticOperator -> EXP .)
    FLOAT           reduce using rule 69 (arithmeticOperator -> EXP .)
    STRING          reduce using rule 69 (arithmeticOperator -> EXP .)
    BOOL            reduce using rule 69 (arithmeticOperator -> EXP .)
    NULL            reduce using rule 69 (arithmeticOperator -> EXP .)


state 43

    (25) if_elseStatement -> IF LPAREN . comparingValue RPAREN LCURLY ifStatementBody RCURLY ELSE ifStatementBody
    (26) if_elseStatement -> IF LPAREN . comparingValue RPAREN LCURLY ifStatementBody
    (80) comparingValue -> . value comparingSign value
    (58) value -> . ID
    (59) value -> . INTEGER
    (60) value -> . FLOAT
    (61) value -> . STRING
    (62) value -> . BOOL
    (63) value -> . NULL

    ID              shift and go to state 53
    INTEGER         shift and go to state 30
    FLOAT           shift and go to state 31
    STRING          shift and go to state 32
    BOOL            shift and go to state 33
    NULL            shift and go to state 34

    comparingValue                 shift and go to state 58
    value                          shift and go to state 59

state 44

    (30) forStatement -> FOR LPAREN . forStatementCondition RPAREN LCURLY forStatementBody RCURLY
    (31) forStatementCondition -> . SEMICOLON SEMICOLON
    (32) forStatementCondition -> . variableAsignation SEMICOLON SEMICOLON variableAsignation
    (33) forStatementCondition -> . variableAsignation SEMICOLON comparingValue SEMICOLON variableAsignation
    (71) variableAsignation -> . ID EQUAL value
    (72) variableAsignation -> . ID EQUAL arithmeticExpression

    SEMICOLON       shift and go to state 61
    ID              shift and go to state 63

    forStatementCondition          shift and go to state 60
    variableAsignation             shift and go to state 62

state 45

    (20) switchStatement -> SWITCH LPAREN . value RPAREN LCURLY switchCases switchDefault RCURLY
    (58) value -> . ID
    (59) value -> . INTEGER
    (60) value -> . FLOAT
    (61) value -> . STRING
    (62) value -> . BOOL
    (63) value -> . NULL

    ID              shift and go to state 53
    INTEGER         shift and go to state 30
    FLOAT           shift and go to state 31
    STRING          shift and go to state 32
    BOOL            shift and go to state 33
    NULL            shift and go to state 34

    value                          shift and go to state 64

state 46

    (39) queueDeclaration -> ID EQUAL . NEW QUEUE SEMICOLON
    (56) fgets -> ID EQUAL . FGETS LPAREN STDIN RPAREN SEMICOLON
    (36) stackDeclaration -> ID EQUAL . NEW STACK SEMICOLON
    (71) variableAsignation -> ID EQUAL . value
    (72) variableAsignation -> ID EQUAL . arithmeticExpression
    (58) value -> . ID
    (59) value -> . INTEGER
    (60) value -> . FLOAT
    (61) value -> . STRING
    (62) value -> . BOOL
    (63) value -> . NULL
    (57) arithmeticExpression -> . value arithmeticOperator value

    NEW             shift and go to state 65
    FGETS           shift and go to state 66
    ID              shift and go to state 53
    INTEGER         shift and go to state 30
    FLOAT           shift and go to state 31
    STRING          shift and go to state 32
    BOOL            shift and go to state 33
    NULL            shift and go to state 34

    value                          shift and go to state 67
    arithmeticExpression           shift and go to state 68

state 47

    (40) queueEnqueue -> ID OBJOP . PUSH LPAREN value RPAREN SEMICOLON
    (41) queueDequeue -> ID OBJOP . POP SEMICOLON
    (37) stackPush -> ID OBJOP . PUSH LPAREN value RPAREN SEMICOLON
    (38) stackPop -> ID OBJOP . POP SEMICOLON

    PUSH            shift and go to state 69
    POP             shift and go to state 70


state 48

    (42) defineFunction -> FUNCTION ID . LPAREN arguments RPAREN LCURLY cuerpo RCURLY
    (43) defineFunction -> FUNCTION ID . LPAREN RPAREN LCURLY cuerpo RCURLY

    LPAREN          shift and go to state 71


state 49

    (46) anonymousFunction -> FUNCTION LPAREN . RPAREN LCURLY cuerpo RCURLY
    (47) anonymousFunction -> FUNCTION LPAREN . arguments RPAREN LCURLY cuerpo RCURLY
    (44) arguments -> . ID
    (45) arguments -> . ID COMMA arguments

    RPAREN          shift and go to state 72
    ID              shift and go to state 74

    arguments                      shift and go to state 73

state 50

    (48) arrowFunction -> FN LPAREN . ID RPAREN FNARROW arrowBody SEMICOLON

    ID              shift and go to state 75


state 51

    (51) echo -> ECHO values . SEMICOLON
    (55) values -> values . COMMA value

    SEMICOLON       shift and go to state 76
    COMMA           shift and go to state 77


state 52

    (54) values -> value .

    SEMICOLON       reduce using rule 54 (values -> value .)
    COMMA           reduce using rule 54 (values -> value .)
    RPAREN          reduce using rule 54 (values -> value .)


state 53

    (58) value -> ID .

    SEMICOLON       reduce using rule 58 (value -> ID .)
    COMMA           reduce using rule 58 (value -> ID .)
    IF              reduce using rule 58 (value -> ID .)
    FOR             reduce using rule 58 (value -> ID .)
    SWITCH          reduce using rule 58 (value -> ID .)
    ID              reduce using rule 58 (value -> ID .)
    FUNCTION        reduce using rule 58 (value -> ID .)
    FN              reduce using rule 58 (value -> ID .)
    ECHO            reduce using rule 58 (value -> ID .)
    PRINT           reduce using rule 58 (value -> ID .)
    INTEGER         reduce using rule 58 (value -> ID .)
    FLOAT           reduce using rule 58 (value -> ID .)
    STRING          reduce using rule 58 (value -> ID .)
    BOOL            reduce using rule 58 (value -> ID .)
    NULL            reduce using rule 58 (value -> ID .)
    $end            reduce using rule 58 (value -> ID .)
    RPAREN          reduce using rule 58 (value -> ID .)
    RCURLY          reduce using rule 58 (value -> ID .)
    CONTINUE        reduce using rule 58 (value -> ID .)
    BREAK           reduce using rule 58 (value -> ID .)
    IS_EQUAL        reduce using rule 58 (value -> ID .)
    IDENTICAL       reduce using rule 58 (value -> ID .)
    NOTEQUAL        reduce using rule 58 (value -> ID .)
    LESSTHAN        reduce using rule 58 (value -> ID .)
    GREATERTHAN     reduce using rule 58 (value -> ID .)
    LESSEQUALTHAN   reduce using rule 58 (value -> ID .)
    GREATEREQUALTHAN reduce using rule 58 (value -> ID .)
    PLUS            reduce using rule 58 (value -> ID .)
    MINUS           reduce using rule 58 (value -> ID .)
    TIMES           reduce using rule 58 (value -> ID .)
    DIVIDE          reduce using rule 58 (value -> ID .)
    MOD             reduce using rule 58 (value -> ID .)
    EXP             reduce using rule 58 (value -> ID .)
    COLON           reduce using rule 58 (value -> ID .)


state 54

    (70) line -> variableAsignation SEMICOLON .

    IF              reduce using rule 70 (line -> variableAsignation SEMICOLON .)
    FOR             reduce using rule 70 (line -> variableAsignation SEMICOLON .)
    SWITCH          reduce using rule 70 (line -> variableAsignation SEMICOLON .)
    ID              reduce using rule 70 (line -> variableAsignation SEMICOLON .)
    FUNCTION        reduce using rule 70 (line -> variableAsignation SEMICOLON .)
    FN              reduce using rule 70 (line -> variableAsignation SEMICOLON .)
    ECHO            reduce using rule 70 (line -> variableAsignation SEMICOLON .)
    PRINT           reduce using rule 70 (line -> variableAsignation SEMICOLON .)
    INTEGER         reduce using rule 70 (line -> variableAsignation SEMICOLON .)
    FLOAT           reduce using rule 70 (line -> variableAsignation SEMICOLON .)
    STRING          reduce using rule 70 (line -> variableAsignation SEMICOLON .)
    BOOL            reduce using rule 70 (line -> variableAsignation SEMICOLON .)
    NULL            reduce using rule 70 (line -> variableAsignation SEMICOLON .)
    $end            reduce using rule 70 (line -> variableAsignation SEMICOLON .)
    RCURLY          reduce using rule 70 (line -> variableAsignation SEMICOLON .)
    CONTINUE        reduce using rule 70 (line -> variableAsignation SEMICOLON .)
    SEMICOLON       reduce using rule 70 (line -> variableAsignation SEMICOLON .)
    BREAK           reduce using rule 70 (line -> variableAsignation SEMICOLON .)


state 55

    (52) print -> PRINT LPAREN . values RPAREN SEMICOLON
    (54) values -> . value
    (55) values -> . values COMMA value
    (58) value -> . ID
    (59) value -> . INTEGER
    (60) value -> . FLOAT
    (61) value -> . STRING
    (62) value -> . BOOL
    (63) value -> . NULL

    ID              shift and go to state 53
    INTEGER         shift and go to state 30
    FLOAT           shift and go to state 31
    STRING          shift and go to state 32
    BOOL            shift and go to state 33
    NULL            shift and go to state 34

    values                         shift and go to state 78
    value                          shift and go to state 52

state 56

    (53) print -> PRINT value . SEMICOLON

    SEMICOLON       shift and go to state 79


state 57

    (57) arithmeticExpression -> value arithmeticOperator value .

    IF              reduce using rule 57 (arithmeticExpression -> value arithmeticOperator value .)
    FOR             reduce using rule 57 (arithmeticExpression -> value arithmeticOperator value .)
    SWITCH          reduce using rule 57 (arithmeticExpression -> value arithmeticOperator value .)
    ID              reduce using rule 57 (arithmeticExpression -> value arithmeticOperator value .)
    FUNCTION        reduce using rule 57 (arithmeticExpression -> value arithmeticOperator value .)
    FN              reduce using rule 57 (arithmeticExpression -> value arithmeticOperator value .)
    ECHO            reduce using rule 57 (arithmeticExpression -> value arithmeticOperator value .)
    PRINT           reduce using rule 57 (arithmeticExpression -> value arithmeticOperator value .)
    INTEGER         reduce using rule 57 (arithmeticExpression -> value arithmeticOperator value .)
    FLOAT           reduce using rule 57 (arithmeticExpression -> value arithmeticOperator value .)
    STRING          reduce using rule 57 (arithmeticExpression -> value arithmeticOperator value .)
    BOOL            reduce using rule 57 (arithmeticExpression -> value arithmeticOperator value .)
    NULL            reduce using rule 57 (arithmeticExpression -> value arithmeticOperator value .)
    $end            reduce using rule 57 (arithmeticExpression -> value arithmeticOperator value .)
    SEMICOLON       reduce using rule 57 (arithmeticExpression -> value arithmeticOperator value .)
    RPAREN          reduce using rule 57 (arithmeticExpression -> value arithmeticOperator value .)
    RCURLY          reduce using rule 57 (arithmeticExpression -> value arithmeticOperator value .)
    CONTINUE        reduce using rule 57 (arithmeticExpression -> value arithmeticOperator value .)
    BREAK           reduce using rule 57 (arithmeticExpression -> value arithmeticOperator value .)


state 58

    (25) if_elseStatement -> IF LPAREN comparingValue . RPAREN LCURLY ifStatementBody RCURLY ELSE ifStatementBody
    (26) if_elseStatement -> IF LPAREN comparingValue . RPAREN LCURLY ifStatementBody

    RPAREN          shift and go to state 80


state 59

    (80) comparingValue -> value . comparingSign value
    (73) comparingSign -> . IS_EQUAL
    (74) comparingSign -> . IDENTICAL
    (75) comparingSign -> . NOTEQUAL
    (76) comparingSign -> . LESSTHAN
    (77) comparingSign -> . GREATERTHAN
    (78) comparingSign -> . LESSEQUALTHAN
    (79) comparingSign -> . GREATEREQUALTHAN

    IS_EQUAL        shift and go to state 82
    IDENTICAL       shift and go to state 83
    NOTEQUAL        shift and go to state 84
    LESSTHAN        shift and go to state 85
    GREATERTHAN     shift and go to state 86
    LESSEQUALTHAN   shift and go to state 87
    GREATEREQUALTHAN shift and go to state 88

    comparingSign                  shift and go to state 81

state 60

    (30) forStatement -> FOR LPAREN forStatementCondition . RPAREN LCURLY forStatementBody RCURLY

    RPAREN          shift and go to state 89


state 61

    (31) forStatementCondition -> SEMICOLON . SEMICOLON

    SEMICOLON       shift and go to state 90


state 62

    (32) forStatementCondition -> variableAsignation . SEMICOLON SEMICOLON variableAsignation
    (33) forStatementCondition -> variableAsignation . SEMICOLON comparingValue SEMICOLON variableAsignation

    SEMICOLON       shift and go to state 91


state 63

    (71) variableAsignation -> ID . EQUAL value
    (72) variableAsignation -> ID . EQUAL arithmeticExpression

    EQUAL           shift and go to state 92


state 64

    (20) switchStatement -> SWITCH LPAREN value . RPAREN LCURLY switchCases switchDefault RCURLY

    RPAREN          shift and go to state 93


state 65

    (39) queueDeclaration -> ID EQUAL NEW . QUEUE SEMICOLON
    (36) stackDeclaration -> ID EQUAL NEW . STACK SEMICOLON

    QUEUE           shift and go to state 94
    STACK           shift and go to state 95


state 66

    (56) fgets -> ID EQUAL FGETS . LPAREN STDIN RPAREN SEMICOLON

    LPAREN          shift and go to state 96


state 67

    (71) variableAsignation -> ID EQUAL value .
    (57) arithmeticExpression -> value . arithmeticOperator value
    (64) arithmeticOperator -> . PLUS
    (65) arithmeticOperator -> . MINUS
    (66) arithmeticOperator -> . TIMES
    (67) arithmeticOperator -> . DIVIDE
    (68) arithmeticOperator -> . MOD
    (69) arithmeticOperator -> . EXP

    SEMICOLON       reduce using rule 71 (variableAsignation -> ID EQUAL value .)
    RPAREN          reduce using rule 71 (variableAsignation -> ID EQUAL value .)
    PLUS            shift and go to state 37
    MINUS           shift and go to state 38
    TIMES           shift and go to state 39
    DIVIDE          shift and go to state 40
    MOD             shift and go to state 41
    EXP             shift and go to state 42

    arithmeticOperator             shift and go to state 36

state 68

    (72) variableAsignation -> ID EQUAL arithmeticExpression .

    SEMICOLON       reduce using rule 72 (variableAsignation -> ID EQUAL arithmeticExpression .)
    RPAREN          reduce using rule 72 (variableAsignation -> ID EQUAL arithmeticExpression .)


state 69

    (40) queueEnqueue -> ID OBJOP PUSH . LPAREN value RPAREN SEMICOLON
    (37) stackPush -> ID OBJOP PUSH . LPAREN value RPAREN SEMICOLON

    LPAREN          shift and go to state 97


state 70

    (41) queueDequeue -> ID OBJOP POP . SEMICOLON
    (38) stackPop -> ID OBJOP POP . SEMICOLON

    SEMICOLON       shift and go to state 98


state 71

    (42) defineFunction -> FUNCTION ID LPAREN . arguments RPAREN LCURLY cuerpo RCURLY
    (43) defineFunction -> FUNCTION ID LPAREN . RPAREN LCURLY cuerpo RCURLY
    (44) arguments -> . ID
    (45) arguments -> . ID COMMA arguments

    RPAREN          shift and go to state 100
    ID              shift and go to state 74

    arguments                      shift and go to state 99

state 72

    (46) anonymousFunction -> FUNCTION LPAREN RPAREN . LCURLY cuerpo RCURLY

    LCURLY          shift and go to state 101


state 73

    (47) anonymousFunction -> FUNCTION LPAREN arguments . RPAREN LCURLY cuerpo RCURLY

    RPAREN          shift and go to state 102


state 74

    (44) arguments -> ID .
    (45) arguments -> ID . COMMA arguments

    RPAREN          reduce using rule 44 (arguments -> ID .)
    COMMA           shift and go to state 103


state 75

    (48) arrowFunction -> FN LPAREN ID . RPAREN FNARROW arrowBody SEMICOLON

    RPAREN          shift and go to state 104


state 76

    (51) echo -> ECHO values SEMICOLON .

    IF              reduce using rule 51 (echo -> ECHO values SEMICOLON .)
    FOR             reduce using rule 51 (echo -> ECHO values SEMICOLON .)
    SWITCH          reduce using rule 51 (echo -> ECHO values SEMICOLON .)
    ID              reduce using rule 51 (echo -> ECHO values SEMICOLON .)
    FUNCTION        reduce using rule 51 (echo -> ECHO values SEMICOLON .)
    FN              reduce using rule 51 (echo -> ECHO values SEMICOLON .)
    ECHO            reduce using rule 51 (echo -> ECHO values SEMICOLON .)
    PRINT           reduce using rule 51 (echo -> ECHO values SEMICOLON .)
    INTEGER         reduce using rule 51 (echo -> ECHO values SEMICOLON .)
    FLOAT           reduce using rule 51 (echo -> ECHO values SEMICOLON .)
    STRING          reduce using rule 51 (echo -> ECHO values SEMICOLON .)
    BOOL            reduce using rule 51 (echo -> ECHO values SEMICOLON .)
    NULL            reduce using rule 51 (echo -> ECHO values SEMICOLON .)
    $end            reduce using rule 51 (echo -> ECHO values SEMICOLON .)
    RCURLY          reduce using rule 51 (echo -> ECHO values SEMICOLON .)
    CONTINUE        reduce using rule 51 (echo -> ECHO values SEMICOLON .)
    SEMICOLON       reduce using rule 51 (echo -> ECHO values SEMICOLON .)
    BREAK           reduce using rule 51 (echo -> ECHO values SEMICOLON .)


state 77

    (55) values -> values COMMA . value
    (58) value -> . ID
    (59) value -> . INTEGER
    (60) value -> . FLOAT
    (61) value -> . STRING
    (62) value -> . BOOL
    (63) value -> . NULL

    ID              shift and go to state 53
    INTEGER         shift and go to state 30
    FLOAT           shift and go to state 31
    STRING          shift and go to state 32
    BOOL            shift and go to state 33
    NULL            shift and go to state 34

    value                          shift and go to state 105

state 78

    (52) print -> PRINT LPAREN values . RPAREN SEMICOLON
    (55) values -> values . COMMA value

    RPAREN          shift and go to state 106
    COMMA           shift and go to state 77


state 79

    (53) print -> PRINT value SEMICOLON .

    IF              reduce using rule 53 (print -> PRINT value SEMICOLON .)
    FOR             reduce using rule 53 (print -> PRINT value SEMICOLON .)
    SWITCH          reduce using rule 53 (print -> PRINT value SEMICOLON .)
    ID              reduce using rule 53 (print -> PRINT value SEMICOLON .)
    FUNCTION        reduce using rule 53 (print -> PRINT value SEMICOLON .)
    FN              reduce using rule 53 (print -> PRINT value SEMICOLON .)
    ECHO            reduce using rule 53 (print -> PRINT value SEMICOLON .)
    PRINT           reduce using rule 53 (print -> PRINT value SEMICOLON .)
    INTEGER         reduce using rule 53 (print -> PRINT value SEMICOLON .)
    FLOAT           reduce using rule 53 (print -> PRINT value SEMICOLON .)
    STRING          reduce using rule 53 (print -> PRINT value SEMICOLON .)
    BOOL            reduce using rule 53 (print -> PRINT value SEMICOLON .)
    NULL            reduce using rule 53 (print -> PRINT value SEMICOLON .)
    $end            reduce using rule 53 (print -> PRINT value SEMICOLON .)
    RCURLY          reduce using rule 53 (print -> PRINT value SEMICOLON .)
    CONTINUE        reduce using rule 53 (print -> PRINT value SEMICOLON .)
    SEMICOLON       reduce using rule 53 (print -> PRINT value SEMICOLON .)
    BREAK           reduce using rule 53 (print -> PRINT value SEMICOLON .)


state 80

    (25) if_elseStatement -> IF LPAREN comparingValue RPAREN . LCURLY ifStatementBody RCURLY ELSE ifStatementBody
    (26) if_elseStatement -> IF LPAREN comparingValue RPAREN . LCURLY ifStatementBody

    LCURLY          shift and go to state 107


state 81

    (80) comparingValue -> value comparingSign . value
    (58) value -> . ID
    (59) value -> . INTEGER
    (60) value -> . FLOAT
    (61) value -> . STRING
    (62) value -> . BOOL
    (63) value -> . NULL

    ID              shift and go to state 53
    INTEGER         shift and go to state 30
    FLOAT           shift and go to state 31
    STRING          shift and go to state 32
    BOOL            shift and go to state 33
    NULL            shift and go to state 34

    value                          shift and go to state 108

state 82

    (73) comparingSign -> IS_EQUAL .

    ID              reduce using rule 73 (comparingSign -> IS_EQUAL .)
    INTEGER         reduce using rule 73 (comparingSign -> IS_EQUAL .)
    FLOAT           reduce using rule 73 (comparingSign -> IS_EQUAL .)
    STRING          reduce using rule 73 (comparingSign -> IS_EQUAL .)
    BOOL            reduce using rule 73 (comparingSign -> IS_EQUAL .)
    NULL            reduce using rule 73 (comparingSign -> IS_EQUAL .)


state 83

    (74) comparingSign -> IDENTICAL .

    ID              reduce using rule 74 (comparingSign -> IDENTICAL .)
    INTEGER         reduce using rule 74 (comparingSign -> IDENTICAL .)
    FLOAT           reduce using rule 74 (comparingSign -> IDENTICAL .)
    STRING          reduce using rule 74 (comparingSign -> IDENTICAL .)
    BOOL            reduce using rule 74 (comparingSign -> IDENTICAL .)
    NULL            reduce using rule 74 (comparingSign -> IDENTICAL .)


state 84

    (75) comparingSign -> NOTEQUAL .

    ID              reduce using rule 75 (comparingSign -> NOTEQUAL .)
    INTEGER         reduce using rule 75 (comparingSign -> NOTEQUAL .)
    FLOAT           reduce using rule 75 (comparingSign -> NOTEQUAL .)
    STRING          reduce using rule 75 (comparingSign -> NOTEQUAL .)
    BOOL            reduce using rule 75 (comparingSign -> NOTEQUAL .)
    NULL            reduce using rule 75 (comparingSign -> NOTEQUAL .)


state 85

    (76) comparingSign -> LESSTHAN .

    ID              reduce using rule 76 (comparingSign -> LESSTHAN .)
    INTEGER         reduce using rule 76 (comparingSign -> LESSTHAN .)
    FLOAT           reduce using rule 76 (comparingSign -> LESSTHAN .)
    STRING          reduce using rule 76 (comparingSign -> LESSTHAN .)
    BOOL            reduce using rule 76 (comparingSign -> LESSTHAN .)
    NULL            reduce using rule 76 (comparingSign -> LESSTHAN .)


state 86

    (77) comparingSign -> GREATERTHAN .

    ID              reduce using rule 77 (comparingSign -> GREATERTHAN .)
    INTEGER         reduce using rule 77 (comparingSign -> GREATERTHAN .)
    FLOAT           reduce using rule 77 (comparingSign -> GREATERTHAN .)
    STRING          reduce using rule 77 (comparingSign -> GREATERTHAN .)
    BOOL            reduce using rule 77 (comparingSign -> GREATERTHAN .)
    NULL            reduce using rule 77 (comparingSign -> GREATERTHAN .)


state 87

    (78) comparingSign -> LESSEQUALTHAN .

    ID              reduce using rule 78 (comparingSign -> LESSEQUALTHAN .)
    INTEGER         reduce using rule 78 (comparingSign -> LESSEQUALTHAN .)
    FLOAT           reduce using rule 78 (comparingSign -> LESSEQUALTHAN .)
    STRING          reduce using rule 78 (comparingSign -> LESSEQUALTHAN .)
    BOOL            reduce using rule 78 (comparingSign -> LESSEQUALTHAN .)
    NULL            reduce using rule 78 (comparingSign -> LESSEQUALTHAN .)


state 88

    (79) comparingSign -> GREATEREQUALTHAN .

    ID              reduce using rule 79 (comparingSign -> GREATEREQUALTHAN .)
    INTEGER         reduce using rule 79 (comparingSign -> GREATEREQUALTHAN .)
    FLOAT           reduce using rule 79 (comparingSign -> GREATEREQUALTHAN .)
    STRING          reduce using rule 79 (comparingSign -> GREATEREQUALTHAN .)
    BOOL            reduce using rule 79 (comparingSign -> GREATEREQUALTHAN .)
    NULL            reduce using rule 79 (comparingSign -> GREATEREQUALTHAN .)


state 89

    (30) forStatement -> FOR LPAREN forStatementCondition RPAREN . LCURLY forStatementBody RCURLY

    LCURLY          shift and go to state 109


state 90

    (31) forStatementCondition -> SEMICOLON SEMICOLON .

    RPAREN          reduce using rule 31 (forStatementCondition -> SEMICOLON SEMICOLON .)


state 91

    (32) forStatementCondition -> variableAsignation SEMICOLON . SEMICOLON variableAsignation
    (33) forStatementCondition -> variableAsignation SEMICOLON . comparingValue SEMICOLON variableAsignation
    (80) comparingValue -> . value comparingSign value
    (58) value -> . ID
    (59) value -> . INTEGER
    (60) value -> . FLOAT
    (61) value -> . STRING
    (62) value -> . BOOL
    (63) value -> . NULL

    SEMICOLON       shift and go to state 110
    ID              shift and go to state 53
    INTEGER         shift and go to state 30
    FLOAT           shift and go to state 31
    STRING          shift and go to state 32
    BOOL            shift and go to state 33
    NULL            shift and go to state 34

    comparingValue                 shift and go to state 111
    value                          shift and go to state 59

state 92

    (71) variableAsignation -> ID EQUAL . value
    (72) variableAsignation -> ID EQUAL . arithmeticExpression
    (58) value -> . ID
    (59) value -> . INTEGER
    (60) value -> . FLOAT
    (61) value -> . STRING
    (62) value -> . BOOL
    (63) value -> . NULL
    (57) arithmeticExpression -> . value arithmeticOperator value

    ID              shift and go to state 53
    INTEGER         shift and go to state 30
    FLOAT           shift and go to state 31
    STRING          shift and go to state 32
    BOOL            shift and go to state 33
    NULL            shift and go to state 34

    value                          shift and go to state 67
    arithmeticExpression           shift and go to state 68

state 93

    (20) switchStatement -> SWITCH LPAREN value RPAREN . LCURLY switchCases switchDefault RCURLY

    LCURLY          shift and go to state 112


state 94

    (39) queueDeclaration -> ID EQUAL NEW QUEUE . SEMICOLON

    SEMICOLON       shift and go to state 113


state 95

    (36) stackDeclaration -> ID EQUAL NEW STACK . SEMICOLON

    SEMICOLON       shift and go to state 114


state 96

    (56) fgets -> ID EQUAL FGETS LPAREN . STDIN RPAREN SEMICOLON

    STDIN           shift and go to state 115


state 97

    (40) queueEnqueue -> ID OBJOP PUSH LPAREN . value RPAREN SEMICOLON
    (37) stackPush -> ID OBJOP PUSH LPAREN . value RPAREN SEMICOLON
    (58) value -> . ID
    (59) value -> . INTEGER
    (60) value -> . FLOAT
    (61) value -> . STRING
    (62) value -> . BOOL
    (63) value -> . NULL

    ID              shift and go to state 53
    INTEGER         shift and go to state 30
    FLOAT           shift and go to state 31
    STRING          shift and go to state 32
    BOOL            shift and go to state 33
    NULL            shift and go to state 34

    value                          shift and go to state 116

state 98

    (41) queueDequeue -> ID OBJOP POP SEMICOLON .
    (38) stackPop -> ID OBJOP POP SEMICOLON .

  ! reduce/reduce conflict for IF resolved using rule 38 (stackPop -> ID OBJOP POP SEMICOLON .)
  ! reduce/reduce conflict for FOR resolved using rule 38 (stackPop -> ID OBJOP POP SEMICOLON .)
  ! reduce/reduce conflict for SWITCH resolved using rule 38 (stackPop -> ID OBJOP POP SEMICOLON .)
  ! reduce/reduce conflict for ID resolved using rule 38 (stackPop -> ID OBJOP POP SEMICOLON .)
  ! reduce/reduce conflict for FUNCTION resolved using rule 38 (stackPop -> ID OBJOP POP SEMICOLON .)
  ! reduce/reduce conflict for FN resolved using rule 38 (stackPop -> ID OBJOP POP SEMICOLON .)
  ! reduce/reduce conflict for ECHO resolved using rule 38 (stackPop -> ID OBJOP POP SEMICOLON .)
  ! reduce/reduce conflict for PRINT resolved using rule 38 (stackPop -> ID OBJOP POP SEMICOLON .)
  ! reduce/reduce conflict for INTEGER resolved using rule 38 (stackPop -> ID OBJOP POP SEMICOLON .)
  ! reduce/reduce conflict for FLOAT resolved using rule 38 (stackPop -> ID OBJOP POP SEMICOLON .)
  ! reduce/reduce conflict for STRING resolved using rule 38 (stackPop -> ID OBJOP POP SEMICOLON .)
  ! reduce/reduce conflict for BOOL resolved using rule 38 (stackPop -> ID OBJOP POP SEMICOLON .)
  ! reduce/reduce conflict for NULL resolved using rule 38 (stackPop -> ID OBJOP POP SEMICOLON .)
  ! reduce/reduce conflict for $end resolved using rule 38 (stackPop -> ID OBJOP POP SEMICOLON .)
  ! reduce/reduce conflict for RCURLY resolved using rule 38 (stackPop -> ID OBJOP POP SEMICOLON .)
  ! reduce/reduce conflict for CONTINUE resolved using rule 38 (stackPop -> ID OBJOP POP SEMICOLON .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 38 (stackPop -> ID OBJOP POP SEMICOLON .)
  ! reduce/reduce conflict for BREAK resolved using rule 38 (stackPop -> ID OBJOP POP SEMICOLON .)
    IF              reduce using rule 38 (stackPop -> ID OBJOP POP SEMICOLON .)
    FOR             reduce using rule 38 (stackPop -> ID OBJOP POP SEMICOLON .)
    SWITCH          reduce using rule 38 (stackPop -> ID OBJOP POP SEMICOLON .)
    ID              reduce using rule 38 (stackPop -> ID OBJOP POP SEMICOLON .)
    FUNCTION        reduce using rule 38 (stackPop -> ID OBJOP POP SEMICOLON .)
    FN              reduce using rule 38 (stackPop -> ID OBJOP POP SEMICOLON .)
    ECHO            reduce using rule 38 (stackPop -> ID OBJOP POP SEMICOLON .)
    PRINT           reduce using rule 38 (stackPop -> ID OBJOP POP SEMICOLON .)
    INTEGER         reduce using rule 38 (stackPop -> ID OBJOP POP SEMICOLON .)
    FLOAT           reduce using rule 38 (stackPop -> ID OBJOP POP SEMICOLON .)
    STRING          reduce using rule 38 (stackPop -> ID OBJOP POP SEMICOLON .)
    BOOL            reduce using rule 38 (stackPop -> ID OBJOP POP SEMICOLON .)
    NULL            reduce using rule 38 (stackPop -> ID OBJOP POP SEMICOLON .)
    $end            reduce using rule 38 (stackPop -> ID OBJOP POP SEMICOLON .)
    RCURLY          reduce using rule 38 (stackPop -> ID OBJOP POP SEMICOLON .)
    CONTINUE        reduce using rule 38 (stackPop -> ID OBJOP POP SEMICOLON .)
    SEMICOLON       reduce using rule 38 (stackPop -> ID OBJOP POP SEMICOLON .)
    BREAK           reduce using rule 38 (stackPop -> ID OBJOP POP SEMICOLON .)

  ! IF              [ reduce using rule 41 (queueDequeue -> ID OBJOP POP SEMICOLON .) ]
  ! FOR             [ reduce using rule 41 (queueDequeue -> ID OBJOP POP SEMICOLON .) ]
  ! SWITCH          [ reduce using rule 41 (queueDequeue -> ID OBJOP POP SEMICOLON .) ]
  ! ID              [ reduce using rule 41 (queueDequeue -> ID OBJOP POP SEMICOLON .) ]
  ! FUNCTION        [ reduce using rule 41 (queueDequeue -> ID OBJOP POP SEMICOLON .) ]
  ! FN              [ reduce using rule 41 (queueDequeue -> ID OBJOP POP SEMICOLON .) ]
  ! ECHO            [ reduce using rule 41 (queueDequeue -> ID OBJOP POP SEMICOLON .) ]
  ! PRINT           [ reduce using rule 41 (queueDequeue -> ID OBJOP POP SEMICOLON .) ]
  ! INTEGER         [ reduce using rule 41 (queueDequeue -> ID OBJOP POP SEMICOLON .) ]
  ! FLOAT           [ reduce using rule 41 (queueDequeue -> ID OBJOP POP SEMICOLON .) ]
  ! STRING          [ reduce using rule 41 (queueDequeue -> ID OBJOP POP SEMICOLON .) ]
  ! BOOL            [ reduce using rule 41 (queueDequeue -> ID OBJOP POP SEMICOLON .) ]
  ! NULL            [ reduce using rule 41 (queueDequeue -> ID OBJOP POP SEMICOLON .) ]
  ! $end            [ reduce using rule 41 (queueDequeue -> ID OBJOP POP SEMICOLON .) ]
  ! RCURLY          [ reduce using rule 41 (queueDequeue -> ID OBJOP POP SEMICOLON .) ]
  ! CONTINUE        [ reduce using rule 41 (queueDequeue -> ID OBJOP POP SEMICOLON .) ]
  ! SEMICOLON       [ reduce using rule 41 (queueDequeue -> ID OBJOP POP SEMICOLON .) ]
  ! BREAK           [ reduce using rule 41 (queueDequeue -> ID OBJOP POP SEMICOLON .) ]


state 99

    (42) defineFunction -> FUNCTION ID LPAREN arguments . RPAREN LCURLY cuerpo RCURLY

    RPAREN          shift and go to state 117


state 100

    (43) defineFunction -> FUNCTION ID LPAREN RPAREN . LCURLY cuerpo RCURLY

    LCURLY          shift and go to state 118


state 101

    (46) anonymousFunction -> FUNCTION LPAREN RPAREN LCURLY . cuerpo RCURLY
    (3) cuerpo -> . arithmeticExpression
    (4) cuerpo -> . if_elseStatement
    (5) cuerpo -> . forStatement
    (6) cuerpo -> . switchStatement
    (7) cuerpo -> . queueDeclaration
    (8) cuerpo -> . queueEnqueue
    (9) cuerpo -> . queueDequeue
    (10) cuerpo -> . defineFunction
    (11) cuerpo -> . anonymousFunction
    (12) cuerpo -> . arrowFunction
    (13) cuerpo -> . echo
    (14) cuerpo -> . fgets
    (15) cuerpo -> . stackDeclaration
    (16) cuerpo -> . stackPush
    (17) cuerpo -> . stackPop
    (18) cuerpo -> . line
    (19) cuerpo -> . print
    (57) arithmeticExpression -> . value arithmeticOperator value
    (25) if_elseStatement -> . IF LPAREN comparingValue RPAREN LCURLY ifStatementBody RCURLY ELSE ifStatementBody
    (26) if_elseStatement -> . IF LPAREN comparingValue RPAREN LCURLY ifStatementBody
    (30) forStatement -> . FOR LPAREN forStatementCondition RPAREN LCURLY forStatementBody RCURLY
    (20) switchStatement -> . SWITCH LPAREN value RPAREN LCURLY switchCases switchDefault RCURLY
    (39) queueDeclaration -> . ID EQUAL NEW QUEUE SEMICOLON
    (40) queueEnqueue -> . ID OBJOP PUSH LPAREN value RPAREN SEMICOLON
    (41) queueDequeue -> . ID OBJOP POP SEMICOLON
    (42) defineFunction -> . FUNCTION ID LPAREN arguments RPAREN LCURLY cuerpo RCURLY
    (43) defineFunction -> . FUNCTION ID LPAREN RPAREN LCURLY cuerpo RCURLY
    (46) anonymousFunction -> . FUNCTION LPAREN RPAREN LCURLY cuerpo RCURLY
    (47) anonymousFunction -> . FUNCTION LPAREN arguments RPAREN LCURLY cuerpo RCURLY
    (48) arrowFunction -> . FN LPAREN ID RPAREN FNARROW arrowBody SEMICOLON
    (51) echo -> . ECHO values SEMICOLON
    (56) fgets -> . ID EQUAL FGETS LPAREN STDIN RPAREN SEMICOLON
    (36) stackDeclaration -> . ID EQUAL NEW STACK SEMICOLON
    (37) stackPush -> . ID OBJOP PUSH LPAREN value RPAREN SEMICOLON
    (38) stackPop -> . ID OBJOP POP SEMICOLON
    (70) line -> . variableAsignation SEMICOLON
    (52) print -> . PRINT LPAREN values RPAREN SEMICOLON
    (53) print -> . PRINT value SEMICOLON
    (58) value -> . ID
    (59) value -> . INTEGER
    (60) value -> . FLOAT
    (61) value -> . STRING
    (62) value -> . BOOL
    (63) value -> . NULL
    (71) variableAsignation -> . ID EQUAL value
    (72) variableAsignation -> . ID EQUAL arithmeticExpression

    IF              shift and go to state 21
    FOR             shift and go to state 22
    SWITCH          shift and go to state 23
    ID              shift and go to state 24
    FUNCTION        shift and go to state 25
    FN              shift and go to state 26
    ECHO            shift and go to state 27
    PRINT           shift and go to state 29
    INTEGER         shift and go to state 30
    FLOAT           shift and go to state 31
    STRING          shift and go to state 32
    BOOL            shift and go to state 33
    NULL            shift and go to state 34

    cuerpo                         shift and go to state 119
    arithmeticExpression           shift and go to state 3
    if_elseStatement               shift and go to state 4
    forStatement                   shift and go to state 5
    switchStatement                shift and go to state 6
    queueDeclaration               shift and go to state 7
    queueEnqueue                   shift and go to state 8
    queueDequeue                   shift and go to state 9
    defineFunction                 shift and go to state 10
    anonymousFunction              shift and go to state 11
    arrowFunction                  shift and go to state 12
    echo                           shift and go to state 13
    fgets                          shift and go to state 14
    stackDeclaration               shift and go to state 15
    stackPush                      shift and go to state 16
    stackPop                       shift and go to state 17
    line                           shift and go to state 18
    print                          shift and go to state 19
    value                          shift and go to state 20
    variableAsignation             shift and go to state 28

state 102

    (47) anonymousFunction -> FUNCTION LPAREN arguments RPAREN . LCURLY cuerpo RCURLY

    LCURLY          shift and go to state 120


state 103

    (45) arguments -> ID COMMA . arguments
    (44) arguments -> . ID
    (45) arguments -> . ID COMMA arguments

    ID              shift and go to state 74

    arguments                      shift and go to state 121

state 104

    (48) arrowFunction -> FN LPAREN ID RPAREN . FNARROW arrowBody SEMICOLON

    FNARROW         shift and go to state 122


state 105

    (55) values -> values COMMA value .

    SEMICOLON       reduce using rule 55 (values -> values COMMA value .)
    COMMA           reduce using rule 55 (values -> values COMMA value .)
    RPAREN          reduce using rule 55 (values -> values COMMA value .)


state 106

    (52) print -> PRINT LPAREN values RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 123


state 107

    (25) if_elseStatement -> IF LPAREN comparingValue RPAREN LCURLY . ifStatementBody RCURLY ELSE ifStatementBody
    (26) if_elseStatement -> IF LPAREN comparingValue RPAREN LCURLY . ifStatementBody
    (27) ifStatementBody -> . cuerpo
    (28) ifStatementBody -> . cuerpo CONTINUE SEMICOLON
    (29) ifStatementBody -> . ifStatementBody cuerpo
    (3) cuerpo -> . arithmeticExpression
    (4) cuerpo -> . if_elseStatement
    (5) cuerpo -> . forStatement
    (6) cuerpo -> . switchStatement
    (7) cuerpo -> . queueDeclaration
    (8) cuerpo -> . queueEnqueue
    (9) cuerpo -> . queueDequeue
    (10) cuerpo -> . defineFunction
    (11) cuerpo -> . anonymousFunction
    (12) cuerpo -> . arrowFunction
    (13) cuerpo -> . echo
    (14) cuerpo -> . fgets
    (15) cuerpo -> . stackDeclaration
    (16) cuerpo -> . stackPush
    (17) cuerpo -> . stackPop
    (18) cuerpo -> . line
    (19) cuerpo -> . print
    (57) arithmeticExpression -> . value arithmeticOperator value
    (25) if_elseStatement -> . IF LPAREN comparingValue RPAREN LCURLY ifStatementBody RCURLY ELSE ifStatementBody
    (26) if_elseStatement -> . IF LPAREN comparingValue RPAREN LCURLY ifStatementBody
    (30) forStatement -> . FOR LPAREN forStatementCondition RPAREN LCURLY forStatementBody RCURLY
    (20) switchStatement -> . SWITCH LPAREN value RPAREN LCURLY switchCases switchDefault RCURLY
    (39) queueDeclaration -> . ID EQUAL NEW QUEUE SEMICOLON
    (40) queueEnqueue -> . ID OBJOP PUSH LPAREN value RPAREN SEMICOLON
    (41) queueDequeue -> . ID OBJOP POP SEMICOLON
    (42) defineFunction -> . FUNCTION ID LPAREN arguments RPAREN LCURLY cuerpo RCURLY
    (43) defineFunction -> . FUNCTION ID LPAREN RPAREN LCURLY cuerpo RCURLY
    (46) anonymousFunction -> . FUNCTION LPAREN RPAREN LCURLY cuerpo RCURLY
    (47) anonymousFunction -> . FUNCTION LPAREN arguments RPAREN LCURLY cuerpo RCURLY
    (48) arrowFunction -> . FN LPAREN ID RPAREN FNARROW arrowBody SEMICOLON
    (51) echo -> . ECHO values SEMICOLON
    (56) fgets -> . ID EQUAL FGETS LPAREN STDIN RPAREN SEMICOLON
    (36) stackDeclaration -> . ID EQUAL NEW STACK SEMICOLON
    (37) stackPush -> . ID OBJOP PUSH LPAREN value RPAREN SEMICOLON
    (38) stackPop -> . ID OBJOP POP SEMICOLON
    (70) line -> . variableAsignation SEMICOLON
    (52) print -> . PRINT LPAREN values RPAREN SEMICOLON
    (53) print -> . PRINT value SEMICOLON
    (58) value -> . ID
    (59) value -> . INTEGER
    (60) value -> . FLOAT
    (61) value -> . STRING
    (62) value -> . BOOL
    (63) value -> . NULL
    (71) variableAsignation -> . ID EQUAL value
    (72) variableAsignation -> . ID EQUAL arithmeticExpression

    IF              shift and go to state 21
    FOR             shift and go to state 22
    SWITCH          shift and go to state 23
    ID              shift and go to state 24
    FUNCTION        shift and go to state 25
    FN              shift and go to state 26
    ECHO            shift and go to state 27
    PRINT           shift and go to state 29
    INTEGER         shift and go to state 30
    FLOAT           shift and go to state 31
    STRING          shift and go to state 32
    BOOL            shift and go to state 33
    NULL            shift and go to state 34

    ifStatementBody                shift and go to state 124
    cuerpo                         shift and go to state 125
    arithmeticExpression           shift and go to state 3
    if_elseStatement               shift and go to state 4
    forStatement                   shift and go to state 5
    switchStatement                shift and go to state 6
    queueDeclaration               shift and go to state 7
    queueEnqueue                   shift and go to state 8
    queueDequeue                   shift and go to state 9
    defineFunction                 shift and go to state 10
    anonymousFunction              shift and go to state 11
    arrowFunction                  shift and go to state 12
    echo                           shift and go to state 13
    fgets                          shift and go to state 14
    stackDeclaration               shift and go to state 15
    stackPush                      shift and go to state 16
    stackPop                       shift and go to state 17
    line                           shift and go to state 18
    print                          shift and go to state 19
    value                          shift and go to state 20
    variableAsignation             shift and go to state 28

state 108

    (80) comparingValue -> value comparingSign value .

    RPAREN          reduce using rule 80 (comparingValue -> value comparingSign value .)
    SEMICOLON       reduce using rule 80 (comparingValue -> value comparingSign value .)


state 109

    (30) forStatement -> FOR LPAREN forStatementCondition RPAREN LCURLY . forStatementBody RCURLY
    (34) forStatementBody -> . cuerpo
    (35) forStatementBody -> . forStatementBody cuerpo
    (3) cuerpo -> . arithmeticExpression
    (4) cuerpo -> . if_elseStatement
    (5) cuerpo -> . forStatement
    (6) cuerpo -> . switchStatement
    (7) cuerpo -> . queueDeclaration
    (8) cuerpo -> . queueEnqueue
    (9) cuerpo -> . queueDequeue
    (10) cuerpo -> . defineFunction
    (11) cuerpo -> . anonymousFunction
    (12) cuerpo -> . arrowFunction
    (13) cuerpo -> . echo
    (14) cuerpo -> . fgets
    (15) cuerpo -> . stackDeclaration
    (16) cuerpo -> . stackPush
    (17) cuerpo -> . stackPop
    (18) cuerpo -> . line
    (19) cuerpo -> . print
    (57) arithmeticExpression -> . value arithmeticOperator value
    (25) if_elseStatement -> . IF LPAREN comparingValue RPAREN LCURLY ifStatementBody RCURLY ELSE ifStatementBody
    (26) if_elseStatement -> . IF LPAREN comparingValue RPAREN LCURLY ifStatementBody
    (30) forStatement -> . FOR LPAREN forStatementCondition RPAREN LCURLY forStatementBody RCURLY
    (20) switchStatement -> . SWITCH LPAREN value RPAREN LCURLY switchCases switchDefault RCURLY
    (39) queueDeclaration -> . ID EQUAL NEW QUEUE SEMICOLON
    (40) queueEnqueue -> . ID OBJOP PUSH LPAREN value RPAREN SEMICOLON
    (41) queueDequeue -> . ID OBJOP POP SEMICOLON
    (42) defineFunction -> . FUNCTION ID LPAREN arguments RPAREN LCURLY cuerpo RCURLY
    (43) defineFunction -> . FUNCTION ID LPAREN RPAREN LCURLY cuerpo RCURLY
    (46) anonymousFunction -> . FUNCTION LPAREN RPAREN LCURLY cuerpo RCURLY
    (47) anonymousFunction -> . FUNCTION LPAREN arguments RPAREN LCURLY cuerpo RCURLY
    (48) arrowFunction -> . FN LPAREN ID RPAREN FNARROW arrowBody SEMICOLON
    (51) echo -> . ECHO values SEMICOLON
    (56) fgets -> . ID EQUAL FGETS LPAREN STDIN RPAREN SEMICOLON
    (36) stackDeclaration -> . ID EQUAL NEW STACK SEMICOLON
    (37) stackPush -> . ID OBJOP PUSH LPAREN value RPAREN SEMICOLON
    (38) stackPop -> . ID OBJOP POP SEMICOLON
    (70) line -> . variableAsignation SEMICOLON
    (52) print -> . PRINT LPAREN values RPAREN SEMICOLON
    (53) print -> . PRINT value SEMICOLON
    (58) value -> . ID
    (59) value -> . INTEGER
    (60) value -> . FLOAT
    (61) value -> . STRING
    (62) value -> . BOOL
    (63) value -> . NULL
    (71) variableAsignation -> . ID EQUAL value
    (72) variableAsignation -> . ID EQUAL arithmeticExpression

    IF              shift and go to state 21
    FOR             shift and go to state 22
    SWITCH          shift and go to state 23
    ID              shift and go to state 24
    FUNCTION        shift and go to state 25
    FN              shift and go to state 26
    ECHO            shift and go to state 27
    PRINT           shift and go to state 29
    INTEGER         shift and go to state 30
    FLOAT           shift and go to state 31
    STRING          shift and go to state 32
    BOOL            shift and go to state 33
    NULL            shift and go to state 34

    forStatementBody               shift and go to state 126
    cuerpo                         shift and go to state 127
    arithmeticExpression           shift and go to state 3
    if_elseStatement               shift and go to state 4
    forStatement                   shift and go to state 5
    switchStatement                shift and go to state 6
    queueDeclaration               shift and go to state 7
    queueEnqueue                   shift and go to state 8
    queueDequeue                   shift and go to state 9
    defineFunction                 shift and go to state 10
    anonymousFunction              shift and go to state 11
    arrowFunction                  shift and go to state 12
    echo                           shift and go to state 13
    fgets                          shift and go to state 14
    stackDeclaration               shift and go to state 15
    stackPush                      shift and go to state 16
    stackPop                       shift and go to state 17
    line                           shift and go to state 18
    print                          shift and go to state 19
    value                          shift and go to state 20
    variableAsignation             shift and go to state 28

state 110

    (32) forStatementCondition -> variableAsignation SEMICOLON SEMICOLON . variableAsignation
    (71) variableAsignation -> . ID EQUAL value
    (72) variableAsignation -> . ID EQUAL arithmeticExpression

    ID              shift and go to state 63

    variableAsignation             shift and go to state 128

state 111

    (33) forStatementCondition -> variableAsignation SEMICOLON comparingValue . SEMICOLON variableAsignation

    SEMICOLON       shift and go to state 129


state 112

    (20) switchStatement -> SWITCH LPAREN value RPAREN LCURLY . switchCases switchDefault RCURLY
    (23) switchCases -> . switchCase
    (24) switchCases -> . switchCases switchCase
    (22) switchCase -> . CASE value COLON cuerpo BREAK SEMICOLON

    CASE            shift and go to state 132

    switchCases                    shift and go to state 130
    switchCase                     shift and go to state 131

state 113

    (39) queueDeclaration -> ID EQUAL NEW QUEUE SEMICOLON .

    IF              reduce using rule 39 (queueDeclaration -> ID EQUAL NEW QUEUE SEMICOLON .)
    FOR             reduce using rule 39 (queueDeclaration -> ID EQUAL NEW QUEUE SEMICOLON .)
    SWITCH          reduce using rule 39 (queueDeclaration -> ID EQUAL NEW QUEUE SEMICOLON .)
    ID              reduce using rule 39 (queueDeclaration -> ID EQUAL NEW QUEUE SEMICOLON .)
    FUNCTION        reduce using rule 39 (queueDeclaration -> ID EQUAL NEW QUEUE SEMICOLON .)
    FN              reduce using rule 39 (queueDeclaration -> ID EQUAL NEW QUEUE SEMICOLON .)
    ECHO            reduce using rule 39 (queueDeclaration -> ID EQUAL NEW QUEUE SEMICOLON .)
    PRINT           reduce using rule 39 (queueDeclaration -> ID EQUAL NEW QUEUE SEMICOLON .)
    INTEGER         reduce using rule 39 (queueDeclaration -> ID EQUAL NEW QUEUE SEMICOLON .)
    FLOAT           reduce using rule 39 (queueDeclaration -> ID EQUAL NEW QUEUE SEMICOLON .)
    STRING          reduce using rule 39 (queueDeclaration -> ID EQUAL NEW QUEUE SEMICOLON .)
    BOOL            reduce using rule 39 (queueDeclaration -> ID EQUAL NEW QUEUE SEMICOLON .)
    NULL            reduce using rule 39 (queueDeclaration -> ID EQUAL NEW QUEUE SEMICOLON .)
    $end            reduce using rule 39 (queueDeclaration -> ID EQUAL NEW QUEUE SEMICOLON .)
    RCURLY          reduce using rule 39 (queueDeclaration -> ID EQUAL NEW QUEUE SEMICOLON .)
    CONTINUE        reduce using rule 39 (queueDeclaration -> ID EQUAL NEW QUEUE SEMICOLON .)
    SEMICOLON       reduce using rule 39 (queueDeclaration -> ID EQUAL NEW QUEUE SEMICOLON .)
    BREAK           reduce using rule 39 (queueDeclaration -> ID EQUAL NEW QUEUE SEMICOLON .)


state 114

    (36) stackDeclaration -> ID EQUAL NEW STACK SEMICOLON .

    IF              reduce using rule 36 (stackDeclaration -> ID EQUAL NEW STACK SEMICOLON .)
    FOR             reduce using rule 36 (stackDeclaration -> ID EQUAL NEW STACK SEMICOLON .)
    SWITCH          reduce using rule 36 (stackDeclaration -> ID EQUAL NEW STACK SEMICOLON .)
    ID              reduce using rule 36 (stackDeclaration -> ID EQUAL NEW STACK SEMICOLON .)
    FUNCTION        reduce using rule 36 (stackDeclaration -> ID EQUAL NEW STACK SEMICOLON .)
    FN              reduce using rule 36 (stackDeclaration -> ID EQUAL NEW STACK SEMICOLON .)
    ECHO            reduce using rule 36 (stackDeclaration -> ID EQUAL NEW STACK SEMICOLON .)
    PRINT           reduce using rule 36 (stackDeclaration -> ID EQUAL NEW STACK SEMICOLON .)
    INTEGER         reduce using rule 36 (stackDeclaration -> ID EQUAL NEW STACK SEMICOLON .)
    FLOAT           reduce using rule 36 (stackDeclaration -> ID EQUAL NEW STACK SEMICOLON .)
    STRING          reduce using rule 36 (stackDeclaration -> ID EQUAL NEW STACK SEMICOLON .)
    BOOL            reduce using rule 36 (stackDeclaration -> ID EQUAL NEW STACK SEMICOLON .)
    NULL            reduce using rule 36 (stackDeclaration -> ID EQUAL NEW STACK SEMICOLON .)
    $end            reduce using rule 36 (stackDeclaration -> ID EQUAL NEW STACK SEMICOLON .)
    RCURLY          reduce using rule 36 (stackDeclaration -> ID EQUAL NEW STACK SEMICOLON .)
    CONTINUE        reduce using rule 36 (stackDeclaration -> ID EQUAL NEW STACK SEMICOLON .)
    SEMICOLON       reduce using rule 36 (stackDeclaration -> ID EQUAL NEW STACK SEMICOLON .)
    BREAK           reduce using rule 36 (stackDeclaration -> ID EQUAL NEW STACK SEMICOLON .)


state 115

    (56) fgets -> ID EQUAL FGETS LPAREN STDIN . RPAREN SEMICOLON

    RPAREN          shift and go to state 133


state 116

    (40) queueEnqueue -> ID OBJOP PUSH LPAREN value . RPAREN SEMICOLON
    (37) stackPush -> ID OBJOP PUSH LPAREN value . RPAREN SEMICOLON

    RPAREN          shift and go to state 134


state 117

    (42) defineFunction -> FUNCTION ID LPAREN arguments RPAREN . LCURLY cuerpo RCURLY

    LCURLY          shift and go to state 135


state 118

    (43) defineFunction -> FUNCTION ID LPAREN RPAREN LCURLY . cuerpo RCURLY
    (3) cuerpo -> . arithmeticExpression
    (4) cuerpo -> . if_elseStatement
    (5) cuerpo -> . forStatement
    (6) cuerpo -> . switchStatement
    (7) cuerpo -> . queueDeclaration
    (8) cuerpo -> . queueEnqueue
    (9) cuerpo -> . queueDequeue
    (10) cuerpo -> . defineFunction
    (11) cuerpo -> . anonymousFunction
    (12) cuerpo -> . arrowFunction
    (13) cuerpo -> . echo
    (14) cuerpo -> . fgets
    (15) cuerpo -> . stackDeclaration
    (16) cuerpo -> . stackPush
    (17) cuerpo -> . stackPop
    (18) cuerpo -> . line
    (19) cuerpo -> . print
    (57) arithmeticExpression -> . value arithmeticOperator value
    (25) if_elseStatement -> . IF LPAREN comparingValue RPAREN LCURLY ifStatementBody RCURLY ELSE ifStatementBody
    (26) if_elseStatement -> . IF LPAREN comparingValue RPAREN LCURLY ifStatementBody
    (30) forStatement -> . FOR LPAREN forStatementCondition RPAREN LCURLY forStatementBody RCURLY
    (20) switchStatement -> . SWITCH LPAREN value RPAREN LCURLY switchCases switchDefault RCURLY
    (39) queueDeclaration -> . ID EQUAL NEW QUEUE SEMICOLON
    (40) queueEnqueue -> . ID OBJOP PUSH LPAREN value RPAREN SEMICOLON
    (41) queueDequeue -> . ID OBJOP POP SEMICOLON
    (42) defineFunction -> . FUNCTION ID LPAREN arguments RPAREN LCURLY cuerpo RCURLY
    (43) defineFunction -> . FUNCTION ID LPAREN RPAREN LCURLY cuerpo RCURLY
    (46) anonymousFunction -> . FUNCTION LPAREN RPAREN LCURLY cuerpo RCURLY
    (47) anonymousFunction -> . FUNCTION LPAREN arguments RPAREN LCURLY cuerpo RCURLY
    (48) arrowFunction -> . FN LPAREN ID RPAREN FNARROW arrowBody SEMICOLON
    (51) echo -> . ECHO values SEMICOLON
    (56) fgets -> . ID EQUAL FGETS LPAREN STDIN RPAREN SEMICOLON
    (36) stackDeclaration -> . ID EQUAL NEW STACK SEMICOLON
    (37) stackPush -> . ID OBJOP PUSH LPAREN value RPAREN SEMICOLON
    (38) stackPop -> . ID OBJOP POP SEMICOLON
    (70) line -> . variableAsignation SEMICOLON
    (52) print -> . PRINT LPAREN values RPAREN SEMICOLON
    (53) print -> . PRINT value SEMICOLON
    (58) value -> . ID
    (59) value -> . INTEGER
    (60) value -> . FLOAT
    (61) value -> . STRING
    (62) value -> . BOOL
    (63) value -> . NULL
    (71) variableAsignation -> . ID EQUAL value
    (72) variableAsignation -> . ID EQUAL arithmeticExpression

    IF              shift and go to state 21
    FOR             shift and go to state 22
    SWITCH          shift and go to state 23
    ID              shift and go to state 24
    FUNCTION        shift and go to state 25
    FN              shift and go to state 26
    ECHO            shift and go to state 27
    PRINT           shift and go to state 29
    INTEGER         shift and go to state 30
    FLOAT           shift and go to state 31
    STRING          shift and go to state 32
    BOOL            shift and go to state 33
    NULL            shift and go to state 34

    cuerpo                         shift and go to state 136
    arithmeticExpression           shift and go to state 3
    if_elseStatement               shift and go to state 4
    forStatement                   shift and go to state 5
    switchStatement                shift and go to state 6
    queueDeclaration               shift and go to state 7
    queueEnqueue                   shift and go to state 8
    queueDequeue                   shift and go to state 9
    defineFunction                 shift and go to state 10
    anonymousFunction              shift and go to state 11
    arrowFunction                  shift and go to state 12
    echo                           shift and go to state 13
    fgets                          shift and go to state 14
    stackDeclaration               shift and go to state 15
    stackPush                      shift and go to state 16
    stackPop                       shift and go to state 17
    line                           shift and go to state 18
    print                          shift and go to state 19
    value                          shift and go to state 20
    variableAsignation             shift and go to state 28

state 119

    (46) anonymousFunction -> FUNCTION LPAREN RPAREN LCURLY cuerpo . RCURLY

    RCURLY          shift and go to state 137


state 120

    (47) anonymousFunction -> FUNCTION LPAREN arguments RPAREN LCURLY . cuerpo RCURLY
    (3) cuerpo -> . arithmeticExpression
    (4) cuerpo -> . if_elseStatement
    (5) cuerpo -> . forStatement
    (6) cuerpo -> . switchStatement
    (7) cuerpo -> . queueDeclaration
    (8) cuerpo -> . queueEnqueue
    (9) cuerpo -> . queueDequeue
    (10) cuerpo -> . defineFunction
    (11) cuerpo -> . anonymousFunction
    (12) cuerpo -> . arrowFunction
    (13) cuerpo -> . echo
    (14) cuerpo -> . fgets
    (15) cuerpo -> . stackDeclaration
    (16) cuerpo -> . stackPush
    (17) cuerpo -> . stackPop
    (18) cuerpo -> . line
    (19) cuerpo -> . print
    (57) arithmeticExpression -> . value arithmeticOperator value
    (25) if_elseStatement -> . IF LPAREN comparingValue RPAREN LCURLY ifStatementBody RCURLY ELSE ifStatementBody
    (26) if_elseStatement -> . IF LPAREN comparingValue RPAREN LCURLY ifStatementBody
    (30) forStatement -> . FOR LPAREN forStatementCondition RPAREN LCURLY forStatementBody RCURLY
    (20) switchStatement -> . SWITCH LPAREN value RPAREN LCURLY switchCases switchDefault RCURLY
    (39) queueDeclaration -> . ID EQUAL NEW QUEUE SEMICOLON
    (40) queueEnqueue -> . ID OBJOP PUSH LPAREN value RPAREN SEMICOLON
    (41) queueDequeue -> . ID OBJOP POP SEMICOLON
    (42) defineFunction -> . FUNCTION ID LPAREN arguments RPAREN LCURLY cuerpo RCURLY
    (43) defineFunction -> . FUNCTION ID LPAREN RPAREN LCURLY cuerpo RCURLY
    (46) anonymousFunction -> . FUNCTION LPAREN RPAREN LCURLY cuerpo RCURLY
    (47) anonymousFunction -> . FUNCTION LPAREN arguments RPAREN LCURLY cuerpo RCURLY
    (48) arrowFunction -> . FN LPAREN ID RPAREN FNARROW arrowBody SEMICOLON
    (51) echo -> . ECHO values SEMICOLON
    (56) fgets -> . ID EQUAL FGETS LPAREN STDIN RPAREN SEMICOLON
    (36) stackDeclaration -> . ID EQUAL NEW STACK SEMICOLON
    (37) stackPush -> . ID OBJOP PUSH LPAREN value RPAREN SEMICOLON
    (38) stackPop -> . ID OBJOP POP SEMICOLON
    (70) line -> . variableAsignation SEMICOLON
    (52) print -> . PRINT LPAREN values RPAREN SEMICOLON
    (53) print -> . PRINT value SEMICOLON
    (58) value -> . ID
    (59) value -> . INTEGER
    (60) value -> . FLOAT
    (61) value -> . STRING
    (62) value -> . BOOL
    (63) value -> . NULL
    (71) variableAsignation -> . ID EQUAL value
    (72) variableAsignation -> . ID EQUAL arithmeticExpression

    IF              shift and go to state 21
    FOR             shift and go to state 22
    SWITCH          shift and go to state 23
    ID              shift and go to state 24
    FUNCTION        shift and go to state 25
    FN              shift and go to state 26
    ECHO            shift and go to state 27
    PRINT           shift and go to state 29
    INTEGER         shift and go to state 30
    FLOAT           shift and go to state 31
    STRING          shift and go to state 32
    BOOL            shift and go to state 33
    NULL            shift and go to state 34

    cuerpo                         shift and go to state 138
    arithmeticExpression           shift and go to state 3
    if_elseStatement               shift and go to state 4
    forStatement                   shift and go to state 5
    switchStatement                shift and go to state 6
    queueDeclaration               shift and go to state 7
    queueEnqueue                   shift and go to state 8
    queueDequeue                   shift and go to state 9
    defineFunction                 shift and go to state 10
    anonymousFunction              shift and go to state 11
    arrowFunction                  shift and go to state 12
    echo                           shift and go to state 13
    fgets                          shift and go to state 14
    stackDeclaration               shift and go to state 15
    stackPush                      shift and go to state 16
    stackPop                       shift and go to state 17
    line                           shift and go to state 18
    print                          shift and go to state 19
    value                          shift and go to state 20
    variableAsignation             shift and go to state 28

state 121

    (45) arguments -> ID COMMA arguments .

    RPAREN          reduce using rule 45 (arguments -> ID COMMA arguments .)


state 122

    (48) arrowFunction -> FN LPAREN ID RPAREN FNARROW . arrowBody SEMICOLON
    (49) arrowBody -> . FN LPAREN ID RPAREN FNARROW arrowBody
    (50) arrowBody -> . cuerpo
    (3) cuerpo -> . arithmeticExpression
    (4) cuerpo -> . if_elseStatement
    (5) cuerpo -> . forStatement
    (6) cuerpo -> . switchStatement
    (7) cuerpo -> . queueDeclaration
    (8) cuerpo -> . queueEnqueue
    (9) cuerpo -> . queueDequeue
    (10) cuerpo -> . defineFunction
    (11) cuerpo -> . anonymousFunction
    (12) cuerpo -> . arrowFunction
    (13) cuerpo -> . echo
    (14) cuerpo -> . fgets
    (15) cuerpo -> . stackDeclaration
    (16) cuerpo -> . stackPush
    (17) cuerpo -> . stackPop
    (18) cuerpo -> . line
    (19) cuerpo -> . print
    (57) arithmeticExpression -> . value arithmeticOperator value
    (25) if_elseStatement -> . IF LPAREN comparingValue RPAREN LCURLY ifStatementBody RCURLY ELSE ifStatementBody
    (26) if_elseStatement -> . IF LPAREN comparingValue RPAREN LCURLY ifStatementBody
    (30) forStatement -> . FOR LPAREN forStatementCondition RPAREN LCURLY forStatementBody RCURLY
    (20) switchStatement -> . SWITCH LPAREN value RPAREN LCURLY switchCases switchDefault RCURLY
    (39) queueDeclaration -> . ID EQUAL NEW QUEUE SEMICOLON
    (40) queueEnqueue -> . ID OBJOP PUSH LPAREN value RPAREN SEMICOLON
    (41) queueDequeue -> . ID OBJOP POP SEMICOLON
    (42) defineFunction -> . FUNCTION ID LPAREN arguments RPAREN LCURLY cuerpo RCURLY
    (43) defineFunction -> . FUNCTION ID LPAREN RPAREN LCURLY cuerpo RCURLY
    (46) anonymousFunction -> . FUNCTION LPAREN RPAREN LCURLY cuerpo RCURLY
    (47) anonymousFunction -> . FUNCTION LPAREN arguments RPAREN LCURLY cuerpo RCURLY
    (48) arrowFunction -> . FN LPAREN ID RPAREN FNARROW arrowBody SEMICOLON
    (51) echo -> . ECHO values SEMICOLON
    (56) fgets -> . ID EQUAL FGETS LPAREN STDIN RPAREN SEMICOLON
    (36) stackDeclaration -> . ID EQUAL NEW STACK SEMICOLON
    (37) stackPush -> . ID OBJOP PUSH LPAREN value RPAREN SEMICOLON
    (38) stackPop -> . ID OBJOP POP SEMICOLON
    (70) line -> . variableAsignation SEMICOLON
    (52) print -> . PRINT LPAREN values RPAREN SEMICOLON
    (53) print -> . PRINT value SEMICOLON
    (58) value -> . ID
    (59) value -> . INTEGER
    (60) value -> . FLOAT
    (61) value -> . STRING
    (62) value -> . BOOL
    (63) value -> . NULL
    (71) variableAsignation -> . ID EQUAL value
    (72) variableAsignation -> . ID EQUAL arithmeticExpression

    FN              shift and go to state 139
    IF              shift and go to state 21
    FOR             shift and go to state 22
    SWITCH          shift and go to state 23
    ID              shift and go to state 24
    FUNCTION        shift and go to state 25
    ECHO            shift and go to state 27
    PRINT           shift and go to state 29
    INTEGER         shift and go to state 30
    FLOAT           shift and go to state 31
    STRING          shift and go to state 32
    BOOL            shift and go to state 33
    NULL            shift and go to state 34

    arrowBody                      shift and go to state 140
    cuerpo                         shift and go to state 141
    arithmeticExpression           shift and go to state 3
    if_elseStatement               shift and go to state 4
    forStatement                   shift and go to state 5
    switchStatement                shift and go to state 6
    queueDeclaration               shift and go to state 7
    queueEnqueue                   shift and go to state 8
    queueDequeue                   shift and go to state 9
    defineFunction                 shift and go to state 10
    anonymousFunction              shift and go to state 11
    arrowFunction                  shift and go to state 12
    echo                           shift and go to state 13
    fgets                          shift and go to state 14
    stackDeclaration               shift and go to state 15
    stackPush                      shift and go to state 16
    stackPop                       shift and go to state 17
    line                           shift and go to state 18
    print                          shift and go to state 19
    value                          shift and go to state 20
    variableAsignation             shift and go to state 28

state 123

    (52) print -> PRINT LPAREN values RPAREN SEMICOLON .

    IF              reduce using rule 52 (print -> PRINT LPAREN values RPAREN SEMICOLON .)
    FOR             reduce using rule 52 (print -> PRINT LPAREN values RPAREN SEMICOLON .)
    SWITCH          reduce using rule 52 (print -> PRINT LPAREN values RPAREN SEMICOLON .)
    ID              reduce using rule 52 (print -> PRINT LPAREN values RPAREN SEMICOLON .)
    FUNCTION        reduce using rule 52 (print -> PRINT LPAREN values RPAREN SEMICOLON .)
    FN              reduce using rule 52 (print -> PRINT LPAREN values RPAREN SEMICOLON .)
    ECHO            reduce using rule 52 (print -> PRINT LPAREN values RPAREN SEMICOLON .)
    PRINT           reduce using rule 52 (print -> PRINT LPAREN values RPAREN SEMICOLON .)
    INTEGER         reduce using rule 52 (print -> PRINT LPAREN values RPAREN SEMICOLON .)
    FLOAT           reduce using rule 52 (print -> PRINT LPAREN values RPAREN SEMICOLON .)
    STRING          reduce using rule 52 (print -> PRINT LPAREN values RPAREN SEMICOLON .)
    BOOL            reduce using rule 52 (print -> PRINT LPAREN values RPAREN SEMICOLON .)
    NULL            reduce using rule 52 (print -> PRINT LPAREN values RPAREN SEMICOLON .)
    $end            reduce using rule 52 (print -> PRINT LPAREN values RPAREN SEMICOLON .)
    RCURLY          reduce using rule 52 (print -> PRINT LPAREN values RPAREN SEMICOLON .)
    CONTINUE        reduce using rule 52 (print -> PRINT LPAREN values RPAREN SEMICOLON .)
    SEMICOLON       reduce using rule 52 (print -> PRINT LPAREN values RPAREN SEMICOLON .)
    BREAK           reduce using rule 52 (print -> PRINT LPAREN values RPAREN SEMICOLON .)


state 124

    (25) if_elseStatement -> IF LPAREN comparingValue RPAREN LCURLY ifStatementBody . RCURLY ELSE ifStatementBody
    (26) if_elseStatement -> IF LPAREN comparingValue RPAREN LCURLY ifStatementBody .
    (29) ifStatementBody -> ifStatementBody . cuerpo
    (3) cuerpo -> . arithmeticExpression
    (4) cuerpo -> . if_elseStatement
    (5) cuerpo -> . forStatement
    (6) cuerpo -> . switchStatement
    (7) cuerpo -> . queueDeclaration
    (8) cuerpo -> . queueEnqueue
    (9) cuerpo -> . queueDequeue
    (10) cuerpo -> . defineFunction
    (11) cuerpo -> . anonymousFunction
    (12) cuerpo -> . arrowFunction
    (13) cuerpo -> . echo
    (14) cuerpo -> . fgets
    (15) cuerpo -> . stackDeclaration
    (16) cuerpo -> . stackPush
    (17) cuerpo -> . stackPop
    (18) cuerpo -> . line
    (19) cuerpo -> . print
    (57) arithmeticExpression -> . value arithmeticOperator value
    (25) if_elseStatement -> . IF LPAREN comparingValue RPAREN LCURLY ifStatementBody RCURLY ELSE ifStatementBody
    (26) if_elseStatement -> . IF LPAREN comparingValue RPAREN LCURLY ifStatementBody
    (30) forStatement -> . FOR LPAREN forStatementCondition RPAREN LCURLY forStatementBody RCURLY
    (20) switchStatement -> . SWITCH LPAREN value RPAREN LCURLY switchCases switchDefault RCURLY
    (39) queueDeclaration -> . ID EQUAL NEW QUEUE SEMICOLON
    (40) queueEnqueue -> . ID OBJOP PUSH LPAREN value RPAREN SEMICOLON
    (41) queueDequeue -> . ID OBJOP POP SEMICOLON
    (42) defineFunction -> . FUNCTION ID LPAREN arguments RPAREN LCURLY cuerpo RCURLY
    (43) defineFunction -> . FUNCTION ID LPAREN RPAREN LCURLY cuerpo RCURLY
    (46) anonymousFunction -> . FUNCTION LPAREN RPAREN LCURLY cuerpo RCURLY
    (47) anonymousFunction -> . FUNCTION LPAREN arguments RPAREN LCURLY cuerpo RCURLY
    (48) arrowFunction -> . FN LPAREN ID RPAREN FNARROW arrowBody SEMICOLON
    (51) echo -> . ECHO values SEMICOLON
    (56) fgets -> . ID EQUAL FGETS LPAREN STDIN RPAREN SEMICOLON
    (36) stackDeclaration -> . ID EQUAL NEW STACK SEMICOLON
    (37) stackPush -> . ID OBJOP PUSH LPAREN value RPAREN SEMICOLON
    (38) stackPop -> . ID OBJOP POP SEMICOLON
    (70) line -> . variableAsignation SEMICOLON
    (52) print -> . PRINT LPAREN values RPAREN SEMICOLON
    (53) print -> . PRINT value SEMICOLON
    (58) value -> . ID
    (59) value -> . INTEGER
    (60) value -> . FLOAT
    (61) value -> . STRING
    (62) value -> . BOOL
    (63) value -> . NULL
    (71) variableAsignation -> . ID EQUAL value
    (72) variableAsignation -> . ID EQUAL arithmeticExpression

  ! shift/reduce conflict for RCURLY resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for SWITCH resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for FUNCTION resolved as shift
  ! shift/reduce conflict for FN resolved as shift
  ! shift/reduce conflict for ECHO resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for BOOL resolved as shift
  ! shift/reduce conflict for NULL resolved as shift
    RCURLY          shift and go to state 142
    $end            reduce using rule 26 (if_elseStatement -> IF LPAREN comparingValue RPAREN LCURLY ifStatementBody .)
    CONTINUE        reduce using rule 26 (if_elseStatement -> IF LPAREN comparingValue RPAREN LCURLY ifStatementBody .)
    SEMICOLON       reduce using rule 26 (if_elseStatement -> IF LPAREN comparingValue RPAREN LCURLY ifStatementBody .)
    BREAK           reduce using rule 26 (if_elseStatement -> IF LPAREN comparingValue RPAREN LCURLY ifStatementBody .)
    IF              shift and go to state 21
    FOR             shift and go to state 22
    SWITCH          shift and go to state 23
    ID              shift and go to state 24
    FUNCTION        shift and go to state 25
    FN              shift and go to state 26
    ECHO            shift and go to state 27
    PRINT           shift and go to state 29
    INTEGER         shift and go to state 30
    FLOAT           shift and go to state 31
    STRING          shift and go to state 32
    BOOL            shift and go to state 33
    NULL            shift and go to state 34

  ! IF              [ reduce using rule 26 (if_elseStatement -> IF LPAREN comparingValue RPAREN LCURLY ifStatementBody .) ]
  ! FOR             [ reduce using rule 26 (if_elseStatement -> IF LPAREN comparingValue RPAREN LCURLY ifStatementBody .) ]
  ! SWITCH          [ reduce using rule 26 (if_elseStatement -> IF LPAREN comparingValue RPAREN LCURLY ifStatementBody .) ]
  ! ID              [ reduce using rule 26 (if_elseStatement -> IF LPAREN comparingValue RPAREN LCURLY ifStatementBody .) ]
  ! FUNCTION        [ reduce using rule 26 (if_elseStatement -> IF LPAREN comparingValue RPAREN LCURLY ifStatementBody .) ]
  ! FN              [ reduce using rule 26 (if_elseStatement -> IF LPAREN comparingValue RPAREN LCURLY ifStatementBody .) ]
  ! ECHO            [ reduce using rule 26 (if_elseStatement -> IF LPAREN comparingValue RPAREN LCURLY ifStatementBody .) ]
  ! PRINT           [ reduce using rule 26 (if_elseStatement -> IF LPAREN comparingValue RPAREN LCURLY ifStatementBody .) ]
  ! INTEGER         [ reduce using rule 26 (if_elseStatement -> IF LPAREN comparingValue RPAREN LCURLY ifStatementBody .) ]
  ! FLOAT           [ reduce using rule 26 (if_elseStatement -> IF LPAREN comparingValue RPAREN LCURLY ifStatementBody .) ]
  ! STRING          [ reduce using rule 26 (if_elseStatement -> IF LPAREN comparingValue RPAREN LCURLY ifStatementBody .) ]
  ! BOOL            [ reduce using rule 26 (if_elseStatement -> IF LPAREN comparingValue RPAREN LCURLY ifStatementBody .) ]
  ! NULL            [ reduce using rule 26 (if_elseStatement -> IF LPAREN comparingValue RPAREN LCURLY ifStatementBody .) ]
  ! RCURLY          [ reduce using rule 26 (if_elseStatement -> IF LPAREN comparingValue RPAREN LCURLY ifStatementBody .) ]

    cuerpo                         shift and go to state 143
    arithmeticExpression           shift and go to state 3
    if_elseStatement               shift and go to state 4
    forStatement                   shift and go to state 5
    switchStatement                shift and go to state 6
    queueDeclaration               shift and go to state 7
    queueEnqueue                   shift and go to state 8
    queueDequeue                   shift and go to state 9
    defineFunction                 shift and go to state 10
    anonymousFunction              shift and go to state 11
    arrowFunction                  shift and go to state 12
    echo                           shift and go to state 13
    fgets                          shift and go to state 14
    stackDeclaration               shift and go to state 15
    stackPush                      shift and go to state 16
    stackPop                       shift and go to state 17
    line                           shift and go to state 18
    print                          shift and go to state 19
    value                          shift and go to state 20
    variableAsignation             shift and go to state 28

state 125

    (27) ifStatementBody -> cuerpo .
    (28) ifStatementBody -> cuerpo . CONTINUE SEMICOLON

  ! shift/reduce conflict for CONTINUE resolved as shift
    RCURLY          reduce using rule 27 (ifStatementBody -> cuerpo .)
    IF              reduce using rule 27 (ifStatementBody -> cuerpo .)
    FOR             reduce using rule 27 (ifStatementBody -> cuerpo .)
    SWITCH          reduce using rule 27 (ifStatementBody -> cuerpo .)
    ID              reduce using rule 27 (ifStatementBody -> cuerpo .)
    FUNCTION        reduce using rule 27 (ifStatementBody -> cuerpo .)
    FN              reduce using rule 27 (ifStatementBody -> cuerpo .)
    ECHO            reduce using rule 27 (ifStatementBody -> cuerpo .)
    PRINT           reduce using rule 27 (ifStatementBody -> cuerpo .)
    INTEGER         reduce using rule 27 (ifStatementBody -> cuerpo .)
    FLOAT           reduce using rule 27 (ifStatementBody -> cuerpo .)
    STRING          reduce using rule 27 (ifStatementBody -> cuerpo .)
    BOOL            reduce using rule 27 (ifStatementBody -> cuerpo .)
    NULL            reduce using rule 27 (ifStatementBody -> cuerpo .)
    $end            reduce using rule 27 (ifStatementBody -> cuerpo .)
    SEMICOLON       reduce using rule 27 (ifStatementBody -> cuerpo .)
    BREAK           reduce using rule 27 (ifStatementBody -> cuerpo .)
    CONTINUE        shift and go to state 144

  ! CONTINUE        [ reduce using rule 27 (ifStatementBody -> cuerpo .) ]


state 126

    (30) forStatement -> FOR LPAREN forStatementCondition RPAREN LCURLY forStatementBody . RCURLY
    (35) forStatementBody -> forStatementBody . cuerpo
    (3) cuerpo -> . arithmeticExpression
    (4) cuerpo -> . if_elseStatement
    (5) cuerpo -> . forStatement
    (6) cuerpo -> . switchStatement
    (7) cuerpo -> . queueDeclaration
    (8) cuerpo -> . queueEnqueue
    (9) cuerpo -> . queueDequeue
    (10) cuerpo -> . defineFunction
    (11) cuerpo -> . anonymousFunction
    (12) cuerpo -> . arrowFunction
    (13) cuerpo -> . echo
    (14) cuerpo -> . fgets
    (15) cuerpo -> . stackDeclaration
    (16) cuerpo -> . stackPush
    (17) cuerpo -> . stackPop
    (18) cuerpo -> . line
    (19) cuerpo -> . print
    (57) arithmeticExpression -> . value arithmeticOperator value
    (25) if_elseStatement -> . IF LPAREN comparingValue RPAREN LCURLY ifStatementBody RCURLY ELSE ifStatementBody
    (26) if_elseStatement -> . IF LPAREN comparingValue RPAREN LCURLY ifStatementBody
    (30) forStatement -> . FOR LPAREN forStatementCondition RPAREN LCURLY forStatementBody RCURLY
    (20) switchStatement -> . SWITCH LPAREN value RPAREN LCURLY switchCases switchDefault RCURLY
    (39) queueDeclaration -> . ID EQUAL NEW QUEUE SEMICOLON
    (40) queueEnqueue -> . ID OBJOP PUSH LPAREN value RPAREN SEMICOLON
    (41) queueDequeue -> . ID OBJOP POP SEMICOLON
    (42) defineFunction -> . FUNCTION ID LPAREN arguments RPAREN LCURLY cuerpo RCURLY
    (43) defineFunction -> . FUNCTION ID LPAREN RPAREN LCURLY cuerpo RCURLY
    (46) anonymousFunction -> . FUNCTION LPAREN RPAREN LCURLY cuerpo RCURLY
    (47) anonymousFunction -> . FUNCTION LPAREN arguments RPAREN LCURLY cuerpo RCURLY
    (48) arrowFunction -> . FN LPAREN ID RPAREN FNARROW arrowBody SEMICOLON
    (51) echo -> . ECHO values SEMICOLON
    (56) fgets -> . ID EQUAL FGETS LPAREN STDIN RPAREN SEMICOLON
    (36) stackDeclaration -> . ID EQUAL NEW STACK SEMICOLON
    (37) stackPush -> . ID OBJOP PUSH LPAREN value RPAREN SEMICOLON
    (38) stackPop -> . ID OBJOP POP SEMICOLON
    (70) line -> . variableAsignation SEMICOLON
    (52) print -> . PRINT LPAREN values RPAREN SEMICOLON
    (53) print -> . PRINT value SEMICOLON
    (58) value -> . ID
    (59) value -> . INTEGER
    (60) value -> . FLOAT
    (61) value -> . STRING
    (62) value -> . BOOL
    (63) value -> . NULL
    (71) variableAsignation -> . ID EQUAL value
    (72) variableAsignation -> . ID EQUAL arithmeticExpression

    RCURLY          shift and go to state 145
    IF              shift and go to state 21
    FOR             shift and go to state 22
    SWITCH          shift and go to state 23
    ID              shift and go to state 24
    FUNCTION        shift and go to state 25
    FN              shift and go to state 26
    ECHO            shift and go to state 27
    PRINT           shift and go to state 29
    INTEGER         shift and go to state 30
    FLOAT           shift and go to state 31
    STRING          shift and go to state 32
    BOOL            shift and go to state 33
    NULL            shift and go to state 34

    cuerpo                         shift and go to state 146
    arithmeticExpression           shift and go to state 3
    if_elseStatement               shift and go to state 4
    forStatement                   shift and go to state 5
    switchStatement                shift and go to state 6
    queueDeclaration               shift and go to state 7
    queueEnqueue                   shift and go to state 8
    queueDequeue                   shift and go to state 9
    defineFunction                 shift and go to state 10
    anonymousFunction              shift and go to state 11
    arrowFunction                  shift and go to state 12
    echo                           shift and go to state 13
    fgets                          shift and go to state 14
    stackDeclaration               shift and go to state 15
    stackPush                      shift and go to state 16
    stackPop                       shift and go to state 17
    line                           shift and go to state 18
    print                          shift and go to state 19
    value                          shift and go to state 20
    variableAsignation             shift and go to state 28

state 127

    (34) forStatementBody -> cuerpo .

    RCURLY          reduce using rule 34 (forStatementBody -> cuerpo .)
    IF              reduce using rule 34 (forStatementBody -> cuerpo .)
    FOR             reduce using rule 34 (forStatementBody -> cuerpo .)
    SWITCH          reduce using rule 34 (forStatementBody -> cuerpo .)
    ID              reduce using rule 34 (forStatementBody -> cuerpo .)
    FUNCTION        reduce using rule 34 (forStatementBody -> cuerpo .)
    FN              reduce using rule 34 (forStatementBody -> cuerpo .)
    ECHO            reduce using rule 34 (forStatementBody -> cuerpo .)
    PRINT           reduce using rule 34 (forStatementBody -> cuerpo .)
    INTEGER         reduce using rule 34 (forStatementBody -> cuerpo .)
    FLOAT           reduce using rule 34 (forStatementBody -> cuerpo .)
    STRING          reduce using rule 34 (forStatementBody -> cuerpo .)
    BOOL            reduce using rule 34 (forStatementBody -> cuerpo .)
    NULL            reduce using rule 34 (forStatementBody -> cuerpo .)


state 128

    (32) forStatementCondition -> variableAsignation SEMICOLON SEMICOLON variableAsignation .

    RPAREN          reduce using rule 32 (forStatementCondition -> variableAsignation SEMICOLON SEMICOLON variableAsignation .)


state 129

    (33) forStatementCondition -> variableAsignation SEMICOLON comparingValue SEMICOLON . variableAsignation
    (71) variableAsignation -> . ID EQUAL value
    (72) variableAsignation -> . ID EQUAL arithmeticExpression

    ID              shift and go to state 63

    variableAsignation             shift and go to state 147

state 130

    (20) switchStatement -> SWITCH LPAREN value RPAREN LCURLY switchCases . switchDefault RCURLY
    (24) switchCases -> switchCases . switchCase
    (21) switchDefault -> . DEFAULT COLON cuerpo
    (22) switchCase -> . CASE value COLON cuerpo BREAK SEMICOLON

    DEFAULT         shift and go to state 150
    CASE            shift and go to state 132

    switchDefault                  shift and go to state 148
    switchCase                     shift and go to state 149

state 131

    (23) switchCases -> switchCase .

    DEFAULT         reduce using rule 23 (switchCases -> switchCase .)
    CASE            reduce using rule 23 (switchCases -> switchCase .)


state 132

    (22) switchCase -> CASE . value COLON cuerpo BREAK SEMICOLON
    (58) value -> . ID
    (59) value -> . INTEGER
    (60) value -> . FLOAT
    (61) value -> . STRING
    (62) value -> . BOOL
    (63) value -> . NULL

    ID              shift and go to state 53
    INTEGER         shift and go to state 30
    FLOAT           shift and go to state 31
    STRING          shift and go to state 32
    BOOL            shift and go to state 33
    NULL            shift and go to state 34

    value                          shift and go to state 151

state 133

    (56) fgets -> ID EQUAL FGETS LPAREN STDIN RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 152


state 134

    (40) queueEnqueue -> ID OBJOP PUSH LPAREN value RPAREN . SEMICOLON
    (37) stackPush -> ID OBJOP PUSH LPAREN value RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 153


state 135

    (42) defineFunction -> FUNCTION ID LPAREN arguments RPAREN LCURLY . cuerpo RCURLY
    (3) cuerpo -> . arithmeticExpression
    (4) cuerpo -> . if_elseStatement
    (5) cuerpo -> . forStatement
    (6) cuerpo -> . switchStatement
    (7) cuerpo -> . queueDeclaration
    (8) cuerpo -> . queueEnqueue
    (9) cuerpo -> . queueDequeue
    (10) cuerpo -> . defineFunction
    (11) cuerpo -> . anonymousFunction
    (12) cuerpo -> . arrowFunction
    (13) cuerpo -> . echo
    (14) cuerpo -> . fgets
    (15) cuerpo -> . stackDeclaration
    (16) cuerpo -> . stackPush
    (17) cuerpo -> . stackPop
    (18) cuerpo -> . line
    (19) cuerpo -> . print
    (57) arithmeticExpression -> . value arithmeticOperator value
    (25) if_elseStatement -> . IF LPAREN comparingValue RPAREN LCURLY ifStatementBody RCURLY ELSE ifStatementBody
    (26) if_elseStatement -> . IF LPAREN comparingValue RPAREN LCURLY ifStatementBody
    (30) forStatement -> . FOR LPAREN forStatementCondition RPAREN LCURLY forStatementBody RCURLY
    (20) switchStatement -> . SWITCH LPAREN value RPAREN LCURLY switchCases switchDefault RCURLY
    (39) queueDeclaration -> . ID EQUAL NEW QUEUE SEMICOLON
    (40) queueEnqueue -> . ID OBJOP PUSH LPAREN value RPAREN SEMICOLON
    (41) queueDequeue -> . ID OBJOP POP SEMICOLON
    (42) defineFunction -> . FUNCTION ID LPAREN arguments RPAREN LCURLY cuerpo RCURLY
    (43) defineFunction -> . FUNCTION ID LPAREN RPAREN LCURLY cuerpo RCURLY
    (46) anonymousFunction -> . FUNCTION LPAREN RPAREN LCURLY cuerpo RCURLY
    (47) anonymousFunction -> . FUNCTION LPAREN arguments RPAREN LCURLY cuerpo RCURLY
    (48) arrowFunction -> . FN LPAREN ID RPAREN FNARROW arrowBody SEMICOLON
    (51) echo -> . ECHO values SEMICOLON
    (56) fgets -> . ID EQUAL FGETS LPAREN STDIN RPAREN SEMICOLON
    (36) stackDeclaration -> . ID EQUAL NEW STACK SEMICOLON
    (37) stackPush -> . ID OBJOP PUSH LPAREN value RPAREN SEMICOLON
    (38) stackPop -> . ID OBJOP POP SEMICOLON
    (70) line -> . variableAsignation SEMICOLON
    (52) print -> . PRINT LPAREN values RPAREN SEMICOLON
    (53) print -> . PRINT value SEMICOLON
    (58) value -> . ID
    (59) value -> . INTEGER
    (60) value -> . FLOAT
    (61) value -> . STRING
    (62) value -> . BOOL
    (63) value -> . NULL
    (71) variableAsignation -> . ID EQUAL value
    (72) variableAsignation -> . ID EQUAL arithmeticExpression

    IF              shift and go to state 21
    FOR             shift and go to state 22
    SWITCH          shift and go to state 23
    ID              shift and go to state 24
    FUNCTION        shift and go to state 25
    FN              shift and go to state 26
    ECHO            shift and go to state 27
    PRINT           shift and go to state 29
    INTEGER         shift and go to state 30
    FLOAT           shift and go to state 31
    STRING          shift and go to state 32
    BOOL            shift and go to state 33
    NULL            shift and go to state 34

    cuerpo                         shift and go to state 154
    arithmeticExpression           shift and go to state 3
    if_elseStatement               shift and go to state 4
    forStatement                   shift and go to state 5
    switchStatement                shift and go to state 6
    queueDeclaration               shift and go to state 7
    queueEnqueue                   shift and go to state 8
    queueDequeue                   shift and go to state 9
    defineFunction                 shift and go to state 10
    anonymousFunction              shift and go to state 11
    arrowFunction                  shift and go to state 12
    echo                           shift and go to state 13
    fgets                          shift and go to state 14
    stackDeclaration               shift and go to state 15
    stackPush                      shift and go to state 16
    stackPop                       shift and go to state 17
    line                           shift and go to state 18
    print                          shift and go to state 19
    value                          shift and go to state 20
    variableAsignation             shift and go to state 28

state 136

    (43) defineFunction -> FUNCTION ID LPAREN RPAREN LCURLY cuerpo . RCURLY

    RCURLY          shift and go to state 155


state 137

    (46) anonymousFunction -> FUNCTION LPAREN RPAREN LCURLY cuerpo RCURLY .

    IF              reduce using rule 46 (anonymousFunction -> FUNCTION LPAREN RPAREN LCURLY cuerpo RCURLY .)
    FOR             reduce using rule 46 (anonymousFunction -> FUNCTION LPAREN RPAREN LCURLY cuerpo RCURLY .)
    SWITCH          reduce using rule 46 (anonymousFunction -> FUNCTION LPAREN RPAREN LCURLY cuerpo RCURLY .)
    ID              reduce using rule 46 (anonymousFunction -> FUNCTION LPAREN RPAREN LCURLY cuerpo RCURLY .)
    FUNCTION        reduce using rule 46 (anonymousFunction -> FUNCTION LPAREN RPAREN LCURLY cuerpo RCURLY .)
    FN              reduce using rule 46 (anonymousFunction -> FUNCTION LPAREN RPAREN LCURLY cuerpo RCURLY .)
    ECHO            reduce using rule 46 (anonymousFunction -> FUNCTION LPAREN RPAREN LCURLY cuerpo RCURLY .)
    PRINT           reduce using rule 46 (anonymousFunction -> FUNCTION LPAREN RPAREN LCURLY cuerpo RCURLY .)
    INTEGER         reduce using rule 46 (anonymousFunction -> FUNCTION LPAREN RPAREN LCURLY cuerpo RCURLY .)
    FLOAT           reduce using rule 46 (anonymousFunction -> FUNCTION LPAREN RPAREN LCURLY cuerpo RCURLY .)
    STRING          reduce using rule 46 (anonymousFunction -> FUNCTION LPAREN RPAREN LCURLY cuerpo RCURLY .)
    BOOL            reduce using rule 46 (anonymousFunction -> FUNCTION LPAREN RPAREN LCURLY cuerpo RCURLY .)
    NULL            reduce using rule 46 (anonymousFunction -> FUNCTION LPAREN RPAREN LCURLY cuerpo RCURLY .)
    $end            reduce using rule 46 (anonymousFunction -> FUNCTION LPAREN RPAREN LCURLY cuerpo RCURLY .)
    RCURLY          reduce using rule 46 (anonymousFunction -> FUNCTION LPAREN RPAREN LCURLY cuerpo RCURLY .)
    CONTINUE        reduce using rule 46 (anonymousFunction -> FUNCTION LPAREN RPAREN LCURLY cuerpo RCURLY .)
    SEMICOLON       reduce using rule 46 (anonymousFunction -> FUNCTION LPAREN RPAREN LCURLY cuerpo RCURLY .)
    BREAK           reduce using rule 46 (anonymousFunction -> FUNCTION LPAREN RPAREN LCURLY cuerpo RCURLY .)


state 138

    (47) anonymousFunction -> FUNCTION LPAREN arguments RPAREN LCURLY cuerpo . RCURLY

    RCURLY          shift and go to state 156


state 139

    (49) arrowBody -> FN . LPAREN ID RPAREN FNARROW arrowBody
    (48) arrowFunction -> FN . LPAREN ID RPAREN FNARROW arrowBody SEMICOLON

    LPAREN          shift and go to state 157


state 140

    (48) arrowFunction -> FN LPAREN ID RPAREN FNARROW arrowBody . SEMICOLON

    SEMICOLON       shift and go to state 158


state 141

    (50) arrowBody -> cuerpo .

    SEMICOLON       reduce using rule 50 (arrowBody -> cuerpo .)


state 142

    (25) if_elseStatement -> IF LPAREN comparingValue RPAREN LCURLY ifStatementBody RCURLY . ELSE ifStatementBody

    ELSE            shift and go to state 159


state 143

    (29) ifStatementBody -> ifStatementBody cuerpo .

    CONTINUE        reduce using rule 29 (ifStatementBody -> ifStatementBody cuerpo .)
    RCURLY          reduce using rule 29 (ifStatementBody -> ifStatementBody cuerpo .)
    IF              reduce using rule 29 (ifStatementBody -> ifStatementBody cuerpo .)
    FOR             reduce using rule 29 (ifStatementBody -> ifStatementBody cuerpo .)
    SWITCH          reduce using rule 29 (ifStatementBody -> ifStatementBody cuerpo .)
    ID              reduce using rule 29 (ifStatementBody -> ifStatementBody cuerpo .)
    FUNCTION        reduce using rule 29 (ifStatementBody -> ifStatementBody cuerpo .)
    FN              reduce using rule 29 (ifStatementBody -> ifStatementBody cuerpo .)
    ECHO            reduce using rule 29 (ifStatementBody -> ifStatementBody cuerpo .)
    PRINT           reduce using rule 29 (ifStatementBody -> ifStatementBody cuerpo .)
    INTEGER         reduce using rule 29 (ifStatementBody -> ifStatementBody cuerpo .)
    FLOAT           reduce using rule 29 (ifStatementBody -> ifStatementBody cuerpo .)
    STRING          reduce using rule 29 (ifStatementBody -> ifStatementBody cuerpo .)
    BOOL            reduce using rule 29 (ifStatementBody -> ifStatementBody cuerpo .)
    NULL            reduce using rule 29 (ifStatementBody -> ifStatementBody cuerpo .)
    $end            reduce using rule 29 (ifStatementBody -> ifStatementBody cuerpo .)
    SEMICOLON       reduce using rule 29 (ifStatementBody -> ifStatementBody cuerpo .)
    BREAK           reduce using rule 29 (ifStatementBody -> ifStatementBody cuerpo .)


state 144

    (28) ifStatementBody -> cuerpo CONTINUE . SEMICOLON

    SEMICOLON       shift and go to state 160


state 145

    (30) forStatement -> FOR LPAREN forStatementCondition RPAREN LCURLY forStatementBody RCURLY .

    IF              reduce using rule 30 (forStatement -> FOR LPAREN forStatementCondition RPAREN LCURLY forStatementBody RCURLY .)
    FOR             reduce using rule 30 (forStatement -> FOR LPAREN forStatementCondition RPAREN LCURLY forStatementBody RCURLY .)
    SWITCH          reduce using rule 30 (forStatement -> FOR LPAREN forStatementCondition RPAREN LCURLY forStatementBody RCURLY .)
    ID              reduce using rule 30 (forStatement -> FOR LPAREN forStatementCondition RPAREN LCURLY forStatementBody RCURLY .)
    FUNCTION        reduce using rule 30 (forStatement -> FOR LPAREN forStatementCondition RPAREN LCURLY forStatementBody RCURLY .)
    FN              reduce using rule 30 (forStatement -> FOR LPAREN forStatementCondition RPAREN LCURLY forStatementBody RCURLY .)
    ECHO            reduce using rule 30 (forStatement -> FOR LPAREN forStatementCondition RPAREN LCURLY forStatementBody RCURLY .)
    PRINT           reduce using rule 30 (forStatement -> FOR LPAREN forStatementCondition RPAREN LCURLY forStatementBody RCURLY .)
    INTEGER         reduce using rule 30 (forStatement -> FOR LPAREN forStatementCondition RPAREN LCURLY forStatementBody RCURLY .)
    FLOAT           reduce using rule 30 (forStatement -> FOR LPAREN forStatementCondition RPAREN LCURLY forStatementBody RCURLY .)
    STRING          reduce using rule 30 (forStatement -> FOR LPAREN forStatementCondition RPAREN LCURLY forStatementBody RCURLY .)
    BOOL            reduce using rule 30 (forStatement -> FOR LPAREN forStatementCondition RPAREN LCURLY forStatementBody RCURLY .)
    NULL            reduce using rule 30 (forStatement -> FOR LPAREN forStatementCondition RPAREN LCURLY forStatementBody RCURLY .)
    $end            reduce using rule 30 (forStatement -> FOR LPAREN forStatementCondition RPAREN LCURLY forStatementBody RCURLY .)
    RCURLY          reduce using rule 30 (forStatement -> FOR LPAREN forStatementCondition RPAREN LCURLY forStatementBody RCURLY .)
    CONTINUE        reduce using rule 30 (forStatement -> FOR LPAREN forStatementCondition RPAREN LCURLY forStatementBody RCURLY .)
    SEMICOLON       reduce using rule 30 (forStatement -> FOR LPAREN forStatementCondition RPAREN LCURLY forStatementBody RCURLY .)
    BREAK           reduce using rule 30 (forStatement -> FOR LPAREN forStatementCondition RPAREN LCURLY forStatementBody RCURLY .)


state 146

    (35) forStatementBody -> forStatementBody cuerpo .

    RCURLY          reduce using rule 35 (forStatementBody -> forStatementBody cuerpo .)
    IF              reduce using rule 35 (forStatementBody -> forStatementBody cuerpo .)
    FOR             reduce using rule 35 (forStatementBody -> forStatementBody cuerpo .)
    SWITCH          reduce using rule 35 (forStatementBody -> forStatementBody cuerpo .)
    ID              reduce using rule 35 (forStatementBody -> forStatementBody cuerpo .)
    FUNCTION        reduce using rule 35 (forStatementBody -> forStatementBody cuerpo .)
    FN              reduce using rule 35 (forStatementBody -> forStatementBody cuerpo .)
    ECHO            reduce using rule 35 (forStatementBody -> forStatementBody cuerpo .)
    PRINT           reduce using rule 35 (forStatementBody -> forStatementBody cuerpo .)
    INTEGER         reduce using rule 35 (forStatementBody -> forStatementBody cuerpo .)
    FLOAT           reduce using rule 35 (forStatementBody -> forStatementBody cuerpo .)
    STRING          reduce using rule 35 (forStatementBody -> forStatementBody cuerpo .)
    BOOL            reduce using rule 35 (forStatementBody -> forStatementBody cuerpo .)
    NULL            reduce using rule 35 (forStatementBody -> forStatementBody cuerpo .)


state 147

    (33) forStatementCondition -> variableAsignation SEMICOLON comparingValue SEMICOLON variableAsignation .

    RPAREN          reduce using rule 33 (forStatementCondition -> variableAsignation SEMICOLON comparingValue SEMICOLON variableAsignation .)


state 148

    (20) switchStatement -> SWITCH LPAREN value RPAREN LCURLY switchCases switchDefault . RCURLY

    RCURLY          shift and go to state 161


state 149

    (24) switchCases -> switchCases switchCase .

    DEFAULT         reduce using rule 24 (switchCases -> switchCases switchCase .)
    CASE            reduce using rule 24 (switchCases -> switchCases switchCase .)


state 150

    (21) switchDefault -> DEFAULT . COLON cuerpo

    COLON           shift and go to state 162


state 151

    (22) switchCase -> CASE value . COLON cuerpo BREAK SEMICOLON

    COLON           shift and go to state 163


state 152

    (56) fgets -> ID EQUAL FGETS LPAREN STDIN RPAREN SEMICOLON .

    IF              reduce using rule 56 (fgets -> ID EQUAL FGETS LPAREN STDIN RPAREN SEMICOLON .)
    FOR             reduce using rule 56 (fgets -> ID EQUAL FGETS LPAREN STDIN RPAREN SEMICOLON .)
    SWITCH          reduce using rule 56 (fgets -> ID EQUAL FGETS LPAREN STDIN RPAREN SEMICOLON .)
    ID              reduce using rule 56 (fgets -> ID EQUAL FGETS LPAREN STDIN RPAREN SEMICOLON .)
    FUNCTION        reduce using rule 56 (fgets -> ID EQUAL FGETS LPAREN STDIN RPAREN SEMICOLON .)
    FN              reduce using rule 56 (fgets -> ID EQUAL FGETS LPAREN STDIN RPAREN SEMICOLON .)
    ECHO            reduce using rule 56 (fgets -> ID EQUAL FGETS LPAREN STDIN RPAREN SEMICOLON .)
    PRINT           reduce using rule 56 (fgets -> ID EQUAL FGETS LPAREN STDIN RPAREN SEMICOLON .)
    INTEGER         reduce using rule 56 (fgets -> ID EQUAL FGETS LPAREN STDIN RPAREN SEMICOLON .)
    FLOAT           reduce using rule 56 (fgets -> ID EQUAL FGETS LPAREN STDIN RPAREN SEMICOLON .)
    STRING          reduce using rule 56 (fgets -> ID EQUAL FGETS LPAREN STDIN RPAREN SEMICOLON .)
    BOOL            reduce using rule 56 (fgets -> ID EQUAL FGETS LPAREN STDIN RPAREN SEMICOLON .)
    NULL            reduce using rule 56 (fgets -> ID EQUAL FGETS LPAREN STDIN RPAREN SEMICOLON .)
    $end            reduce using rule 56 (fgets -> ID EQUAL FGETS LPAREN STDIN RPAREN SEMICOLON .)
    RCURLY          reduce using rule 56 (fgets -> ID EQUAL FGETS LPAREN STDIN RPAREN SEMICOLON .)
    CONTINUE        reduce using rule 56 (fgets -> ID EQUAL FGETS LPAREN STDIN RPAREN SEMICOLON .)
    SEMICOLON       reduce using rule 56 (fgets -> ID EQUAL FGETS LPAREN STDIN RPAREN SEMICOLON .)
    BREAK           reduce using rule 56 (fgets -> ID EQUAL FGETS LPAREN STDIN RPAREN SEMICOLON .)


state 153

    (40) queueEnqueue -> ID OBJOP PUSH LPAREN value RPAREN SEMICOLON .
    (37) stackPush -> ID OBJOP PUSH LPAREN value RPAREN SEMICOLON .

  ! reduce/reduce conflict for IF resolved using rule 37 (stackPush -> ID OBJOP PUSH LPAREN value RPAREN SEMICOLON .)
  ! reduce/reduce conflict for FOR resolved using rule 37 (stackPush -> ID OBJOP PUSH LPAREN value RPAREN SEMICOLON .)
  ! reduce/reduce conflict for SWITCH resolved using rule 37 (stackPush -> ID OBJOP PUSH LPAREN value RPAREN SEMICOLON .)
  ! reduce/reduce conflict for ID resolved using rule 37 (stackPush -> ID OBJOP PUSH LPAREN value RPAREN SEMICOLON .)
  ! reduce/reduce conflict for FUNCTION resolved using rule 37 (stackPush -> ID OBJOP PUSH LPAREN value RPAREN SEMICOLON .)
  ! reduce/reduce conflict for FN resolved using rule 37 (stackPush -> ID OBJOP PUSH LPAREN value RPAREN SEMICOLON .)
  ! reduce/reduce conflict for ECHO resolved using rule 37 (stackPush -> ID OBJOP PUSH LPAREN value RPAREN SEMICOLON .)
  ! reduce/reduce conflict for PRINT resolved using rule 37 (stackPush -> ID OBJOP PUSH LPAREN value RPAREN SEMICOLON .)
  ! reduce/reduce conflict for INTEGER resolved using rule 37 (stackPush -> ID OBJOP PUSH LPAREN value RPAREN SEMICOLON .)
  ! reduce/reduce conflict for FLOAT resolved using rule 37 (stackPush -> ID OBJOP PUSH LPAREN value RPAREN SEMICOLON .)
  ! reduce/reduce conflict for STRING resolved using rule 37 (stackPush -> ID OBJOP PUSH LPAREN value RPAREN SEMICOLON .)
  ! reduce/reduce conflict for BOOL resolved using rule 37 (stackPush -> ID OBJOP PUSH LPAREN value RPAREN SEMICOLON .)
  ! reduce/reduce conflict for NULL resolved using rule 37 (stackPush -> ID OBJOP PUSH LPAREN value RPAREN SEMICOLON .)
  ! reduce/reduce conflict for $end resolved using rule 37 (stackPush -> ID OBJOP PUSH LPAREN value RPAREN SEMICOLON .)
  ! reduce/reduce conflict for RCURLY resolved using rule 37 (stackPush -> ID OBJOP PUSH LPAREN value RPAREN SEMICOLON .)
  ! reduce/reduce conflict for CONTINUE resolved using rule 37 (stackPush -> ID OBJOP PUSH LPAREN value RPAREN SEMICOLON .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 37 (stackPush -> ID OBJOP PUSH LPAREN value RPAREN SEMICOLON .)
  ! reduce/reduce conflict for BREAK resolved using rule 37 (stackPush -> ID OBJOP PUSH LPAREN value RPAREN SEMICOLON .)
    IF              reduce using rule 37 (stackPush -> ID OBJOP PUSH LPAREN value RPAREN SEMICOLON .)
    FOR             reduce using rule 37 (stackPush -> ID OBJOP PUSH LPAREN value RPAREN SEMICOLON .)
    SWITCH          reduce using rule 37 (stackPush -> ID OBJOP PUSH LPAREN value RPAREN SEMICOLON .)
    ID              reduce using rule 37 (stackPush -> ID OBJOP PUSH LPAREN value RPAREN SEMICOLON .)
    FUNCTION        reduce using rule 37 (stackPush -> ID OBJOP PUSH LPAREN value RPAREN SEMICOLON .)
    FN              reduce using rule 37 (stackPush -> ID OBJOP PUSH LPAREN value RPAREN SEMICOLON .)
    ECHO            reduce using rule 37 (stackPush -> ID OBJOP PUSH LPAREN value RPAREN SEMICOLON .)
    PRINT           reduce using rule 37 (stackPush -> ID OBJOP PUSH LPAREN value RPAREN SEMICOLON .)
    INTEGER         reduce using rule 37 (stackPush -> ID OBJOP PUSH LPAREN value RPAREN SEMICOLON .)
    FLOAT           reduce using rule 37 (stackPush -> ID OBJOP PUSH LPAREN value RPAREN SEMICOLON .)
    STRING          reduce using rule 37 (stackPush -> ID OBJOP PUSH LPAREN value RPAREN SEMICOLON .)
    BOOL            reduce using rule 37 (stackPush -> ID OBJOP PUSH LPAREN value RPAREN SEMICOLON .)
    NULL            reduce using rule 37 (stackPush -> ID OBJOP PUSH LPAREN value RPAREN SEMICOLON .)
    $end            reduce using rule 37 (stackPush -> ID OBJOP PUSH LPAREN value RPAREN SEMICOLON .)
    RCURLY          reduce using rule 37 (stackPush -> ID OBJOP PUSH LPAREN value RPAREN SEMICOLON .)
    CONTINUE        reduce using rule 37 (stackPush -> ID OBJOP PUSH LPAREN value RPAREN SEMICOLON .)
    SEMICOLON       reduce using rule 37 (stackPush -> ID OBJOP PUSH LPAREN value RPAREN SEMICOLON .)
    BREAK           reduce using rule 37 (stackPush -> ID OBJOP PUSH LPAREN value RPAREN SEMICOLON .)

  ! IF              [ reduce using rule 40 (queueEnqueue -> ID OBJOP PUSH LPAREN value RPAREN SEMICOLON .) ]
  ! FOR             [ reduce using rule 40 (queueEnqueue -> ID OBJOP PUSH LPAREN value RPAREN SEMICOLON .) ]
  ! SWITCH          [ reduce using rule 40 (queueEnqueue -> ID OBJOP PUSH LPAREN value RPAREN SEMICOLON .) ]
  ! ID              [ reduce using rule 40 (queueEnqueue -> ID OBJOP PUSH LPAREN value RPAREN SEMICOLON .) ]
  ! FUNCTION        [ reduce using rule 40 (queueEnqueue -> ID OBJOP PUSH LPAREN value RPAREN SEMICOLON .) ]
  ! FN              [ reduce using rule 40 (queueEnqueue -> ID OBJOP PUSH LPAREN value RPAREN SEMICOLON .) ]
  ! ECHO            [ reduce using rule 40 (queueEnqueue -> ID OBJOP PUSH LPAREN value RPAREN SEMICOLON .) ]
  ! PRINT           [ reduce using rule 40 (queueEnqueue -> ID OBJOP PUSH LPAREN value RPAREN SEMICOLON .) ]
  ! INTEGER         [ reduce using rule 40 (queueEnqueue -> ID OBJOP PUSH LPAREN value RPAREN SEMICOLON .) ]
  ! FLOAT           [ reduce using rule 40 (queueEnqueue -> ID OBJOP PUSH LPAREN value RPAREN SEMICOLON .) ]
  ! STRING          [ reduce using rule 40 (queueEnqueue -> ID OBJOP PUSH LPAREN value RPAREN SEMICOLON .) ]
  ! BOOL            [ reduce using rule 40 (queueEnqueue -> ID OBJOP PUSH LPAREN value RPAREN SEMICOLON .) ]
  ! NULL            [ reduce using rule 40 (queueEnqueue -> ID OBJOP PUSH LPAREN value RPAREN SEMICOLON .) ]
  ! $end            [ reduce using rule 40 (queueEnqueue -> ID OBJOP PUSH LPAREN value RPAREN SEMICOLON .) ]
  ! RCURLY          [ reduce using rule 40 (queueEnqueue -> ID OBJOP PUSH LPAREN value RPAREN SEMICOLON .) ]
  ! CONTINUE        [ reduce using rule 40 (queueEnqueue -> ID OBJOP PUSH LPAREN value RPAREN SEMICOLON .) ]
  ! SEMICOLON       [ reduce using rule 40 (queueEnqueue -> ID OBJOP PUSH LPAREN value RPAREN SEMICOLON .) ]
  ! BREAK           [ reduce using rule 40 (queueEnqueue -> ID OBJOP PUSH LPAREN value RPAREN SEMICOLON .) ]


state 154

    (42) defineFunction -> FUNCTION ID LPAREN arguments RPAREN LCURLY cuerpo . RCURLY

    RCURLY          shift and go to state 164


state 155

    (43) defineFunction -> FUNCTION ID LPAREN RPAREN LCURLY cuerpo RCURLY .

    IF              reduce using rule 43 (defineFunction -> FUNCTION ID LPAREN RPAREN LCURLY cuerpo RCURLY .)
    FOR             reduce using rule 43 (defineFunction -> FUNCTION ID LPAREN RPAREN LCURLY cuerpo RCURLY .)
    SWITCH          reduce using rule 43 (defineFunction -> FUNCTION ID LPAREN RPAREN LCURLY cuerpo RCURLY .)
    ID              reduce using rule 43 (defineFunction -> FUNCTION ID LPAREN RPAREN LCURLY cuerpo RCURLY .)
    FUNCTION        reduce using rule 43 (defineFunction -> FUNCTION ID LPAREN RPAREN LCURLY cuerpo RCURLY .)
    FN              reduce using rule 43 (defineFunction -> FUNCTION ID LPAREN RPAREN LCURLY cuerpo RCURLY .)
    ECHO            reduce using rule 43 (defineFunction -> FUNCTION ID LPAREN RPAREN LCURLY cuerpo RCURLY .)
    PRINT           reduce using rule 43 (defineFunction -> FUNCTION ID LPAREN RPAREN LCURLY cuerpo RCURLY .)
    INTEGER         reduce using rule 43 (defineFunction -> FUNCTION ID LPAREN RPAREN LCURLY cuerpo RCURLY .)
    FLOAT           reduce using rule 43 (defineFunction -> FUNCTION ID LPAREN RPAREN LCURLY cuerpo RCURLY .)
    STRING          reduce using rule 43 (defineFunction -> FUNCTION ID LPAREN RPAREN LCURLY cuerpo RCURLY .)
    BOOL            reduce using rule 43 (defineFunction -> FUNCTION ID LPAREN RPAREN LCURLY cuerpo RCURLY .)
    NULL            reduce using rule 43 (defineFunction -> FUNCTION ID LPAREN RPAREN LCURLY cuerpo RCURLY .)
    $end            reduce using rule 43 (defineFunction -> FUNCTION ID LPAREN RPAREN LCURLY cuerpo RCURLY .)
    RCURLY          reduce using rule 43 (defineFunction -> FUNCTION ID LPAREN RPAREN LCURLY cuerpo RCURLY .)
    CONTINUE        reduce using rule 43 (defineFunction -> FUNCTION ID LPAREN RPAREN LCURLY cuerpo RCURLY .)
    SEMICOLON       reduce using rule 43 (defineFunction -> FUNCTION ID LPAREN RPAREN LCURLY cuerpo RCURLY .)
    BREAK           reduce using rule 43 (defineFunction -> FUNCTION ID LPAREN RPAREN LCURLY cuerpo RCURLY .)


state 156

    (47) anonymousFunction -> FUNCTION LPAREN arguments RPAREN LCURLY cuerpo RCURLY .

    IF              reduce using rule 47 (anonymousFunction -> FUNCTION LPAREN arguments RPAREN LCURLY cuerpo RCURLY .)
    FOR             reduce using rule 47 (anonymousFunction -> FUNCTION LPAREN arguments RPAREN LCURLY cuerpo RCURLY .)
    SWITCH          reduce using rule 47 (anonymousFunction -> FUNCTION LPAREN arguments RPAREN LCURLY cuerpo RCURLY .)
    ID              reduce using rule 47 (anonymousFunction -> FUNCTION LPAREN arguments RPAREN LCURLY cuerpo RCURLY .)
    FUNCTION        reduce using rule 47 (anonymousFunction -> FUNCTION LPAREN arguments RPAREN LCURLY cuerpo RCURLY .)
    FN              reduce using rule 47 (anonymousFunction -> FUNCTION LPAREN arguments RPAREN LCURLY cuerpo RCURLY .)
    ECHO            reduce using rule 47 (anonymousFunction -> FUNCTION LPAREN arguments RPAREN LCURLY cuerpo RCURLY .)
    PRINT           reduce using rule 47 (anonymousFunction -> FUNCTION LPAREN arguments RPAREN LCURLY cuerpo RCURLY .)
    INTEGER         reduce using rule 47 (anonymousFunction -> FUNCTION LPAREN arguments RPAREN LCURLY cuerpo RCURLY .)
    FLOAT           reduce using rule 47 (anonymousFunction -> FUNCTION LPAREN arguments RPAREN LCURLY cuerpo RCURLY .)
    STRING          reduce using rule 47 (anonymousFunction -> FUNCTION LPAREN arguments RPAREN LCURLY cuerpo RCURLY .)
    BOOL            reduce using rule 47 (anonymousFunction -> FUNCTION LPAREN arguments RPAREN LCURLY cuerpo RCURLY .)
    NULL            reduce using rule 47 (anonymousFunction -> FUNCTION LPAREN arguments RPAREN LCURLY cuerpo RCURLY .)
    $end            reduce using rule 47 (anonymousFunction -> FUNCTION LPAREN arguments RPAREN LCURLY cuerpo RCURLY .)
    RCURLY          reduce using rule 47 (anonymousFunction -> FUNCTION LPAREN arguments RPAREN LCURLY cuerpo RCURLY .)
    CONTINUE        reduce using rule 47 (anonymousFunction -> FUNCTION LPAREN arguments RPAREN LCURLY cuerpo RCURLY .)
    SEMICOLON       reduce using rule 47 (anonymousFunction -> FUNCTION LPAREN arguments RPAREN LCURLY cuerpo RCURLY .)
    BREAK           reduce using rule 47 (anonymousFunction -> FUNCTION LPAREN arguments RPAREN LCURLY cuerpo RCURLY .)


state 157

    (49) arrowBody -> FN LPAREN . ID RPAREN FNARROW arrowBody
    (48) arrowFunction -> FN LPAREN . ID RPAREN FNARROW arrowBody SEMICOLON

    ID              shift and go to state 165


state 158

    (48) arrowFunction -> FN LPAREN ID RPAREN FNARROW arrowBody SEMICOLON .

    IF              reduce using rule 48 (arrowFunction -> FN LPAREN ID RPAREN FNARROW arrowBody SEMICOLON .)
    FOR             reduce using rule 48 (arrowFunction -> FN LPAREN ID RPAREN FNARROW arrowBody SEMICOLON .)
    SWITCH          reduce using rule 48 (arrowFunction -> FN LPAREN ID RPAREN FNARROW arrowBody SEMICOLON .)
    ID              reduce using rule 48 (arrowFunction -> FN LPAREN ID RPAREN FNARROW arrowBody SEMICOLON .)
    FUNCTION        reduce using rule 48 (arrowFunction -> FN LPAREN ID RPAREN FNARROW arrowBody SEMICOLON .)
    FN              reduce using rule 48 (arrowFunction -> FN LPAREN ID RPAREN FNARROW arrowBody SEMICOLON .)
    ECHO            reduce using rule 48 (arrowFunction -> FN LPAREN ID RPAREN FNARROW arrowBody SEMICOLON .)
    PRINT           reduce using rule 48 (arrowFunction -> FN LPAREN ID RPAREN FNARROW arrowBody SEMICOLON .)
    INTEGER         reduce using rule 48 (arrowFunction -> FN LPAREN ID RPAREN FNARROW arrowBody SEMICOLON .)
    FLOAT           reduce using rule 48 (arrowFunction -> FN LPAREN ID RPAREN FNARROW arrowBody SEMICOLON .)
    STRING          reduce using rule 48 (arrowFunction -> FN LPAREN ID RPAREN FNARROW arrowBody SEMICOLON .)
    BOOL            reduce using rule 48 (arrowFunction -> FN LPAREN ID RPAREN FNARROW arrowBody SEMICOLON .)
    NULL            reduce using rule 48 (arrowFunction -> FN LPAREN ID RPAREN FNARROW arrowBody SEMICOLON .)
    $end            reduce using rule 48 (arrowFunction -> FN LPAREN ID RPAREN FNARROW arrowBody SEMICOLON .)
    RCURLY          reduce using rule 48 (arrowFunction -> FN LPAREN ID RPAREN FNARROW arrowBody SEMICOLON .)
    CONTINUE        reduce using rule 48 (arrowFunction -> FN LPAREN ID RPAREN FNARROW arrowBody SEMICOLON .)
    SEMICOLON       reduce using rule 48 (arrowFunction -> FN LPAREN ID RPAREN FNARROW arrowBody SEMICOLON .)
    BREAK           reduce using rule 48 (arrowFunction -> FN LPAREN ID RPAREN FNARROW arrowBody SEMICOLON .)


state 159

    (25) if_elseStatement -> IF LPAREN comparingValue RPAREN LCURLY ifStatementBody RCURLY ELSE . ifStatementBody
    (27) ifStatementBody -> . cuerpo
    (28) ifStatementBody -> . cuerpo CONTINUE SEMICOLON
    (29) ifStatementBody -> . ifStatementBody cuerpo
    (3) cuerpo -> . arithmeticExpression
    (4) cuerpo -> . if_elseStatement
    (5) cuerpo -> . forStatement
    (6) cuerpo -> . switchStatement
    (7) cuerpo -> . queueDeclaration
    (8) cuerpo -> . queueEnqueue
    (9) cuerpo -> . queueDequeue
    (10) cuerpo -> . defineFunction
    (11) cuerpo -> . anonymousFunction
    (12) cuerpo -> . arrowFunction
    (13) cuerpo -> . echo
    (14) cuerpo -> . fgets
    (15) cuerpo -> . stackDeclaration
    (16) cuerpo -> . stackPush
    (17) cuerpo -> . stackPop
    (18) cuerpo -> . line
    (19) cuerpo -> . print
    (57) arithmeticExpression -> . value arithmeticOperator value
    (25) if_elseStatement -> . IF LPAREN comparingValue RPAREN LCURLY ifStatementBody RCURLY ELSE ifStatementBody
    (26) if_elseStatement -> . IF LPAREN comparingValue RPAREN LCURLY ifStatementBody
    (30) forStatement -> . FOR LPAREN forStatementCondition RPAREN LCURLY forStatementBody RCURLY
    (20) switchStatement -> . SWITCH LPAREN value RPAREN LCURLY switchCases switchDefault RCURLY
    (39) queueDeclaration -> . ID EQUAL NEW QUEUE SEMICOLON
    (40) queueEnqueue -> . ID OBJOP PUSH LPAREN value RPAREN SEMICOLON
    (41) queueDequeue -> . ID OBJOP POP SEMICOLON
    (42) defineFunction -> . FUNCTION ID LPAREN arguments RPAREN LCURLY cuerpo RCURLY
    (43) defineFunction -> . FUNCTION ID LPAREN RPAREN LCURLY cuerpo RCURLY
    (46) anonymousFunction -> . FUNCTION LPAREN RPAREN LCURLY cuerpo RCURLY
    (47) anonymousFunction -> . FUNCTION LPAREN arguments RPAREN LCURLY cuerpo RCURLY
    (48) arrowFunction -> . FN LPAREN ID RPAREN FNARROW arrowBody SEMICOLON
    (51) echo -> . ECHO values SEMICOLON
    (56) fgets -> . ID EQUAL FGETS LPAREN STDIN RPAREN SEMICOLON
    (36) stackDeclaration -> . ID EQUAL NEW STACK SEMICOLON
    (37) stackPush -> . ID OBJOP PUSH LPAREN value RPAREN SEMICOLON
    (38) stackPop -> . ID OBJOP POP SEMICOLON
    (70) line -> . variableAsignation SEMICOLON
    (52) print -> . PRINT LPAREN values RPAREN SEMICOLON
    (53) print -> . PRINT value SEMICOLON
    (58) value -> . ID
    (59) value -> . INTEGER
    (60) value -> . FLOAT
    (61) value -> . STRING
    (62) value -> . BOOL
    (63) value -> . NULL
    (71) variableAsignation -> . ID EQUAL value
    (72) variableAsignation -> . ID EQUAL arithmeticExpression

    IF              shift and go to state 21
    FOR             shift and go to state 22
    SWITCH          shift and go to state 23
    ID              shift and go to state 24
    FUNCTION        shift and go to state 25
    FN              shift and go to state 26
    ECHO            shift and go to state 27
    PRINT           shift and go to state 29
    INTEGER         shift and go to state 30
    FLOAT           shift and go to state 31
    STRING          shift and go to state 32
    BOOL            shift and go to state 33
    NULL            shift and go to state 34

    ifStatementBody                shift and go to state 166
    cuerpo                         shift and go to state 125
    arithmeticExpression           shift and go to state 3
    if_elseStatement               shift and go to state 4
    forStatement                   shift and go to state 5
    switchStatement                shift and go to state 6
    queueDeclaration               shift and go to state 7
    queueEnqueue                   shift and go to state 8
    queueDequeue                   shift and go to state 9
    defineFunction                 shift and go to state 10
    anonymousFunction              shift and go to state 11
    arrowFunction                  shift and go to state 12
    echo                           shift and go to state 13
    fgets                          shift and go to state 14
    stackDeclaration               shift and go to state 15
    stackPush                      shift and go to state 16
    stackPop                       shift and go to state 17
    line                           shift and go to state 18
    print                          shift and go to state 19
    value                          shift and go to state 20
    variableAsignation             shift and go to state 28

state 160

    (28) ifStatementBody -> cuerpo CONTINUE SEMICOLON .

    CONTINUE        reduce using rule 28 (ifStatementBody -> cuerpo CONTINUE SEMICOLON .)
    RCURLY          reduce using rule 28 (ifStatementBody -> cuerpo CONTINUE SEMICOLON .)
    IF              reduce using rule 28 (ifStatementBody -> cuerpo CONTINUE SEMICOLON .)
    FOR             reduce using rule 28 (ifStatementBody -> cuerpo CONTINUE SEMICOLON .)
    SWITCH          reduce using rule 28 (ifStatementBody -> cuerpo CONTINUE SEMICOLON .)
    ID              reduce using rule 28 (ifStatementBody -> cuerpo CONTINUE SEMICOLON .)
    FUNCTION        reduce using rule 28 (ifStatementBody -> cuerpo CONTINUE SEMICOLON .)
    FN              reduce using rule 28 (ifStatementBody -> cuerpo CONTINUE SEMICOLON .)
    ECHO            reduce using rule 28 (ifStatementBody -> cuerpo CONTINUE SEMICOLON .)
    PRINT           reduce using rule 28 (ifStatementBody -> cuerpo CONTINUE SEMICOLON .)
    INTEGER         reduce using rule 28 (ifStatementBody -> cuerpo CONTINUE SEMICOLON .)
    FLOAT           reduce using rule 28 (ifStatementBody -> cuerpo CONTINUE SEMICOLON .)
    STRING          reduce using rule 28 (ifStatementBody -> cuerpo CONTINUE SEMICOLON .)
    BOOL            reduce using rule 28 (ifStatementBody -> cuerpo CONTINUE SEMICOLON .)
    NULL            reduce using rule 28 (ifStatementBody -> cuerpo CONTINUE SEMICOLON .)
    $end            reduce using rule 28 (ifStatementBody -> cuerpo CONTINUE SEMICOLON .)
    SEMICOLON       reduce using rule 28 (ifStatementBody -> cuerpo CONTINUE SEMICOLON .)
    BREAK           reduce using rule 28 (ifStatementBody -> cuerpo CONTINUE SEMICOLON .)


state 161

    (20) switchStatement -> SWITCH LPAREN value RPAREN LCURLY switchCases switchDefault RCURLY .

    IF              reduce using rule 20 (switchStatement -> SWITCH LPAREN value RPAREN LCURLY switchCases switchDefault RCURLY .)
    FOR             reduce using rule 20 (switchStatement -> SWITCH LPAREN value RPAREN LCURLY switchCases switchDefault RCURLY .)
    SWITCH          reduce using rule 20 (switchStatement -> SWITCH LPAREN value RPAREN LCURLY switchCases switchDefault RCURLY .)
    ID              reduce using rule 20 (switchStatement -> SWITCH LPAREN value RPAREN LCURLY switchCases switchDefault RCURLY .)
    FUNCTION        reduce using rule 20 (switchStatement -> SWITCH LPAREN value RPAREN LCURLY switchCases switchDefault RCURLY .)
    FN              reduce using rule 20 (switchStatement -> SWITCH LPAREN value RPAREN LCURLY switchCases switchDefault RCURLY .)
    ECHO            reduce using rule 20 (switchStatement -> SWITCH LPAREN value RPAREN LCURLY switchCases switchDefault RCURLY .)
    PRINT           reduce using rule 20 (switchStatement -> SWITCH LPAREN value RPAREN LCURLY switchCases switchDefault RCURLY .)
    INTEGER         reduce using rule 20 (switchStatement -> SWITCH LPAREN value RPAREN LCURLY switchCases switchDefault RCURLY .)
    FLOAT           reduce using rule 20 (switchStatement -> SWITCH LPAREN value RPAREN LCURLY switchCases switchDefault RCURLY .)
    STRING          reduce using rule 20 (switchStatement -> SWITCH LPAREN value RPAREN LCURLY switchCases switchDefault RCURLY .)
    BOOL            reduce using rule 20 (switchStatement -> SWITCH LPAREN value RPAREN LCURLY switchCases switchDefault RCURLY .)
    NULL            reduce using rule 20 (switchStatement -> SWITCH LPAREN value RPAREN LCURLY switchCases switchDefault RCURLY .)
    $end            reduce using rule 20 (switchStatement -> SWITCH LPAREN value RPAREN LCURLY switchCases switchDefault RCURLY .)
    RCURLY          reduce using rule 20 (switchStatement -> SWITCH LPAREN value RPAREN LCURLY switchCases switchDefault RCURLY .)
    CONTINUE        reduce using rule 20 (switchStatement -> SWITCH LPAREN value RPAREN LCURLY switchCases switchDefault RCURLY .)
    SEMICOLON       reduce using rule 20 (switchStatement -> SWITCH LPAREN value RPAREN LCURLY switchCases switchDefault RCURLY .)
    BREAK           reduce using rule 20 (switchStatement -> SWITCH LPAREN value RPAREN LCURLY switchCases switchDefault RCURLY .)


state 162

    (21) switchDefault -> DEFAULT COLON . cuerpo
    (3) cuerpo -> . arithmeticExpression
    (4) cuerpo -> . if_elseStatement
    (5) cuerpo -> . forStatement
    (6) cuerpo -> . switchStatement
    (7) cuerpo -> . queueDeclaration
    (8) cuerpo -> . queueEnqueue
    (9) cuerpo -> . queueDequeue
    (10) cuerpo -> . defineFunction
    (11) cuerpo -> . anonymousFunction
    (12) cuerpo -> . arrowFunction
    (13) cuerpo -> . echo
    (14) cuerpo -> . fgets
    (15) cuerpo -> . stackDeclaration
    (16) cuerpo -> . stackPush
    (17) cuerpo -> . stackPop
    (18) cuerpo -> . line
    (19) cuerpo -> . print
    (57) arithmeticExpression -> . value arithmeticOperator value
    (25) if_elseStatement -> . IF LPAREN comparingValue RPAREN LCURLY ifStatementBody RCURLY ELSE ifStatementBody
    (26) if_elseStatement -> . IF LPAREN comparingValue RPAREN LCURLY ifStatementBody
    (30) forStatement -> . FOR LPAREN forStatementCondition RPAREN LCURLY forStatementBody RCURLY
    (20) switchStatement -> . SWITCH LPAREN value RPAREN LCURLY switchCases switchDefault RCURLY
    (39) queueDeclaration -> . ID EQUAL NEW QUEUE SEMICOLON
    (40) queueEnqueue -> . ID OBJOP PUSH LPAREN value RPAREN SEMICOLON
    (41) queueDequeue -> . ID OBJOP POP SEMICOLON
    (42) defineFunction -> . FUNCTION ID LPAREN arguments RPAREN LCURLY cuerpo RCURLY
    (43) defineFunction -> . FUNCTION ID LPAREN RPAREN LCURLY cuerpo RCURLY
    (46) anonymousFunction -> . FUNCTION LPAREN RPAREN LCURLY cuerpo RCURLY
    (47) anonymousFunction -> . FUNCTION LPAREN arguments RPAREN LCURLY cuerpo RCURLY
    (48) arrowFunction -> . FN LPAREN ID RPAREN FNARROW arrowBody SEMICOLON
    (51) echo -> . ECHO values SEMICOLON
    (56) fgets -> . ID EQUAL FGETS LPAREN STDIN RPAREN SEMICOLON
    (36) stackDeclaration -> . ID EQUAL NEW STACK SEMICOLON
    (37) stackPush -> . ID OBJOP PUSH LPAREN value RPAREN SEMICOLON
    (38) stackPop -> . ID OBJOP POP SEMICOLON
    (70) line -> . variableAsignation SEMICOLON
    (52) print -> . PRINT LPAREN values RPAREN SEMICOLON
    (53) print -> . PRINT value SEMICOLON
    (58) value -> . ID
    (59) value -> . INTEGER
    (60) value -> . FLOAT
    (61) value -> . STRING
    (62) value -> . BOOL
    (63) value -> . NULL
    (71) variableAsignation -> . ID EQUAL value
    (72) variableAsignation -> . ID EQUAL arithmeticExpression

    IF              shift and go to state 21
    FOR             shift and go to state 22
    SWITCH          shift and go to state 23
    ID              shift and go to state 24
    FUNCTION        shift and go to state 25
    FN              shift and go to state 26
    ECHO            shift and go to state 27
    PRINT           shift and go to state 29
    INTEGER         shift and go to state 30
    FLOAT           shift and go to state 31
    STRING          shift and go to state 32
    BOOL            shift and go to state 33
    NULL            shift and go to state 34

    cuerpo                         shift and go to state 167
    arithmeticExpression           shift and go to state 3
    if_elseStatement               shift and go to state 4
    forStatement                   shift and go to state 5
    switchStatement                shift and go to state 6
    queueDeclaration               shift and go to state 7
    queueEnqueue                   shift and go to state 8
    queueDequeue                   shift and go to state 9
    defineFunction                 shift and go to state 10
    anonymousFunction              shift and go to state 11
    arrowFunction                  shift and go to state 12
    echo                           shift and go to state 13
    fgets                          shift and go to state 14
    stackDeclaration               shift and go to state 15
    stackPush                      shift and go to state 16
    stackPop                       shift and go to state 17
    line                           shift and go to state 18
    print                          shift and go to state 19
    value                          shift and go to state 20
    variableAsignation             shift and go to state 28

state 163

    (22) switchCase -> CASE value COLON . cuerpo BREAK SEMICOLON
    (3) cuerpo -> . arithmeticExpression
    (4) cuerpo -> . if_elseStatement
    (5) cuerpo -> . forStatement
    (6) cuerpo -> . switchStatement
    (7) cuerpo -> . queueDeclaration
    (8) cuerpo -> . queueEnqueue
    (9) cuerpo -> . queueDequeue
    (10) cuerpo -> . defineFunction
    (11) cuerpo -> . anonymousFunction
    (12) cuerpo -> . arrowFunction
    (13) cuerpo -> . echo
    (14) cuerpo -> . fgets
    (15) cuerpo -> . stackDeclaration
    (16) cuerpo -> . stackPush
    (17) cuerpo -> . stackPop
    (18) cuerpo -> . line
    (19) cuerpo -> . print
    (57) arithmeticExpression -> . value arithmeticOperator value
    (25) if_elseStatement -> . IF LPAREN comparingValue RPAREN LCURLY ifStatementBody RCURLY ELSE ifStatementBody
    (26) if_elseStatement -> . IF LPAREN comparingValue RPAREN LCURLY ifStatementBody
    (30) forStatement -> . FOR LPAREN forStatementCondition RPAREN LCURLY forStatementBody RCURLY
    (20) switchStatement -> . SWITCH LPAREN value RPAREN LCURLY switchCases switchDefault RCURLY
    (39) queueDeclaration -> . ID EQUAL NEW QUEUE SEMICOLON
    (40) queueEnqueue -> . ID OBJOP PUSH LPAREN value RPAREN SEMICOLON
    (41) queueDequeue -> . ID OBJOP POP SEMICOLON
    (42) defineFunction -> . FUNCTION ID LPAREN arguments RPAREN LCURLY cuerpo RCURLY
    (43) defineFunction -> . FUNCTION ID LPAREN RPAREN LCURLY cuerpo RCURLY
    (46) anonymousFunction -> . FUNCTION LPAREN RPAREN LCURLY cuerpo RCURLY
    (47) anonymousFunction -> . FUNCTION LPAREN arguments RPAREN LCURLY cuerpo RCURLY
    (48) arrowFunction -> . FN LPAREN ID RPAREN FNARROW arrowBody SEMICOLON
    (51) echo -> . ECHO values SEMICOLON
    (56) fgets -> . ID EQUAL FGETS LPAREN STDIN RPAREN SEMICOLON
    (36) stackDeclaration -> . ID EQUAL NEW STACK SEMICOLON
    (37) stackPush -> . ID OBJOP PUSH LPAREN value RPAREN SEMICOLON
    (38) stackPop -> . ID OBJOP POP SEMICOLON
    (70) line -> . variableAsignation SEMICOLON
    (52) print -> . PRINT LPAREN values RPAREN SEMICOLON
    (53) print -> . PRINT value SEMICOLON
    (58) value -> . ID
    (59) value -> . INTEGER
    (60) value -> . FLOAT
    (61) value -> . STRING
    (62) value -> . BOOL
    (63) value -> . NULL
    (71) variableAsignation -> . ID EQUAL value
    (72) variableAsignation -> . ID EQUAL arithmeticExpression

    IF              shift and go to state 21
    FOR             shift and go to state 22
    SWITCH          shift and go to state 23
    ID              shift and go to state 24
    FUNCTION        shift and go to state 25
    FN              shift and go to state 26
    ECHO            shift and go to state 27
    PRINT           shift and go to state 29
    INTEGER         shift and go to state 30
    FLOAT           shift and go to state 31
    STRING          shift and go to state 32
    BOOL            shift and go to state 33
    NULL            shift and go to state 34

    value                          shift and go to state 20
    cuerpo                         shift and go to state 168
    arithmeticExpression           shift and go to state 3
    if_elseStatement               shift and go to state 4
    forStatement                   shift and go to state 5
    switchStatement                shift and go to state 6
    queueDeclaration               shift and go to state 7
    queueEnqueue                   shift and go to state 8
    queueDequeue                   shift and go to state 9
    defineFunction                 shift and go to state 10
    anonymousFunction              shift and go to state 11
    arrowFunction                  shift and go to state 12
    echo                           shift and go to state 13
    fgets                          shift and go to state 14
    stackDeclaration               shift and go to state 15
    stackPush                      shift and go to state 16
    stackPop                       shift and go to state 17
    line                           shift and go to state 18
    print                          shift and go to state 19
    variableAsignation             shift and go to state 28

state 164

    (42) defineFunction -> FUNCTION ID LPAREN arguments RPAREN LCURLY cuerpo RCURLY .

    IF              reduce using rule 42 (defineFunction -> FUNCTION ID LPAREN arguments RPAREN LCURLY cuerpo RCURLY .)
    FOR             reduce using rule 42 (defineFunction -> FUNCTION ID LPAREN arguments RPAREN LCURLY cuerpo RCURLY .)
    SWITCH          reduce using rule 42 (defineFunction -> FUNCTION ID LPAREN arguments RPAREN LCURLY cuerpo RCURLY .)
    ID              reduce using rule 42 (defineFunction -> FUNCTION ID LPAREN arguments RPAREN LCURLY cuerpo RCURLY .)
    FUNCTION        reduce using rule 42 (defineFunction -> FUNCTION ID LPAREN arguments RPAREN LCURLY cuerpo RCURLY .)
    FN              reduce using rule 42 (defineFunction -> FUNCTION ID LPAREN arguments RPAREN LCURLY cuerpo RCURLY .)
    ECHO            reduce using rule 42 (defineFunction -> FUNCTION ID LPAREN arguments RPAREN LCURLY cuerpo RCURLY .)
    PRINT           reduce using rule 42 (defineFunction -> FUNCTION ID LPAREN arguments RPAREN LCURLY cuerpo RCURLY .)
    INTEGER         reduce using rule 42 (defineFunction -> FUNCTION ID LPAREN arguments RPAREN LCURLY cuerpo RCURLY .)
    FLOAT           reduce using rule 42 (defineFunction -> FUNCTION ID LPAREN arguments RPAREN LCURLY cuerpo RCURLY .)
    STRING          reduce using rule 42 (defineFunction -> FUNCTION ID LPAREN arguments RPAREN LCURLY cuerpo RCURLY .)
    BOOL            reduce using rule 42 (defineFunction -> FUNCTION ID LPAREN arguments RPAREN LCURLY cuerpo RCURLY .)
    NULL            reduce using rule 42 (defineFunction -> FUNCTION ID LPAREN arguments RPAREN LCURLY cuerpo RCURLY .)
    $end            reduce using rule 42 (defineFunction -> FUNCTION ID LPAREN arguments RPAREN LCURLY cuerpo RCURLY .)
    RCURLY          reduce using rule 42 (defineFunction -> FUNCTION ID LPAREN arguments RPAREN LCURLY cuerpo RCURLY .)
    CONTINUE        reduce using rule 42 (defineFunction -> FUNCTION ID LPAREN arguments RPAREN LCURLY cuerpo RCURLY .)
    SEMICOLON       reduce using rule 42 (defineFunction -> FUNCTION ID LPAREN arguments RPAREN LCURLY cuerpo RCURLY .)
    BREAK           reduce using rule 42 (defineFunction -> FUNCTION ID LPAREN arguments RPAREN LCURLY cuerpo RCURLY .)


state 165

    (49) arrowBody -> FN LPAREN ID . RPAREN FNARROW arrowBody
    (48) arrowFunction -> FN LPAREN ID . RPAREN FNARROW arrowBody SEMICOLON

    RPAREN          shift and go to state 169


state 166

    (25) if_elseStatement -> IF LPAREN comparingValue RPAREN LCURLY ifStatementBody RCURLY ELSE ifStatementBody .
    (29) ifStatementBody -> ifStatementBody . cuerpo
    (3) cuerpo -> . arithmeticExpression
    (4) cuerpo -> . if_elseStatement
    (5) cuerpo -> . forStatement
    (6) cuerpo -> . switchStatement
    (7) cuerpo -> . queueDeclaration
    (8) cuerpo -> . queueEnqueue
    (9) cuerpo -> . queueDequeue
    (10) cuerpo -> . defineFunction
    (11) cuerpo -> . anonymousFunction
    (12) cuerpo -> . arrowFunction
    (13) cuerpo -> . echo
    (14) cuerpo -> . fgets
    (15) cuerpo -> . stackDeclaration
    (16) cuerpo -> . stackPush
    (17) cuerpo -> . stackPop
    (18) cuerpo -> . line
    (19) cuerpo -> . print
    (57) arithmeticExpression -> . value arithmeticOperator value
    (25) if_elseStatement -> . IF LPAREN comparingValue RPAREN LCURLY ifStatementBody RCURLY ELSE ifStatementBody
    (26) if_elseStatement -> . IF LPAREN comparingValue RPAREN LCURLY ifStatementBody
    (30) forStatement -> . FOR LPAREN forStatementCondition RPAREN LCURLY forStatementBody RCURLY
    (20) switchStatement -> . SWITCH LPAREN value RPAREN LCURLY switchCases switchDefault RCURLY
    (39) queueDeclaration -> . ID EQUAL NEW QUEUE SEMICOLON
    (40) queueEnqueue -> . ID OBJOP PUSH LPAREN value RPAREN SEMICOLON
    (41) queueDequeue -> . ID OBJOP POP SEMICOLON
    (42) defineFunction -> . FUNCTION ID LPAREN arguments RPAREN LCURLY cuerpo RCURLY
    (43) defineFunction -> . FUNCTION ID LPAREN RPAREN LCURLY cuerpo RCURLY
    (46) anonymousFunction -> . FUNCTION LPAREN RPAREN LCURLY cuerpo RCURLY
    (47) anonymousFunction -> . FUNCTION LPAREN arguments RPAREN LCURLY cuerpo RCURLY
    (48) arrowFunction -> . FN LPAREN ID RPAREN FNARROW arrowBody SEMICOLON
    (51) echo -> . ECHO values SEMICOLON
    (56) fgets -> . ID EQUAL FGETS LPAREN STDIN RPAREN SEMICOLON
    (36) stackDeclaration -> . ID EQUAL NEW STACK SEMICOLON
    (37) stackPush -> . ID OBJOP PUSH LPAREN value RPAREN SEMICOLON
    (38) stackPop -> . ID OBJOP POP SEMICOLON
    (70) line -> . variableAsignation SEMICOLON
    (52) print -> . PRINT LPAREN values RPAREN SEMICOLON
    (53) print -> . PRINT value SEMICOLON
    (58) value -> . ID
    (59) value -> . INTEGER
    (60) value -> . FLOAT
    (61) value -> . STRING
    (62) value -> . BOOL
    (63) value -> . NULL
    (71) variableAsignation -> . ID EQUAL value
    (72) variableAsignation -> . ID EQUAL arithmeticExpression

  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for SWITCH resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for FUNCTION resolved as shift
  ! shift/reduce conflict for FN resolved as shift
  ! shift/reduce conflict for ECHO resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for BOOL resolved as shift
  ! shift/reduce conflict for NULL resolved as shift
    $end            reduce using rule 25 (if_elseStatement -> IF LPAREN comparingValue RPAREN LCURLY ifStatementBody RCURLY ELSE ifStatementBody .)
    RCURLY          reduce using rule 25 (if_elseStatement -> IF LPAREN comparingValue RPAREN LCURLY ifStatementBody RCURLY ELSE ifStatementBody .)
    CONTINUE        reduce using rule 25 (if_elseStatement -> IF LPAREN comparingValue RPAREN LCURLY ifStatementBody RCURLY ELSE ifStatementBody .)
    SEMICOLON       reduce using rule 25 (if_elseStatement -> IF LPAREN comparingValue RPAREN LCURLY ifStatementBody RCURLY ELSE ifStatementBody .)
    BREAK           reduce using rule 25 (if_elseStatement -> IF LPAREN comparingValue RPAREN LCURLY ifStatementBody RCURLY ELSE ifStatementBody .)
    IF              shift and go to state 21
    FOR             shift and go to state 22
    SWITCH          shift and go to state 23
    ID              shift and go to state 24
    FUNCTION        shift and go to state 25
    FN              shift and go to state 26
    ECHO            shift and go to state 27
    PRINT           shift and go to state 29
    INTEGER         shift and go to state 30
    FLOAT           shift and go to state 31
    STRING          shift and go to state 32
    BOOL            shift and go to state 33
    NULL            shift and go to state 34

  ! IF              [ reduce using rule 25 (if_elseStatement -> IF LPAREN comparingValue RPAREN LCURLY ifStatementBody RCURLY ELSE ifStatementBody .) ]
  ! FOR             [ reduce using rule 25 (if_elseStatement -> IF LPAREN comparingValue RPAREN LCURLY ifStatementBody RCURLY ELSE ifStatementBody .) ]
  ! SWITCH          [ reduce using rule 25 (if_elseStatement -> IF LPAREN comparingValue RPAREN LCURLY ifStatementBody RCURLY ELSE ifStatementBody .) ]
  ! ID              [ reduce using rule 25 (if_elseStatement -> IF LPAREN comparingValue RPAREN LCURLY ifStatementBody RCURLY ELSE ifStatementBody .) ]
  ! FUNCTION        [ reduce using rule 25 (if_elseStatement -> IF LPAREN comparingValue RPAREN LCURLY ifStatementBody RCURLY ELSE ifStatementBody .) ]
  ! FN              [ reduce using rule 25 (if_elseStatement -> IF LPAREN comparingValue RPAREN LCURLY ifStatementBody RCURLY ELSE ifStatementBody .) ]
  ! ECHO            [ reduce using rule 25 (if_elseStatement -> IF LPAREN comparingValue RPAREN LCURLY ifStatementBody RCURLY ELSE ifStatementBody .) ]
  ! PRINT           [ reduce using rule 25 (if_elseStatement -> IF LPAREN comparingValue RPAREN LCURLY ifStatementBody RCURLY ELSE ifStatementBody .) ]
  ! INTEGER         [ reduce using rule 25 (if_elseStatement -> IF LPAREN comparingValue RPAREN LCURLY ifStatementBody RCURLY ELSE ifStatementBody .) ]
  ! FLOAT           [ reduce using rule 25 (if_elseStatement -> IF LPAREN comparingValue RPAREN LCURLY ifStatementBody RCURLY ELSE ifStatementBody .) ]
  ! STRING          [ reduce using rule 25 (if_elseStatement -> IF LPAREN comparingValue RPAREN LCURLY ifStatementBody RCURLY ELSE ifStatementBody .) ]
  ! BOOL            [ reduce using rule 25 (if_elseStatement -> IF LPAREN comparingValue RPAREN LCURLY ifStatementBody RCURLY ELSE ifStatementBody .) ]
  ! NULL            [ reduce using rule 25 (if_elseStatement -> IF LPAREN comparingValue RPAREN LCURLY ifStatementBody RCURLY ELSE ifStatementBody .) ]

    cuerpo                         shift and go to state 143
    arithmeticExpression           shift and go to state 3
    if_elseStatement               shift and go to state 4
    forStatement                   shift and go to state 5
    switchStatement                shift and go to state 6
    queueDeclaration               shift and go to state 7
    queueEnqueue                   shift and go to state 8
    queueDequeue                   shift and go to state 9
    defineFunction                 shift and go to state 10
    anonymousFunction              shift and go to state 11
    arrowFunction                  shift and go to state 12
    echo                           shift and go to state 13
    fgets                          shift and go to state 14
    stackDeclaration               shift and go to state 15
    stackPush                      shift and go to state 16
    stackPop                       shift and go to state 17
    line                           shift and go to state 18
    print                          shift and go to state 19
    value                          shift and go to state 20
    variableAsignation             shift and go to state 28

state 167

    (21) switchDefault -> DEFAULT COLON cuerpo .

    RCURLY          reduce using rule 21 (switchDefault -> DEFAULT COLON cuerpo .)


state 168

    (22) switchCase -> CASE value COLON cuerpo . BREAK SEMICOLON

    BREAK           shift and go to state 170


state 169

    (49) arrowBody -> FN LPAREN ID RPAREN . FNARROW arrowBody
    (48) arrowFunction -> FN LPAREN ID RPAREN . FNARROW arrowBody SEMICOLON

    FNARROW         shift and go to state 171


state 170

    (22) switchCase -> CASE value COLON cuerpo BREAK . SEMICOLON

    SEMICOLON       shift and go to state 172


state 171

    (49) arrowBody -> FN LPAREN ID RPAREN FNARROW . arrowBody
    (48) arrowFunction -> FN LPAREN ID RPAREN FNARROW . arrowBody SEMICOLON
    (49) arrowBody -> . FN LPAREN ID RPAREN FNARROW arrowBody
    (50) arrowBody -> . cuerpo
    (3) cuerpo -> . arithmeticExpression
    (4) cuerpo -> . if_elseStatement
    (5) cuerpo -> . forStatement
    (6) cuerpo -> . switchStatement
    (7) cuerpo -> . queueDeclaration
    (8) cuerpo -> . queueEnqueue
    (9) cuerpo -> . queueDequeue
    (10) cuerpo -> . defineFunction
    (11) cuerpo -> . anonymousFunction
    (12) cuerpo -> . arrowFunction
    (13) cuerpo -> . echo
    (14) cuerpo -> . fgets
    (15) cuerpo -> . stackDeclaration
    (16) cuerpo -> . stackPush
    (17) cuerpo -> . stackPop
    (18) cuerpo -> . line
    (19) cuerpo -> . print
    (57) arithmeticExpression -> . value arithmeticOperator value
    (25) if_elseStatement -> . IF LPAREN comparingValue RPAREN LCURLY ifStatementBody RCURLY ELSE ifStatementBody
    (26) if_elseStatement -> . IF LPAREN comparingValue RPAREN LCURLY ifStatementBody
    (30) forStatement -> . FOR LPAREN forStatementCondition RPAREN LCURLY forStatementBody RCURLY
    (20) switchStatement -> . SWITCH LPAREN value RPAREN LCURLY switchCases switchDefault RCURLY
    (39) queueDeclaration -> . ID EQUAL NEW QUEUE SEMICOLON
    (40) queueEnqueue -> . ID OBJOP PUSH LPAREN value RPAREN SEMICOLON
    (41) queueDequeue -> . ID OBJOP POP SEMICOLON
    (42) defineFunction -> . FUNCTION ID LPAREN arguments RPAREN LCURLY cuerpo RCURLY
    (43) defineFunction -> . FUNCTION ID LPAREN RPAREN LCURLY cuerpo RCURLY
    (46) anonymousFunction -> . FUNCTION LPAREN RPAREN LCURLY cuerpo RCURLY
    (47) anonymousFunction -> . FUNCTION LPAREN arguments RPAREN LCURLY cuerpo RCURLY
    (48) arrowFunction -> . FN LPAREN ID RPAREN FNARROW arrowBody SEMICOLON
    (51) echo -> . ECHO values SEMICOLON
    (56) fgets -> . ID EQUAL FGETS LPAREN STDIN RPAREN SEMICOLON
    (36) stackDeclaration -> . ID EQUAL NEW STACK SEMICOLON
    (37) stackPush -> . ID OBJOP PUSH LPAREN value RPAREN SEMICOLON
    (38) stackPop -> . ID OBJOP POP SEMICOLON
    (70) line -> . variableAsignation SEMICOLON
    (52) print -> . PRINT LPAREN values RPAREN SEMICOLON
    (53) print -> . PRINT value SEMICOLON
    (58) value -> . ID
    (59) value -> . INTEGER
    (60) value -> . FLOAT
    (61) value -> . STRING
    (62) value -> . BOOL
    (63) value -> . NULL
    (71) variableAsignation -> . ID EQUAL value
    (72) variableAsignation -> . ID EQUAL arithmeticExpression

    FN              shift and go to state 139
    IF              shift and go to state 21
    FOR             shift and go to state 22
    SWITCH          shift and go to state 23
    ID              shift and go to state 24
    FUNCTION        shift and go to state 25
    ECHO            shift and go to state 27
    PRINT           shift and go to state 29
    INTEGER         shift and go to state 30
    FLOAT           shift and go to state 31
    STRING          shift and go to state 32
    BOOL            shift and go to state 33
    NULL            shift and go to state 34

    arrowBody                      shift and go to state 173
    cuerpo                         shift and go to state 141
    arithmeticExpression           shift and go to state 3
    if_elseStatement               shift and go to state 4
    forStatement                   shift and go to state 5
    switchStatement                shift and go to state 6
    queueDeclaration               shift and go to state 7
    queueEnqueue                   shift and go to state 8
    queueDequeue                   shift and go to state 9
    defineFunction                 shift and go to state 10
    anonymousFunction              shift and go to state 11
    arrowFunction                  shift and go to state 12
    echo                           shift and go to state 13
    fgets                          shift and go to state 14
    stackDeclaration               shift and go to state 15
    stackPush                      shift and go to state 16
    stackPop                       shift and go to state 17
    line                           shift and go to state 18
    print                          shift and go to state 19
    value                          shift and go to state 20
    variableAsignation             shift and go to state 28

state 172

    (22) switchCase -> CASE value COLON cuerpo BREAK SEMICOLON .

    DEFAULT         reduce using rule 22 (switchCase -> CASE value COLON cuerpo BREAK SEMICOLON .)
    CASE            reduce using rule 22 (switchCase -> CASE value COLON cuerpo BREAK SEMICOLON .)


state 173

    (49) arrowBody -> FN LPAREN ID RPAREN FNARROW arrowBody .
    (48) arrowFunction -> FN LPAREN ID RPAREN FNARROW arrowBody . SEMICOLON

  ! shift/reduce conflict for SEMICOLON resolved as shift
    SEMICOLON       shift and go to state 158

  ! SEMICOLON       [ reduce using rule 49 (arrowBody -> FN LPAREN ID RPAREN FNARROW arrowBody .) ]

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for RCURLY in state 124 resolved as shift
WARNING: shift/reduce conflict for IF in state 124 resolved as shift
WARNING: shift/reduce conflict for FOR in state 124 resolved as shift
WARNING: shift/reduce conflict for SWITCH in state 124 resolved as shift
WARNING: shift/reduce conflict for ID in state 124 resolved as shift
WARNING: shift/reduce conflict for FUNCTION in state 124 resolved as shift
WARNING: shift/reduce conflict for FN in state 124 resolved as shift
WARNING: shift/reduce conflict for ECHO in state 124 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 124 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 124 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 124 resolved as shift
WARNING: shift/reduce conflict for STRING in state 124 resolved as shift
WARNING: shift/reduce conflict for BOOL in state 124 resolved as shift
WARNING: shift/reduce conflict for NULL in state 124 resolved as shift
WARNING: shift/reduce conflict for CONTINUE in state 125 resolved as shift
WARNING: shift/reduce conflict for IF in state 166 resolved as shift
WARNING: shift/reduce conflict for FOR in state 166 resolved as shift
WARNING: shift/reduce conflict for SWITCH in state 166 resolved as shift
WARNING: shift/reduce conflict for ID in state 166 resolved as shift
WARNING: shift/reduce conflict for FUNCTION in state 166 resolved as shift
WARNING: shift/reduce conflict for FN in state 166 resolved as shift
WARNING: shift/reduce conflict for ECHO in state 166 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 166 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 166 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 166 resolved as shift
WARNING: shift/reduce conflict for STRING in state 166 resolved as shift
WARNING: shift/reduce conflict for BOOL in state 166 resolved as shift
WARNING: shift/reduce conflict for NULL in state 166 resolved as shift
WARNING: shift/reduce conflict for SEMICOLON in state 173 resolved as shift
WARNING: reduce/reduce conflict in state 98 resolved using rule (stackPop -> ID OBJOP POP SEMICOLON)
WARNING: rejected rule (queueDequeue -> ID OBJOP POP SEMICOLON) in state 98
WARNING: reduce/reduce conflict in state 153 resolved using rule (stackPush -> ID OBJOP PUSH LPAREN value RPAREN SEMICOLON)
WARNING: rejected rule (queueEnqueue -> ID OBJOP PUSH LPAREN value RPAREN SEMICOLON) in state 153
WARNING: Rule (queueDequeue -> ID OBJOP POP SEMICOLON) is never reduced
WARNING: Rule (queueEnqueue -> ID OBJOP PUSH LPAREN value RPAREN SEMICOLON) is never reduced
